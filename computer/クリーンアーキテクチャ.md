※画像はWebもしくは「Clean Architecture　達人に学ぶソフトウェアの構造と設計 (アスキードワンゴ) Kindle版」から引用  

# SRP：単一責任原則  
アクターの異なるコードは分離するべきだ。  
※アクター... 変更を望む人たちをひとまとめにしたグループ。  
同じような変更を望む人たちは同じグループであり一つのアクターで表現される。  
  
3つのアクターを持つEmployeeクラスがある場合の対策：  
3つのアクターの要望に応える3つのメソッドを、3つのドメインサービスとして切り出す。  
さらに利便性のために3つのドメインサービスを取りまとめるFacadeを用意しても良いし、  
データの近くに振る舞いを持たせたければEmployeeにドメインサービスをダブルディスパッチさせる方法もある。  
  
そもそも3種類のEmployeeクラスにモデリングすることが正しいだろう。  


# OCP：オープン・クローズドの原則  
変更の影響を受けずにシステムを拡張しやすくするべきだ。  
方向の制御と情報隠蔽により実現する。  
### 方向の制御  
依存関係逆転の原則（DIP）を適用する。つまり処理の流れ（方針→詳細）と依存関係を逆転させるが、  
そのときビジネスロジック（ドメイン層）が最上位となるように設計する。（ドメイン層が詳細に依存しない）  
  
### 情報隠蔽  
ドメイン層の利用者がドメイン層の内部を知りすぎないように、ドメイン層側にインターフェースを用意する。  
これにより利用者がドメインオブジェクトに推移的に依存することを防ぎ、ドメイン層の変更の影響を受けないようにする。  
推移的な依存関係は「ソフトウェアのエンティティは自分が直接使っていないものに依存すべきではない」という大原則に違反しており、  
これはインターフェース分離の原則（ISP）や全再利用の原則（CRP）が関連する。  
  
  
# コンポーネントの凝集性に関する原則（REP・CCP・CRP）の関係性  
REP・CCP・CRPはそれぞれ目的が異なる。これらに従ったプラクティスは  
目的を達成するためにパッケージを大きくするものもあれば、小さくするものもある。  
相反する動きがあるためアーキテクトはバランスを取りながら「いいとこ取り」していく。  
<img src="/picture/クリーンアーキテクチャ13.png" width="600px">
  
### 再利用・リリース等価の原則：REP  
ソフトウェアは再利用される時代である。ユーザーは再利用するコンポーネントについて  
新機能の内容を吟味したり、リリース番号とドキュメントから依存するコンポーネントとの互換性を考えて利用を決めたりする。  
これをアーキテクチャの観点で見ると、コンポーネントが適当なクラスの集まりであってはならず一貫するテーマや目的がなければならない。  
またこの原則の根本は利用ユーザーにとって再利用性が高いものすることである。  
```  
再利用性が高いコンポーネントは  
一つのコンポーネントにユーザーの目的にとって必要なものが揃っているので多くのパッケージに依存する必要がなく  
詳細（ユーザーがカスタマイズすべきところ）が含まれていない。  
```  
ユーザーが多くのパッケージから必要なクラスを抽出して再利用されるようでは、ユーザーの管理が大変になってしまう。  
（再利用の単位とリリースの単位が同じでなければならない）  
  
##### REPに従うプラクティスはコンポーネントを大きくする。  
  
### 閉鎖性共通の原則：CCP  
単一責任原則（SRP）をコンポーネント向けに言い換えたもので、コンポーネントを変更する理由が複数あるべきではない。  
これは変更の理由と頻度が異なるクラスを別のコンポーネントに入れろということだけではなく（むしろそれは当たり前）  
物理的あるいは概念的に結合するクラスは同じタイミングで変更されるので一つにまとめておけということだ。  
そうすることでひとつの変更であちこちを変更する必要がなくなる。  
「閉鎖性」という言葉はオープン・クローズドの原則（OCP）の「クローズド」と同じ意味で使われている。  
OCPでは変更に閉じ拡張に開いてなければならないが、完全に閉じることはできないので戦略的なアプローチで可能な限り閉じなければならない。  
そのためCCPにより、想定される変更に対して影響を最小コンポーネントに閉じるようにしておく。  
  
##### CCPに従うプラクティスはコンポーネントを大きくする。  
  
### 全再利用の原則：CRP  
コンポーネントが他のコンポーネントに依存する場合、他のコンポーネントの中のたった一つのクラスに変更があったとしても影響を受ける。  
その変更がコンポーネントにとって全く関係のない変更であっても、再デプロイ・再テストが必要になる。  
そのためコンポーネントに依存するのであれば、コンポーネントに含まれる全てのクラスに依存するようにしておきたい。  
CRPは密結合していないクラスは別のコンポーネントに分けろとしている。  
  
##### CRPに従うプラクティスはコンポーネントを小さくする。  
  

# その他の原則
「アジャイルソフトウェア開発の奥義」を参照  
https://github.com/sasachichito/knowledge/blob/master/computer/%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA.md  


# 独立性  
優れたアーキテクチャは以下のことをサポートしなければならない。  
```
・システムのユースケース
・システムの運用
・システムの開発
・システムのデプロイ
```
そのためにはシステムを適切に切り離し、独立性を持たせる必要がある。  
  
切り離し方式には以下のレベルがある。  
```  
ソースレベル... パッケージ  
デプロイレベル... jar  
サービスレベル... サービス  
```  
  
### レイヤの切り離し  
UI、ユースケース、ビジネスロジック、インフラストラクチャは異なる頻度や理由で変更されるため  
これらをレイヤにより水平に切り離す。  
  
### ユースケースの切り離し  
ユースケースはシステムの水平レイヤを薄く垂直にスライスしたものである。  
別々のユースケース（注文追加・注文削除など）はUIを別々に分けたり、  
インフラストラクチャをユースケース毎にグループ化することで新しいユースケースを追加しても古いユースケースに影響を与えずに済む。  

# 境界線
ソフトウェアアーキテクチャとは、境界線を引く芸当である。これを「バウンダリー」と呼ぶ。  
システムに独立性を与えるためにはこれを実施する必要がある。  

### ソースレベルの切り離し
ソースレベルの切り離し方式では、境界をどのように引くべきか。  
方法としてはレイヤ化アーキテクチャやヘキサゴナルアーキテクチャを用いる。  
    
```  
ユーザーインターフェース層... ユーザーにアプリケーションの使い方を提供する  
アプリケーション層... ビジネスロジックの使い方を提供する  
ドメイン層... ビジネスロジックを提供する  
インフラストラクチャ層... 記録や通信の仕組み（マシンリソースの使い方）を提供する。  
ポート&アダプター層... アプリケーションの使い方を提供する  
```  
※ポート&アダプターパターン（ヘキサゴナルアーキテクチャ）  
アプリケーションを、ユーザー、プログラム、自動テストあるいはバッチスクリプトから、同じように駆動できるようにする設計。    

```  
最も上位レベル：ドメイン層  
次に上位レベル：アプリケーション層  
下位レベル：ユーザーインターフェース層、インフラストラクチャ層、ポート&アダプター層  

上位レベル... 方針を含んだモジュール（クラス・コンポーネント）  
下位レベル... 詳細を含んだモジュール（クラス・コンポーネント）  
```  

境界の越え方(依存の方向）が重要である。  
  
上位レベルのモジュールは下位モジュールに依存してはいけない。（方針が詳細に振り回されてはいけない。詳細はプラグインであるべき。DIP）  
アプリケーション層にとってユーザーにどのように利用されるかは詳細にすぎないし、  
ユーザーはアプリケーション層の方針に従って利用する。  

### デプロイレベルの切り離し
デプロイレベルとはjarのことを指す。（ライブラリとしてのjarであり実行可能jarやwarではない）  
全ての機能が同一プロセッサとアドレス空間に属するため、ソースレベルの切り離しと同じになる。  
  
### サービスレベルの切り離し
最も強い境界である。下位レベルのサービスは上位レベルのサービスに「プラグイン」されるべきである。  
上位レベルのサービスのソースコードには、下位レベルのサービスの物理的な情報（URIなど）を含めてはいけない。    

# 方針とレベル  
優れたアーキテクチャではどんな場合でも下位レベルのコンポーネントが上位レベルのコンポーネントに依存するように設計する。  
「レベル」の厳密な定義は「入力と出力からの距離」である。  
  
# 叫ぶアーキテクチャ  
アーキテクチャは、システムで使用しているフレームワークではなくドメインについての情報を伝える必要がある。  
例えばヘルスケアシステムを構築しているならば  
新しく参加したプログラマがリポジトリを見たときに、「ああ、これはヘルスケアシステムだ」と思えるようにしておくべきだ。  
  
# クリーンアーキテクチャ  
![クリーンアーキテクチャ](/picture/クリーンアーキテクチャ.jpeg "クリーンアーキテクチャ")  
![クリーンアーキテクチャ2](/picture/クリーンアーキテクチャ2.jpeg "クリーンアーキテクチャ2")  
![クリーンアーキテクチャ3](/picture/クリーンアーキテクチャ3.jpeg "クリーンアーキテクチャ3")  
  
  
DDDで用いるヘキサゴナルアーキテクチャは以下  
![ヘキサゴナルアーキテクチャ](/picture/ヘキサゴナルアーキテクチャ.png "ヘキサゴナルアーキテクチャ")  
  
  
# Humble Objectパターン  
Humble Objectパターンは、テストしにくい振る舞いを2つに分割することでテストをしやすくする考え方である。  
そのときどちらかをHumble（控えめ）にする。  
  
GUIの振る舞いの例では  
PresenterとViewの2つに分割し、ViewはHumbleオブジェクトとしてシンプルな振る舞いしか持たせない。  
参考：https://qiita.com/nrslib/items/a5f902c4defc83bd46b8  
  
データベースアクセスの例では  
データベースゲートウェイ（DDDにおけるリポジトリ）パターンがHumble Objectパターンの実装となる。  
リポジトリインターフェースの利用側と実装側の2つに分割し、実装する側をHumbleにする。  
  
サービスレベルでの分割もHumble Objectパターンで境界を作成することができる。  
  
アーキテクチャの境界の近くには、Humble Objectパターンが潜んでいる。  
境界を越える通信には、シンプルなデータ構造が含まれているように設計することで、  
境界がテストしにくい部分とテストしやすい部分に分割するようになる。  
そしてシステム全体のテスト容易性が大幅に向上する。  

# 部分的な境界  
本格的なアーキテクチャ境界はコストが高いため、部分的な境界を実装することも選択肢としてある。  
  
### 片方だけの境界（Strategy）  
Strategyパターンにより、下位レベルのクライアントから上位レベルのサービスへ境界を超える時にはサービス実装を気にしないが、  
サービス実装からのレスポンスは依存関係逆転なしで直接受け取る。  
上位レベルの変更の影響を下位レベルがもろに受ける。  
<img src="/picture/クリーンアーキテクチャ5.png" width="500px">
  
### シンプルな境界（Facade）  
片方だけの境界よりもシンプルな境界はFacadeパターンで実現する。  
下位レベルのクライアントは全てのサービス実装に推移的に依存している。  
サービス実装の変更はクライアントに影響を与える。  
<img src="/picture/クリーンアーキテクチャ4.png" width="500px">

# YAGNI  
YAGNI（You Aren't Going to Need It：あとで必要になることはない）の哲学では、抽象化が必要になることを予測してはいけないと提唱している。  
しかしアーキテクチャ境界が必要なところになかったとしたら、境界を追加するコストやリスクは非常に高いものとなる。  
ソフトウェアアーキテクトは未来に目を向けなければならない。  
頭を使って推測し、どこにアーキテクチャ境界があり、YAGNIとのバランスを取りながらどこまで実装するべきか判断しなければならない。  

# 事例  
システムの最初のアーキテクチャを決めるための第一歩は、アクターとユースケースを見つけることだ。  
<img src="/picture/クリーンアーキテクチャ6.png" width="500px">

アクターとユースケースがわかったので、とりあえずコンポーネントアーキテクチャを検討できるようになった。  
<img src="/picture/クリーンアーキテクチャ7.png" width="500px">
  
# 設計・コーディングのアプローチ  
悪魔は実装の詳細に宿る。気をつけておかないと最後の最後でつまずいてしまう。  
  
### レイヤーによるパッケージング  
Martin Fowlerや他の多くの人が最初はレイヤードアーキテクチャに従うのが得策だと述べている。シンプルだからだ。  
しかしソフトウェアが巨大になっていくと、コードを各レイヤのバケツに分けるだけでは手に負えなくなってしまう。  
また、レイヤードアーキテクチャはビジネスドメインについて何も叫ばない。全く異なるビジネスドメインのコードを並べてもそっくりになってしまう。  
<img src="/picture/クリーンアーキテクチャ8.png" width="200px">
  
### 機能によるパッケージング  
レイヤーは水平だが、こちらは垂直に分割しパッケージングする。  
関連する機能、ドメインの概念、集約のルート(DDD)に基づいて分割する。  
トップレベルのコードがビジネスドメインについて叫ぶようになり、また修正すべきユースケースが明確になる。  
<img src="/picture/クリーンアーキテクチャ9.png" width="200px">
水平レイヤーリング（レイヤーによるパッケージング）がうまくいかないチームが垂直レイヤーリング（機能によるパッケージング）に切り替える事例をよく見かける。  
もっと良いやり方がある。（ポート＆アダプター）  
  
### ポート＆アダプター  
ヘキサゴナルアーキテクチャのこと。  
<img src="/picture/クリーンアーキテクチャ10.png" width="200px">
<img src="/picture/クリーンアーキテクチャ11.png" width="200px">
  
### コンポーネントによるパッケージング  
「ビジネスロジック」と永続化コードを一つにまとめて「コンポーネント」にする。  
<img src="/picture/クリーンアーキテクチャ12.png" width="200px">

# メモ
```
・Humbleオブジェクトパターン再考
大前提：UI、ユースケース、ビジネスロジック、インフラストラクチャは異なる頻度や理由で変更されるためレイヤとして切り離されていなければならない。

各レイヤはレベルが異なる。「レベル」の定義は「入力と出力からの距離」である。レベルが違うと相手にするロジックの種別が異なる。
レベルが交わる場所には境界がある。
境界をまたがったクラスがある場合、異なる種別のロジックが交わっているためテストが難しい。
テスト観点が異なるし、テスト内容が境界をまたがっているため異なる頻度や理由で変更されるからだ。

ここでHumbleオブジェクトパターンの考えを用いる。目的は境界をまたがったクラスを2つに分離し、テストしやすくすることだ。
分離するということは、境界をまたぐメソッド呼び出しを最大限にシンプルにすることを指す。
方法としては境界の片方のロジックを経た結果をオブジェクトではなくデータ構造として、境界の向こうへメソッド呼び出しで渡す。
受け取った側では、境界の反対側で起きたことを一切認識することなく渡されたデータ構造を読み込みだけでシンプルに利用する。

こうすることで、データ構造を作るロジックのテストと、受け取ったデータ構造を利用するテストに分離される。
境界の向こうをモックにするなどしてテストの容易性を格段に向上させることができる。
```
