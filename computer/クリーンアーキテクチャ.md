※画像はWebもしくは「Clean Architecture　達人に学ぶソフトウェアの構造と設計 (アスキードワンゴ) Kindle版」から引用  

# SRP：単一責任原則  
アクターの異なるコードは分離するべきだ。  
※アクター... 変更を望む人たちをひとまとめにしたグループ。  
同じような変更を望む人たちは同じグループであり一つのアクターで表現される。  
  
3つのアクターを持つEmployeeクラスがある場合の対策：  
3つのアクターの要望に応える3つのメソッドを、3つのドメインサービスとして切り出す。  
さらに利便性のために3つのドメインサービスを取りまとめるFacadeを用意しても良いし、  
データの近くに振る舞いを持たせたければEmployeeにドメインサービスをダブルディスパッチさせる方法もある。  
  
そもそも3種類のEmployeeクラスにモデリングすることが正しいだろう。  


# OCP：オープン・クローズドの原則  
変更の影響を受けずにシステムを拡張しやすくするべきだ。  
方向の制御と情報隠蔽により実現する。  
### 方向の制御  
依存関係逆転の原則（DIP）を適用する。つまり処理の流れ（方針→詳細）と依存関係を逆転させるが、  
そのときビジネスロジック（ドメイン層）が最上位となるように設計する。（ドメイン層が詳細に依存しない）  
  
### 情報隠蔽  
ドメイン層の利用者がドメイン層の内部を知りすぎないように、ドメイン層側にインターフェースを用意する。  
これにより利用者がドメインオブジェクトに推移的に依存することを防ぎ、ドメイン層の変更の影響を受けないようにする。  
推移的な依存関係は「ソフトウェアのエンティティは自分が直接使っていないものに依存すべきではない」という大原則に違反しており、  
これはインターフェース分離の原則（ISP）や全再利用の原則（CRP）が関連する。  
  
  
# その他の原則
「アジャイルソフトウェア開発の奥義」を参照  
https://github.com/sasachichito/knowledge/blob/master/computer/%E3%82%A2%E3%82%B8%E3%83%A3%E3%82%A4%E3%83%AB%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E9%96%8B%E7%99%BA.md  


# 独立性  
優れたアーキテクチャは以下のことをサポートしなければならない。  
```
・システムのユースケース
・システムの運用
・システムの開発
・システムのデプロイ
```
そのためにはシステムを適切に切り離し、独立性を持たせる必要がある。  
  
切り離し方式には以下のレベルがある。  
```  
ソースレベル... パッケージ  
デプロイレベル... jar  
サービスレベル... サービス  
```  
  
### レイヤの切り離し  
UI、ユースケース、ビジネスロジック、インフラストラクチャは異なる頻度や理由で変更されるため  
これらをレイヤにより水平に切り離す。  
  
### ユースケースの切り離し  
ユースケースはシステムの水平レイヤを薄く垂直にスライスしたものである。  
別々のユースケース（注文追加・注文削除など）はUIを別々に分けたり、  
インフラストラクチャをユースケース毎にグループ化することで新しいユースケースを追加しても古いユースケースに影響を与えずに済む。  

# 境界線
ソフトウェアアーキテクチャとは、境界線を引く芸当である。これを「バウンダリー」と呼ぶ。  
システムに独立性を与えるためにはこれを実施する必要がある。  

### ソースレベルの切り離し
ソースレベルの切り離し方式では、境界をどのように引くべきか。  
方法としてはレイヤ化アーキテクチャやヘキサゴナルアーキテクチャを用いる。  
    
```  
ユーザーインターフェース層... ユーザーにアプリケーションの使い方を提供する  
アプリケーション層... ビジネスロジックの使い方を提供する  
ドメイン層... ビジネスロジックを提供する  
インフラストラクチャ層... 記録や通信の仕組み（マシンリソースの使い方）を提供する。  
ポート&アダプター層... アプリケーションの使い方を提供する  
```  
※ポート&アダプターパターン（ヘキサゴナルアーキテクチャ）  
アプリケーションを、ユーザー、プログラム、自動テストあるいはバッチスクリプトから、同じように駆動できるようにする設計。    

```  
最も上位レベル：ドメイン層  
次に上位レベル：アプリケーション層  
下位レベル：ユーザーインターフェース層、インフラストラクチャ層、ポート&アダプター層  

上位レベル... 方針を含んだモジュール（クラス・コンポーネント）  
下位レベル... 詳細を含んだモジュール（クラス・コンポーネント）  
```  

境界の越え方(依存の方向）が重要である。  
  
上位レベルのモジュールは下位モジュールに依存してはいけない。（方針が詳細に振り回されてはいけない。詳細はプラグインであるべき。DIP）  
アプリケーション層にとってユーザーにどのように利用されるかは詳細にすぎないし、  
ユーザーはアプリケーション層の方針に従って利用する。  

### デプロイレベルの切り離し
デプロイレベルとはjarのことを指す。（ライブラリとしてのjarであり実行可能jarやwarではない）  
全ての機能が同一プロセッサとアドレス空間に属するため、ソースレベルの切り離しと同じになる。  
  
### サービスレベルの切り離し
最も強い境界である。下位レベルのサービスは上位レベルのサービスに「プラグイン」されるべきである。  
上位レベルのサービスのソースコードには、下位レベルのサービスの物理的な情報（URIなど）を含めてはいけない。    

# 方針とレベル  
優れたアーキテクチャではどんな場合でも下位レベルのコンポーネントが上位レベルのコンポーネントに依存するように設計する。  
「レベル」の厳密な定義は「入力と出力からの距離」である。  
  
# 叫ぶアーキテクチャ  
アーキテクチャは、システムで使用しているフレームワークではなくドメインについての情報を伝える必要がある。  
例えばヘルスケアシステムを構築しているならば  
新しく参加したプログラマがリポジトリを見たときに、「ああ、これはヘルスケアシステムだ」と思えるようにしておくべきだ。  
  
# クリーンアーキテクチャ  
![クリーンアーキテクチャ](/picture/クリーンアーキテクチャ.jpeg "クリーンアーキテクチャ")  
![クリーンアーキテクチャ2](/picture/クリーンアーキテクチャ2.jpeg "クリーンアーキテクチャ2")  
![クリーンアーキテクチャ3](/picture/クリーンアーキテクチャ3.jpeg "クリーンアーキテクチャ3")  
  
  
DDDで用いるヘキサゴナルアーキテクチャは以下  
![ヘキサゴナルアーキテクチャ](/picture/ヘキサゴナルアーキテクチャ.png "ヘキサゴナルアーキテクチャ")  
  
  
# Humble Objectパターン  
Humble Objectパターンは、テストしにくい振る舞いを2つに分割することでテストをしやすくする考え方である。  
そのときどちらかをHumble（控えめ）にする。  
  
GUIの振る舞いの例では  
PresenterとViewの2つに分割し、ViewはHumbleオブジェクトとしてシンプルな振る舞いしか持たせない。  
参考：https://qiita.com/nrslib/items/a5f902c4defc83bd46b8  
  
データベースアクセスの例では  
データベースゲートウェイ（DDDにおけるリポジトリ）パターンがHumble Objectパターンの実装となる。  
リポジトリインターフェースの利用側と実装側の2つに分割し、実装する側をHumbleにする。  
  
サービスレベルでの分割もHumble Objectパターンで境界を作成することができる。  
  
アーキテクチャの境界の近くには、Humble Objectパターンが潜んでいる。  
境界を越える通信には、シンプルなデータ構造が含まれているように設計することで、  
境界がテストしにくい部分とテストしやすい部分に分割するようになる。  
そしてシステム全体のテスト容易性が大幅に向上する。  

# 部分的な境界  
本格的なアーキテクチャ境界はコストが高いため、部分的な境界を実装することも選択肢としてある。  
  
### 片方だけの境界（Strategy）  
Strategyパターンにより、下位レベルのクライアントから上位レベルのサービスへ境界を超える時にはサービス実装を気にしないが、  
サービス実装からのレスポンスは依存関係逆転なしで直接受け取る。  
上位レベルの変更の影響を下位レベルがもろに受ける。  
<img src="/picture/クリーンアーキテクチャ5.png" width="500px">
  
### シンプルな境界（Facade）  
片方だけの境界よりもシンプルな境界はFacadeパターンで実現する。  
下位レベルのクライアントは全てのサービス実装に推移的に依存している。  
サービス実装の変更はクライアントに影響を与える。  
<img src="/picture/クリーンアーキテクチャ4.png" width="500px">

# YAGNI  
YAGNI（You Aren't Going to Need It：あとで必要になることはない）の哲学では、抽象化が必要になることを予測してはいけないと提唱している。  
しかしアーキテクチャ境界が必要なところになかったとしたら、境界を追加するコストやリスクは非常に高いものとなる。  
ソフトウェアアーキテクトは未来に目を向けなければならない。  
頭を使って推測し、どこにアーキテクチャ境界があり、YAGNIとのバランスを取りながらどこまで実装するべきか判断しなければならない。  

# 事例  
システムの最初のアーキテクチャを決めるための第一歩は、アクターとユースケースを見つけることだ。  
<img src="/picture/クリーンアーキテクチャ6.png" width="500px">

アクターとユースケースがわかったので、とりあえずコンポーネントアーキテクチャを検討できるようになった。  
<img src="/picture/クリーンアーキテクチャ7.png" width="500px">
  
# 設計・コーディングのアプローチ  
悪魔は実装の詳細に宿る。気をつけておかないと最後の最後でつまずいてしまう。  
  
### レイヤーによるパッケージング  
Martin Fowlerや他の多くの人が最初はレイヤードアーキテクチャに従うのが得策だと述べている。シンプルだからだ。  
しかしソフトウェアが巨大になっていくと、コードを各レイヤのバケツに分けるだけでは手に負えなくなってしまう。  
また、レイヤードアーキテクチャはビジネスドメインについて何も叫ばない。全く異なるビジネスドメインのコードを並べてもそっくりになってしまう。  
<img src="/picture/クリーンアーキテクチャ8.png" width="200px">
  
### 機能によるパッケージング  
レイヤーは水平だが、こちらは垂直に分割しパッケージングする。  
関連する機能、ドメインの概念、集約のルート(DDD)に基づいて分割する。  
トップレベルのコードがビジネスドメインについて叫ぶようになり、また修正すべきユースケースが明確になる。  
<img src="/picture/クリーンアーキテクチャ9.png" width="200px">
水平レイヤーリング（レイヤーによるパッケージング）がうまくいかないチームが垂直レイヤーリング（機能によるパッケージング）に切り替える事例をよく見かける。  
もっと良いやり方がある。（ポート＆アダプター）  
  
### ポート＆アダプター  
ヘキサゴナルアーキテクチャのこと。  
<img src="/picture/クリーンアーキテクチャ10.png" width="200px">
<img src="/picture/クリーンアーキテクチャ11.png" width="200px">
  
### コンポーネントによるパッケージング  
「ビジネスロジック」と永続化コードを一つにまとめて「コンポーネント」にする。  
<img src="/picture/クリーンアーキテクチャ12.png" width="200px">
