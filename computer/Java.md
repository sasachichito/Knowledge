# データベース接続
【参考】http://www.atmarkit.co.jp/ait/articles/0106/26/news001.html  
## JDBC  
データベースに接続するためのインターフェース（を定めるJavaの標準APIのこと）。  
  
## JDBCドライバマネージャー  
JDBCを実装したクラス。  
プログラマが作成するJavaクラスから利用される。  
JDBCドライバのラッパーになっている。  
  
## JDBCドライバ  
実際にDBに接続するクラス。  
JDBCドライバマネージャーにラップされるため、  
JDBCドライバインターフェースを実装している必要がある。  

# Javaとスレッド  
Javaプログラミングで可能なスレッド操作は、大きく分けて二つある。  
  
- **新しいスレッドで処理させる**  
スレッドの処理内容を定義したインスタンスをnew  
↓  
startメソッドでスレッドを作成・起動。  
※startメソッドをコールするまではスレッドは存在しない。  
- **複数スレッド実行時の挙動を制御する**  
メソッドを実行するであろう複数スレッド群に対して  
あらかじめクラス側で制御処理を書いておく。  

# 例外  
  
## 例外処理とは  
アプリケーションには処理の起点がある。  
Javaであればmainスレッドが実行するmainメソッドか  
mainスレッドから派生したスレッドのrunメソッドのどちらかである。  
https://teratail.com/questions/115164  
これらの起点メソッドが別メソッドを実行し、その先で問題が発生したとする。  
起点メソッドはその問題を検知したい。  
なぜなら起点メソッドが正常終了することはすなわちアプリケーションが正常に動作し終了したということであるから、  
問題が発生したのであれば異常終了しなければならないから。  
そのための仕組みとしてJavaには「例外」がある。  
  
呼び出し元に「例外をスローする」ことで問題が発生したと伝えることが出来る。  
呼び出し元では「例外をキャッチ」して、問題発生時の処理を書かなければいけない。  
  
これを徹底し、起点メソッドが例外をキャッチしなければアプリケーションは正常に終了することになる。  
  
## Javaの例外  
例外には2種類ある  
- 検査例外  
どうしても発生する可能性がある場合にスローする  
- 非検査例外  
適切に扱えば避けられる問題が発生した場合にスローする  
  
検査例外はファイルが見つからない、SQLが実行できないなど、  
アプリケーション側で抑制できない問題が発生したことを呼び出し元に伝える例外である。  
検査例外をスローするメソッドを呼び出す場合、例外をキャッチするか、さらに呼び出し元にスローしなければ  
コンパイルエラーになる。  
  
非検査例外はキャッチしなくてもコンパイルエラーにならない。  
非検査例外がスローされキャッチしていなければ、その時点で異常終了扱いになる。  
  
どちらであっても「例外をキャッチ」した場合、  
握りつぶすか、再スローのどちらかの処理をする。  
- 握りつぶす  
あるメソッドでキャッチして何もしなければ、そのメソッドで例外を握りつぶしたことになる。  
もちろん起点メソッドまで問題発生が伝わることがないので、アプリケーションは正常に動作していると扱われる。  
その例外が発生することも想定内であるときの処理となる。  
- 再スロー  
あるメソッドで例外をキャッチしたとき、呼び出し元に問題発生を伝えるために例外をスローする。  
これを繰り返すと起点メソッドに問題発生が伝わり、アプリケーションが異常であると扱われる。  
  
# equalsメソッドとhashCodeメソッドのオーバーライド  
##### equalsをオーバーライドしていない自作のクラスは、これらのメソッドは何をしている？  
＝＝で比較しているだけ、つまり同じインスタンスじゃないとエラーになる。  
##### hashSetに格納したり、hashMapのキーとして使うならequalsメソッドとともにhashCodeメソッドも実装しなければならない  
##### equalsがtrueを返却する場合、それらhashCodeは必ず同じハッシュ値を返さなければならない(返さないとハッシュアルゴリズムを利用したクラスが正常に動作しない)  
http://education.yachinco.net/tips/java/01/4.html  
##### equalsがfalseを返却する場合、それらhashCodeは異なるハッシュ値を返さなくても構わない(しかしハッシュアルゴリズムを利用したクラスのパフォーマンスが向上しない)  
##### Lombokでハッシュ計算ができる？@EqualsAndHashCodeアノテーションをクラスにつけてあげる  
##### IDEにequalsとhashCodeメソッドの自動生成機能がある  
##### 自前でオーバーライドする場合はObjects.hashメソッドを使う  
https://qiita.com/frost_star/items/8a5d711f9090f0e24f51  
##### samePropertyValuesAsではどんな比較をしている？  
比較対象オブジェクトのプロパティ一覧出してそれぞれを、IsEqualクラスのmatchesメソッドで比較している。  
matchesメソッドはプロパティのequalsメソッドを実行している。  
```  
・比較対象のプロパティの一覧をそれぞれ取得  
・それぞれの一覧の数や名前に差分がないか比較  
・一つづつequalsメソッドで比較  
```  
# クラスの種類  
### トップレベルクラス  
通常のクラス  
### ネストしたクラス  
staticメンバークラス、  
とも呼ばれる。  
トップレベルクラス（外部クラス）のメンバの１つとして定義されているクラスで、static修飾子が付いているもの。  
```  
基本的に「外部クラス名.メンバークラス名」で利用する。  
外部クラスのメンバーにアクセス出来るが、staticなものに限られる。  
```  
外部クラスやそのインスタンスとの関係が比較的薄い。  
  
### インナークラス  
非staticメンバークラス、  
内部クラス、  
とも呼ばれる。  
トップレベルクラス（外部クラス）のメンバの１つとして定義されているクラスで、static修飾子が付いていないもの。  
```  
基本的に「外部クラス名.メンバークラス名」で利用する。  
結び付いている外部インスタンスの非staticメンバーにもアクセス出来る。   
```  
インスタンス化は、外部クラスのインスタンス変数名.new メンバークラスコンストラクタ呼び出し、となる。  
外部クラスのインスタンス(エンクロージングインスタンス)の参照を持つため、バグやGCの思わぬ挙動の原因になりやすい  
  
### ローカルインナークラス、  
ローカル内部クラス、  
ローカルクラス、  
とも呼ばれる。  
インナークラスの一種。  
メソッドやイニシャライザ、コンストラクタで宣言されたクラス。  
クラスの継承やインターフェース実装が可能。  
  
### 匿名インナークラス  
匿名クラス内部クラス、  
匿名クラス、  
無名インナークラス、  
無名内部クラス、  
無名クラス、  
とも呼ばれる。  
インナークラスの一種。  
newと同時にブロックで定義したクラス。  
クラスに名前を持たないのでコンストラクタを定義できない（インスタンスイニシャライザで代替することが多い）。  
  
  
## 日時系
```
人間は１日をだいたい朝・昼・夜に分けて考える。  
「9時は朝」「13時は昼」といった認識を全世界で共有しないと不便である。  
ある瞬間を考えたとき、日本が朝でも、ブラジルでは夜かもしれない。  
つまり同じ共通の時間を利用できない。  
そこで唯一の標準時間(UTC)を定め、各地にはその差分を定義する形にする。（日本の場合は+9時間）  
ある瞬間を考えたとき、当然だがUTCは一意に決まる。  
日本時間はそのUTCに差分の9時間加えると算出できる。  
差分の定義を持つ各地をタイムゾーンという。  
  
unixタイムとはエポック秒とも呼ばれ、UTCの「1970/1/1 00:00:00」からの経過秒数である。  
当然だが、ある日時にはタイムゾーンがどこであろうと必ず唯一のunixタイムがあり、そこからUTCがわかる。  
Javaでunixタイムを表現するのはInstantオブジェクトである。  
System.curremntTimeMillis() は直接unixタイムをlong値で取得できる。  
  
ClockはタイムゾーンかもしくはUTCの指定と、時間の進み方（1分ずつなど）の設定を持つクラスで、日時を表すクラスの生成に利用される。  
Clockは自分のインスタンスが生成された瞬間から日時を保持し、設定通りに日時が進めていく。  
Clockをもとに生成された「日時を表すクラス」は、そのときのClockの日時となる。  
Clockをタイムゾーン/UTCの指定ではなく日時を指定してインスタンス生成すると、日時が進まない。  
  
日時を表すクラスには、Local・Offset・Zonedの3種類が存在する。  
参考：http://www.ne.jp/asahi/hishidama/home/tech/java/datetime.html  
```

## 数値系
```
小数を扱う方法として固定小数点と浮動小数点がある。

固定小数点とは
小数点が特定の位置にある前提で数値を扱う方法。

浮動小数点数とは
仮数部と指数部で数値を扱う方法。

Javaではリテラルの浮動小数点をfloat型とdouble型に格納できる。
floatとdoubleは内部で数値を2進数で管理している。

10進数で記載した小数は、2進数で表しきれないことが多い。（10進数の小数点以下を2進数で表そうとすると、桁の重みの違いからちょうど良く終わらないから。）
結果として最後の方が丸められてしまい誤差が出る。

https://itmanabi.com/fixed-floating/
【固定小数点数】
コンピュータ上での小数の表現方法の一つ。ビット列の中に小数点の位置を決めておく。
64ビット中の32と33ビット目の間、など。
数値を表現するときには小数点位置の左に整数部、右に小数部を配置する。
数値によっては左右どちらかに無駄なスペースが生まれてしまう。

例えば64ビット中の32と33ビット目の間に小数点を置くとき、
小数部は３桁までしかないのに整数部は40桁ある数値は入りきらない。

【浮動小数点数】
コンピュータ上での小数の表現方法の一つ。固定小数点数の無駄を無くす。
指数部と仮数部を使ってコンパクトにまとめる。
このとき固定小数点数のように小数点の位置を決めていないので浮動小数点数と呼ぶ。

【誤差】
固定小数点数と浮動小数点数のどちらであっても、コンピュータ上での小数点の計算には誤差が生じる。
誤差の原因は、10進数の小数は2進数で表現できない場合があること。
例えば10進数の0.1は、2進数で表現できない。

【BigDecimal】
小数を内部で数字情報と小数点位置情報に分けて、整数として計算することで、小数を2進数で表現しない。
```

# 関数型インターフェース  
java8 api https://docs.oracle.com/javase/jp/8/docs/api/  
http://www.ne.jp/asahi/hishidama/home/tech/java/functionalinterface.html#h_Function  
  
# ラムダ式  
  
# メソッド参照・コンストラクタ参照  
http://pppurple.hatenablog.com/entry/2016/09/11/212621  
  
# ストリームAPI  
http://backpaper0.github.io/2014/10/04/stream_collect.html  
  

# 非同期  
### CompletionStage  
ステージという概念で処理の依存関係を表現できるインターフェース。  
ステージとは何らかの処理を行う場所で、他のステージとの依存関係を持つ。  
ステージが正常に完了もしくは例外で完了することが後方に依存するステージのトリガーとなる。  
非同期の依存関係も定義できる。〜Asyncメソッドは別スレッドで非同期実行する。  
CompletionStageの利用者はステージそのものとステージ間の依存関係を定義して利用する。  
https://docs.oracle.com/javase/jp/8/docs/api/java/util/concurrent/CompletionStage.html  
  
### Future  
非同期処理の結果を表現し、それに対する操作（キャンセル、タイムアウト設定、完了チェック、結果取得）ができるインターフェース。  
https://docs.oracle.com/javase/jp/8/docs/api/java/util/concurrent/Future.html  
  
### CompletableFuture  
CompletionStageとFutureを実装したクラス。  
CompletionStageのインターフェースに加えて非同期処理の依存関係定義に便利なメソッドを追加している。（allOfなど）  
Futureインターフェースを実装しているので結果の取得や操作も可能。  
https://docs.oracle.com/javase/jp/8/docs/api/java/util/concurrent/CompletableFuture.html
  
以下のようにステージが分岐する場合は依存関係定義において〜Asyncメソッドの使用の有無が大きな影響を与える。  
```  
              B---  
              |  
          A---C---  
          |  
main---------------------  
```  
上図のA,B,CはどれもCompletableFutureインスタンスである。Aの結果を使ってB,Cが処理を行う。  
mainスレッドからCompletableFutureのstaticファクトリーメソッドでAを生成する。ファクトリーメソッド名にはAsyncとついているので、  
この段階で別スレッドで非同期処理が始まる。  
Cのステージ定義では  
```  
A.thenApply(Cの処理)  
```  
としている。そのためAのスレッドを利用してで実行される。  
Bのステージ定義では  
```  
A.thenApplyAsync(Bの処理）  
```  
としている。そのため別スレッドで実行される。(上図の通りになる)  
  
もしBの定義で  
```  
A.thenApply(Bの処理)  
```  
としてしまうとAの処理で使ったスレッドをそのまま使うので    
```  
          A---C---B---  
          |  
main---------------------  
```  
となってBとCの処理が直列になる。(CとBの処理順については必ずしもこうなるわけではない。詳しくは後述している。)  
  
むしろ同じスレッドを使ってBとCを直列で実行したい場合は〜Asyncをつけてはいけない。  
mainスレッドにて  
```  
CompletableFuture A = CompletableFuture.supplyAsync(Aの処理);  
A.thenApply(Bの処理);  
A.thenApply(Cの処理);  
```  
とするとAのスレッドを使ってBとCが直列で実行されるが、Aの後の処理順には注意しなければならない。  
処理順はスタックアルゴリズムで決定される。定義された後続ステージがスタックに溜まっていく。  
つまり仮にAの処理が別スレッド上で完了する前に、mainスレッド上でCのステージまで定義された場合の処理順は、  
```  
          A---C---B---  
          |  
main---------------------  
```  
となり、逆にAの処理が別スレッドで完了したときに、mainスレッドでBのステージまでしか定義されていなければ（もしくはBのステージすら定義されていなければ）  
```  
          A---B---C---  
          |  
main---------------------  
```  
となる。  
  
# Javaのロギング  
## ロギングインターフェース  
```  
commons-logging  
slf4j  
...  
```  
アプリケーションから利用されるロギングインターフェース。  
デファクトスタンダードはslf4j。  
commons-loggingは早い段階でリリースされたが普及せず、現在は後述するロギングライブラリの立ち位置になる。  
  
## slf4j  
概念としてネイティブバインダー、アダプター、ロギングライブラリ、ブリッジを扱う。  
<img src="/picture/javalog1.png" width="500px">

### ネイティブバインダー  
```  
slf4j-nop.jar（slf4j => /dev/null）  
slf4j-simple.jar（slf4j => 標準エラー出力）  
logback-classic.jar（slf4j => logback）  
logback-core.jar（slf4j => logback）  
```  
ロギングインターフェースの実装で、実際にロギング処理を行う。  
後述するアダプターのような委譲処理がないため高速でシンプル。  
  
### アダプター  
```  
slf4j-log4j12.jar（slf4j => log4j）  
slf4j-jdk14.jar（slf4j => java.util.logging）  
slf4j-jcl.jar（slf4j => commons-logging）  
```  
ロギングインターフェースの実装で、ロギングライブラリに処理を委譲する。  
これによりインターフェースを満たしていないロギングライブラリをslf4jから利用できる。  
新しいロギング実装が生まれれば、専用のアダプタを用意することでアプリを変更することなくjar追加で対応できる。  
  
### ロギングライブラリ  
```  
logback（log4jの後継）  
log4j  
java.util.logging  
commons-logging  
...  
```  
slf4jに依存しないロギング実装ライブラリ。  
  
### ブリッジ  
```  
jcl-over-slf4j.XXX.jar（commons-logging => slf4jに処理を移譲）  
jul-to-slf4j.XXX.jar（java.util.logging => slf4jに処理を移譲）  
log4j-over-slf4j.XXX.jar（log4j => slf4jに処理を移譲）  
...  
```  
log4j, jcl等を使って既に実装されているログ出力処理を段階的にSLF4Jに移行するために使用するもの。  
ブリッジはlog4j, jclと同名のクラスを提供して成りすますことで移行する。（元のクラスはクラスパスから除外する）  
java.util.loggingは標準なのでクラスパスから外せないため別の仕組みを使っている。 
<img src="/picture/javalog2.png" width="500px">
  
参考 : https://qiita.com/takuya-s/items/45176b2bfc9fe07a9ce7  
https://qiita.com/NagaokaKenichi/items/9febd2e559331152fcf8  
https://www.nextdoorwith.info/wp/se/slf4j/  
https://www.bunkei-programmer.net/entry/2012/10/20/java%E3%81%AE%E3%83%AD%E3%82%AC%E3%83%BC%E3%81%8C%E5%A4%9A%E3%81%99%E3%81%8E%E3%81%A6%E8%A8%B3%E3%81%8C%E8%A7%A3%E3%82%89%E3%81%AA%E3%81%84%E3%81%AE%E3%81%A7%E6%95%B4%E7%90%86%E3%81%97%E3%81%A6  
  
## その他のログに関する知識  
syslog...ログ出力を専門とするデーモンプロセスの総称。  
ローカルやリモートの別プロセスから利用され、ログの集約を可能にする。  
複数プロセスから利用できるようにファシリティという概念でデーモンをサブシステムに分割している。  
実装としてsyslogd, rsyslog, syslog-ngがある。  
  
fluentd... ログ収集を専門とするデーモンプロセス。  
ファイル、syslog、DB、アプリ等からログを受け取り、ファイル、syslog、DB、アプリ等に出力する。  
入出力の種類・形式毎にプラグインがあり、fluentdの実態はプラグインのHubになっている。  
syslogとの違いはその柔軟性にある。  
https://knowledge.sakura.ad.jp/1336/  

# ファイル操作  
### java.io  
[javadoc](https://docs.oracle.com/javase/jp/8/docs/api/java/io/package-summary.html)  
ファイルシステムにアクセスするために提供されたパッケージ。  
コピーやシンボリックリンクなどに対応できずエラーの詳細を知ることもできないなど問題が多く改善が求められた。  
  
参考 : https://qiita.com/liguofeng29/items/e08dc21b16c0057f601e  
  
主な概念  
・byte stream... 処理単位 1バイトのストリーム  
InputStream | OutputStream  
・char stream... 処理単位 2バイトのストリーム  
Reader | Writer  
・Buffer... 指定のバッファサイズだけ一括でストリームから読み(書き)込むことでデータソースへのアクセス回数を減らす仕組み  
BufferedInputStream | BufferedOutputStream | BufferedReader | BufferedWriter  
  
### java.nio  
[javadoc](https://docs.oracle.com/javase/jp/8/docs/api/java/nio/package-summary.html)  
java1.4で導入されたパッケージ。java.ioの強化版。  
java7でさらに強化されたjava.nioをnio.2と呼ぶ。  
  
主な概念  
Channel... データソースとバッファを繋げるパイプ  
Buffer... チャネルとアプリを繋げるパイプ  
