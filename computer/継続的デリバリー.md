# ソフトウェアデリバリーの問題

動作するソフトウェアは4つのコンポーネントに分けられる。
```
実行可能なコード
設定
ホスト環境
データ
```
これらのどれかひとつでも変更があった場合にはそれを確実に確かめるようにすること。

手動デプロイは再現性がなく、ヒューマンエラーを避けられない。
可能な限り全てを自動化すること。

### サイクルタイム
バグフィックスであれフィーチャであれ、変更すると決めてからユーザーが使えるようになるまでにかかる時間。
これを最小化し、効果的なフィードバックループを構築すること。

### 統合（インテグレーション）
```
1. バージョン管理にソースコードをコミットする。
2. ソフトウェアを動かしてみて期待した通りの価値を実現しているかどうかを確かめる。（統合）
```
2番のフェーズを統合と呼ぶ。
統合が行われるまで、システムは壊れていることになる。
統合を先延ばしにするとシステムが壊れている期間は長くなり、統合で発覚した不具合の原因は掴みにくくなる。
統合が痛みを伴うものになってしまう。

```
ソフトウェアの世界では、何か痛みを伴うものがあった場合にその痛みを軽減する唯一の方法は、もっとこまめに行うことだけである。
```

自動でこまめに統合するプラクティスを継続的インテグレーションと呼ぶ。
統合のおける確認（テスト）が十分に網羅的で、本番と同様の環境でテストを実行しているなら、ソフトウェアは事実上、常にリリースできる状態にあることになる。

# 構成管理
```
構成管理とはプロジェクトに関連するあらゆる成果物とそれらの間にある関係性が、保存され、検索され、一意に特定され、修正されるプロセスのこと。
```
構成管理にバージョン管理システムを使う場合もある。その場合はひとつ残らず全てをバージョン管理に保存すること。
例外としてソースコードをコンパイルしたバイナリは含めないこと。理由は
```
1. バイナリのサイズが大きい。
2. 保存しなくてもビルドシステムがソースコードから再生成できる。（ビルドプロセスで毎回コンパイルするという意味ではない）
3. ソースコードとバイナリのコミットが分かれてしまい、アプリケーションの特定バージョンに対応するコミットが二つになってしまう。
```

メインラインにこまめにコミットすること。ブランチを用いたプラクティスには反対する。
ブランチを作るといくつかの問題が発生する。（例外が三つある）
```
・新しい機能の統合が先延ばしになってしまう。
・複数の開発者がブランチを作るとマージプロセスが複雑になる。
```

### 設定  
設定情報をアプリケーションに注入するタイミングによって種類分けされる。  
```  
ビルド時  
パッケージング時  
デプロイ時  
起動時  
```  
基本的にビルド時とパッケージング時の設定は悪いプラクティスである。  
なぜならあらゆる環境に同じバイナリをデプロイできるべきだという原則に違反するから。（環境毎に別々のバイナリを準備しなければならなくなる。）  
  
設定はタプルの集合としてモデル化される。タプルの集合と値は以下の3つに依存する。  
```  
アプリケーション  
アプリケーションのバージョン  
アプリケーションの実行環境（開発環境、UAT環境、性能環境、ステージング環境、本番環境など）  
```  
これらが異なるとタプル集合モデルとその値も異なる。  
  
アプリケーションの設定を行うシステムを作る際の原則  
```  
・アプリケーションが使うことのできる設定オプションを、ソースコードと同じリポジトリ内に保持しておくこと。値は別の場所に置いておくこと。設定値のライフサイクルはコードのライフサイクルとは異なっているし、パスワードやその他機密情報はバージョン管理にチェックインしてはならない。  
・設定に対してはデプロイメント時やインストール時に確実にテストを実行すること。依存サービスにアクセスできることをチェックし、スモークテストで設定に依存している機能が期待通り動くことを確認しよう。  
```  
  
適切にデプロイされた状態にある環境は、構成管理の用語ではベースラインと呼ぶ。  
自動化されたプロビジョニングシステムは、プロジェクトで最近存在したベースラインの構築や再構築ができなければならない。  
  
