# 継続的デリバリー  
「継続的デリバリー」という言葉は、アジャイルマニフェストの最初の条文からとられている。  
```  
我々が最も価値を置くのは、価値あるソフトウェアを早いうちから継続的にデリバリーすることを通じて顧客を満足させることである。  
```  
  
継続的デリバリーは概念であり、デプロイメントパイプラインや開発プラクティスでモデル化される。  
デプロイメントパイプラインは継続的インテグレーションを論理的に突き詰めたものである。  
  
「継続的デプロイ」は全ての正しいビルドを利用者に向けてリリースすることだ。  
デプロイメントパイプラインのモデルの一つとして考えられる。  
デプロイとリリースは違うので、より正確な名前は継続的リリースかもしれない。  

# ソフトウェアデリバリーの問題

動作するソフトウェアは4つのコンポーネントに分けられる。
```
実行可能なコード
設定
ホスト環境
データ
```
これらのどれかひとつでも変更があった場合にはそれを確実に確かめるようにすること。

手動デプロイは再現性がなく、ヒューマンエラーを避けられない。
可能な限り全てを自動化すること。

### サイクルタイム
バグフィックスであれフィーチャであれ、変更すると決めてからユーザーが使えるようになるまでにかかる時間。
これを最小化し、効果的なフィードバックループを構築すること。

### 統合（インテグレーション）
```
1. バージョン管理にソースコードをコミットする。
2. ソフトウェアを動かしてみて期待した通りの価値を実現しているかどうかを確かめる。（統合）
```
2番のフェーズを統合と呼ぶ。
統合が行われるまで、システムは壊れていることになる。
統合を先延ばしにするとシステムが壊れている期間は長くなり、統合で発覚した不具合の原因は掴みにくくなる。
統合が痛みを伴うものになってしまう。

```
ソフトウェアの世界では、何か痛みを伴うものがあった場合にその痛みを軽減する唯一の方法は、もっとこまめに行うことだけである。
```

自動でこまめに統合するプラクティスを継続的インテグレーションと呼ぶ。
統合のおける確認（テスト）が十分に網羅的で、本番と同様の環境でテストを実行しているなら、ソフトウェアは事実上、常にリリースできる状態にあることになる。

# 構成管理
```
構成管理とはプロジェクトに関連するあらゆる成果物とそれらの間にある関係性が、保存され、検索され、一意に特定され、修正されるプロセスのこと。
```
構成管理にバージョン管理システムを使う場合もある。その場合はひとつ残らず全てをバージョン管理に保存すること。
例外としてソースコードをコンパイルしたバイナリは含めないこと。理由は
```
1. バイナリのサイズが大きい。
2. 保存しなくてもビルドシステムがソースコードから再生成できる。（ビルドプロセスで毎回コンパイルするという意味ではない）
3. ソースコードとバイナリのコミットが分かれてしまい、アプリケーションの特定バージョンに対応するコミットが二つになってしまう。
```

メインラインにこまめにコミットすること。ブランチを用いたプラクティスには反対する。
ブランチを作るといくつかの問題が発生する。（例外が三つある）
```
・新しい機能の統合が先延ばしになってしまう。
・複数の開発者がブランチを作るとマージプロセスが複雑になる。
```

### 設定  
設定情報をアプリケーションに注入するタイミングによって種類分けされる。  
```  
ビルド時  
パッケージング時  
デプロイ時  
起動時  
```  
基本的にビルド時とパッケージング時の設定は悪いプラクティスである。  
なぜならあらゆる環境に同じバイナリをデプロイできるべきだという原則に違反するから。（環境毎に別々のバイナリを準備しなければならなくなる。）  
  
設定はタプルの集合としてモデル化される。タプルの集合と値は以下の3つに依存する。  
```  
アプリケーション  
アプリケーションのバージョン  
アプリケーションの実行環境（開発環境、UAT環境、性能環境、ステージング環境、本番環境など）  
```  
これらが異なるとタプル集合モデルとその値も異なる。 
```
実行環境は決まったものがあるのではなく、合わせるものである。
別チームや別会社と協力して１からシステムを作ると、自然と環境は本番環境だけになる。
別チームが作ったシステム、別会社が作ったシステム、自分のチームが作ったシステムがネットワークを介して接続する。
本番環境だけではテストができないので、別チーム・別会社と協力してステージング環境を構築してステージング用ドメイン(IP)を共有する。
自分たちがステージング環境にデプロイするアプリの接続先にはこれらを設定する。
今度はユーザー受け入れテストをしたくなったので再度協力して、それぞれでUAT環境を構築して、同様にドメインを共有する。
自分のチームで固有の環境を作りたくなったら勝手に作れば良い。別チーム・別会社に同様の環境がないので接続先はないが、そこには自分たちでスタブやモックを作れば良い。
パフォーマンステスト環境など、むしろ別チームや別会社のサービスに接続しない方が良い場合もある。この場合はきっと全チームがパフォーマンステスト環境を持っているが、
ドメインは共有していないだろう。
固有の環境を作るとき、自分のチームでいくつかのマイクロサービスを持っているのならば、少なくともそれらでは同様の環境を作っても良い。
```
  
アプリケーションの設定を行うシステムを作る際の原則  
```  
・アプリケーションが使うことのできる設定オプションを、ソースコードと同じリポジトリ内に保持しておくこと。値は別の場所に置いておくこと。設定値のライフサイクルはコードのライフサイクルとは異なっているし、パスワードやその他機密情報はバージョン管理にチェックインしてはならない。  
・設定に対してはデプロイメント時やインストール時に確実にテストを実行すること。依存サービスにアクセスできることをチェックし、スモークテストで設定に依存している機能が期待通り動くことを確認しよう。  
```  
  
適切にデプロイされた状態にある環境は、構成管理の用語ではベースラインと呼ぶ。  
自動化されたプロビジョニングシステムは、プロジェクトで最近存在したベースラインの構築や再構築ができなければならない。  
  
# 継続的インテグレーション  
こまめに統合し、ビルドやテストプロセスが失敗したら、開発チームは何をしていても手を止めて即座に問題を修正する。  
継続的インテグレーションの目標は、ソフトウェアを常に動く状態にしておくことだ。  
  
### 継続的インテグレーション実現する  
継続的インテグレーションを行うためには、以下が必要である。  
```  
1. バージョン管理  
2. 自動ビルド  
3. チームの合意  
```  
  
### 継続的インテグレーションの前提条件  
##### 定期的にチェックインすること  
コードを1日に2回はチェックインするべきだ。定期的にチェックインすることで変更が小さくなりビルドを壊す可能性も低くなる。  
極めて限定的な状況の除き、ブランチを使ってはならない。  
  
##### 包括的な自動テストスイートを作成すること  
```  
ユニットテスト  
コンポーネントテスト  
受け入れテスト  
```  
  
##### ビルドプロセスとテストプロセスを短く保つこと  
ビルドやテストにかかる時間を短くすること。  
そうしなければ、こまめなコミットが阻害されてしまう。  
  
##### 開発ワークスペースを管理すること  
開発者が作業に取り掛かる時は、常に正しく動くとわかっている開始地点から始められるべきだ。  
そのために以下を行う。  
```  
構成管理... CIサーバー上で自動テストを全て通った状態を開発環境に再現する。ソースコードだけでなくテストデータやデータベーススクリプト、ビルド・デプロイメントスクリプトも含む。  
依存関係の構成管理... 特定のバージョンのライブラリを用意できるようにする。  
スモークテストを含む自動テスト実行... 実行にある程度の努力が必要でも、開発機上で実行できることで品質が大きく向上する。  
```  
アプリケーションアーキテクチャが優れていることを示すひとつの指標として、  
アプリケーションがそれほど労力を払わず開発機上で実行できるようになっている、というものがある。  
  
### 継続的インテグレーションの必須プラクティス  
##### ・ビルドが壊れているときにはチェックインするな  
##### ・コミットする前に、常にローカルでコミットテストを実行せよ。あるいは代わりにCIサーバーにやってもらえ  
##### ・次の作業を始める前に、コミットテストが通るまで待て  
##### ・ビルドが壊れているのに家に帰ってはならない  
##### ・常に以前のリビジョンに戻す準備をしておくこと  
##### ・リバートする前にタイムボックスを切って修正する  
##### ・失敗したテストをコメントアウトするな  
##### ・自分が変更してビルドが壊れたら、すべてに対して責任をとれ  
##### ・テスト駆動開発  
  
### 継続的インテグレーションのやったほうが良いプラクティス  
##### ・エクストリームプログラミング（XP）の開発プラクティス  
##### ・アーキテクチャ上の違反事項があった場合にビルドを失敗させる  
##### ・テストが遅い場合にビルドを失敗させる  
##### ・警告やコードスタイルの違反があったときにビルドを失敗させる  

# テスト戦略を実装する
![テストの四象限図](/picture/継続的デリバリー1.png "テストの四象限図")  

```
どのテストも必ずテスト種別に属し、テストスコープを持つ。

・テスト種別（テストの四象限で表現）... 観点で分類される
開発プロセスを支援するビジネス視点のテスト
観点：ユーザーが求める機能を実装できたかどうか

開発プロセスを支援する技術視点のテスト
観点：エンジニアのコミットがアプリを壊していないかどうか

プロジェクトを評価するビジネス視点のテスト
観点：仕様がユーザーにとって正しく満足できるものかどうか

プロジェクトを評価する技術視点のテスト
観点：非機能要件（キャパシティ・可用性・セキュリティ）を満たしているかどうか


・テストスコープ（テストピラミッドで表現）
単体スコープ
アプリケーションは起動しない。
依存関係はスタブ/モックを利用する。

サービススコープ
アプリケーションを起動する。
依存関係はスタブ/モックを利用する。

エンドツーエンドスコープ
アプリケーションを起動する。
依存関係は本物を利用する。
```
  
### 開発プロセスを支援するビジネス視点のテスト  
この区画のテストは一般的に機能テストあるいは受け入れテストとして知られている。  
そもそも受け入れテストとは、ストーリーに対する受け入れ基準が満たされていることを保証するテストだ。  
受け入れ基準は、構築するシステムのあらゆる属性をテストする。そこには  
```  
機能、キャパシティやユーザービリティ、セキュリティ、変更のしやすさ、可用性  
```  
といったものが含まれる。  
この中でも機能を関心の対象とする受け入れテストは、機能受け入れテストと呼ばれ、この区画のテストにあたる。  
その他を関心の対象とする受け入れテストは、非機能受け入れテストであり「プロジェクトを評価する技術視点のテスト」の区画となる。  
  
あるストーリーに対する開発が始まる前に書かなければならず、理想的には自動化されるのが望ましい。  
  
受け入れテストはアジャイルを行なっている場合は欠かせない。なぜなら開発者の「どうすれば完了したとわかるのか？」という問いに答えると同時に、  
ユーザーの「必要なものは手に入ったのか？」という問いにも答えるからだ。  
したがって理想的には、各要件に対する成功条件を定義した後で、顧客やユーザーが受け入れテストを書くのが良い。  
（Cucumber, JBehae, Concordion, Twistといった機能テスト自動化ツールがある）  
  
### 開発プロセスを支援する技術視点のテスト  
この区画のテストには以下がある。  
```  
ユニットテスト... コードの特定の一部をテストする。  
コンポーネントテスト... コードを組み合わせたものをテストする。インテグレーションと呼ばれたりする。  
デプロイメントテスト... デプロイがうまくいったことを確認する。  
```  
  
### プロジェクトを評価するビジネス視点のテスト  
この区画のテストには以下がある。  
```  
ショーケース... ユーザーにイテレーションが終わるたびに新機能のデモを披露する。  
探索的テスト... 手作業で行うテストの一形態で、テスターがテスト設計をコントロールしていくテスト。  
ユーザービリティテスト... ユーザーがソフトウェアを使って目的を達成するのがどれほど簡単かを知るためのテスト。  
```  
  
### プロジェクトを評価する技術視点のテスト  
この区画は、  
受け入れ基準のうち、機能以外を関心の対象としたテスト（非機能受け入れテスト）となる。  
  
# デプロイメントパイプライン  
### デプロイメントパイプラインとは何か？  
抽象的に言えばデプロイメントパイプラインとは、ソフトウェアをバージョン管理から取り出してユーザーの手に渡すまでのプロセスを自動化して表現したものだ。  
理想的には受け入れテストもローカルで実行でき、ユビキタス言語で表現されるべきだ。  

# データを管理する  
### データベースのマイグレーション  
・マイグレーション種別  
```  
新スキーマ追加  
既存スキーマの変更  
```  
  
・アーキテクチャ  
```  
単一データベース  
blue-greenデータベース  
```  
  
・制約  
```  
ゼロダウンタイムリリース  
ロールバック  
```  
  
・テクニック  
```  
データベースのバージョン管理... データベースを管理するスクリプトをバージョン管理する。任意のマイグレーションツールを利用し、特定バージョンの構築・ロールバックを実現する。  
リードモード... データベースへの書き込みを停止させる仕組みをAppに用意しておく。  
Appデプロイとのマイグレーションの切り離し... Appにデータベースの前方互換性を持たせ、先にデプロイする。  
```  
  
# メモ
```
・コンポーネント（インテグレーション）テストと受け入れテストの違いは？
コンポーネント（インテグレーション）テストの定義は様々だが、我々は依存先のサービスとうまく結合できることを確認する意味で用いている。
アジャイルコミュニティの中にはユニットテストとコンポーネント（インテグレーション）テストを包括的に書き、
しっかりとビジネスとコミュニケーションをとることで、受け入れテストはいらないという考えを持つ人もいる。
しかし、テストの四象限図にあるとおり、この二つは目的と視点が違う。
コンポーネント（インテグレーション）テストは技術視点、受け入れテストはビジネス視点である。
つまり受け入れテストだけが、ユーザーの求める機能を満たしたことを確認してくれる。
コンポーネント（インテグレーション）テストは継続的デリバリーにおいては受け入れテストの一環として行われる。

・受け入れテストのDBと依存先サービスはモックか？
当然だが、依存先の本番環境にアクセスすることはない。（そもそもファイアウォールで弾かれるべきだ）
受け入れテストは２通りのコンテキストで行われる。
・依存先サービスが用意している検証環境
・コードベースの一部として作成したテストハーネス
場合によってはテストハーネスは状態を記憶できるように作り込まなければならない。

# CIサーバー上でローカルに起動する場合… 
DB… インメモリDBかテストハーネス
依存先サービス… 検証環境かテストハーネスかスタブサーバー

# 環境にデプロイしてテストする場合… 
DB… 環境用DBかインメモリDBかテストハーネス
依存先サービス… 検証環境かテストハーネスかスタブサーバー

※デプロイしてテストする場合、ライブラリ等でテストハーネスへの切り替えが難しい。
→ DIでテストハーネス用Beanを設定する。https://qiita.com/kazuki43zoo/items/8645d9765edd11c6f1dd （「切り替え」でページ内検索）
※実際の依存先にリクエストしてしまうと負荷がかかる。受け入れテストは１日に何度も行われる。
それを緩和する戦略としては、1日に1度、1週間に1度にしたりする。
※自動受け入れテストとUATの違いのひとつは、自動受け入れテストは外部システムとすべて統合された環境で実行してはならないということだ。
そうではなく、自動受け入れテストではテスト対象のシステムが実行できる制御可能な環境を提供することに集中しなければならない。
「制御可能」とは、テスト用の初期状態を正しく作れるということだ。（P266）
※基本的に受け入れテストはデプロイメントスクリプトでデプロイしたものが正しく動くかどうかをテストするため、環境にデプロイしてテストする。
依存先サービスについてはテストハーネスで細かいところまで網羅し、検証環境に対しては重要なシナリオだけをテストする。
```

  
  
# バージョン管理システムと開発手法  
  
```  
コードフリーズ... バージョン管理システムへのチェックインを数日から数週間にかけてやめてしまうこと。  
  
バージョンナンバーは、メジャー.マイナー.パッチとし、バージョンを上げるには、  
1. APIの変更に互換性のない場合はメジャーバージョンを、  
2. 後方互換性があり機能性を追加した場合はマイナーバージョンを、  
3. 後方互換性を伴うバグ修正をした場合はパッチバージョンを上げます。  
```  
  
### ・メインライン上での開発  
最も推奨される開発手法。  
ブランチ・マージという概念はない。  
アプリケーションをリリース可能な状態に保つテクニックを用いる。（継続的デリバリー P411）  
```  
フィーチャートグル... 新機能は完成するまで隠す。https://qiita.com/TsuyoshiUshio@github/items/51c6662cd45bded95389  
インクリメンタルな開発計画  
抽象化によるブランチ  
```  
  
### ・リリース用のブランチ  
次善の開発手法。（業界標準になりうる。）  
新機能の開発をメインラインで行う。  
リリース用のバグフィックスが新機能の開発に影響を及ぼさないようにするための手法。  
  
### ・フィーチャによるブランチ  
非推奨の開発手法。  
デメリットが多い。http://bliki-ja.github.io/FeatureBranch/  
```  
意味的衝突を招く... http://bliki-ja.github.io/SemanticConflict/  
リファクタリングへの抑止力として機能する... リファクタリングが意味的衝突を招きやすくするので、躊躇しがちになる。結果として、フィーチャーブランチを使用するチームはリファクタリングすることに尻込みし、コードベースが醜くなることを招く。  
```  
デメリットへの対策として、アプリケーションをリリース可能な状態に保つテクニックと共に、明示的に継続的インテグレーションを行う。  
これによりコードレビューのタイミングを与えられる。  
  
### ・チームによるブランチ  
省略  

# 実践
バージョン管理
```
あらゆるものをバージョン管理すること。（成果物（バイナリ、レポート）を除く）
```

構成管理
```
自動でミドルウェア（もしくはApp）スタックまで構築できること。
```

データベース・バージョン管理
```
マイグレーションツールでデータベースをバージョンで管理しAppのバージョンと紐づけることで、自動リリース・ロールバックを可能にすること。
```

デプロイメントパイプライン
```
デプロイメントパイプラインを用意すること。
```

成果物リポジトリ
```
成果物リポジトリを用意すること。
```

コミットテスト
```
ユニットテストやソースコード解析、選別したいくつかの自動受け入れテストを実行すること。
```

自動受け入れテスト
```
包括的な受け入れテストを実行すること。この受け入れテストをパスしたバージョンは絶対にリリース可能であること。
```

パフォーマンステスト
```
ロードテストを行うこと。
```

デプロイメントスクリプト
```
全ての環境(dev, stg, prod)で単一の同じデプロイメントスクリプトを用意すること。
設定の注入とデプロイメントテストを行うこと。
```

ビルドスクリプト
```
デプロイメントスクリプトの各ステージ毎に別々のビルドスクリプトを用意すること。
作成するバイナリそのものは全ての環境(dev, stg, prod)で同じであること。
```

フィーチャートグル
```
デプロイした新機能を完成・公開まで隠すトグルの仕組みを用意すること。
```

抽象化によるブランチ
```
抽象化によるブランチが可能な設計にすること。
```

## 自動受け入れテスト  
※画像は「継続的デリバリー 信頼できるソフトウェアリリースのためのビルド・テスト・デプロイメントの自動化 David Farley (著), Jez Humble (著), 和智 右桂 (翻訳), 高木 正弘 (翻訳) 」から引用。  
  
### テストの四象限図と受け入れテストの必要性について  
テストの四象限図  
<img src="/picture/自動受け入れテスト1.jpg" width="500px">  
  
  
##### 開発プロセスを支援するビジネス視点のテスト（テストの四象限図左上）  
この区画のテストは一般的に機能テストあるいは受け入れテストとして知られている。  
そもそも受け入れテストとは、ストーリーに対する受け入れ基準が満たされていることを保証するテストだ。  
  
受け入れ基準は、構築するシステムのあらゆる属性をテストする。そこには  
機能、キャパシティやユーザービリティ、セキュリティ、変更のしやすさ、可用性    
といったものが含まれる。  
この中でも機能を関心の対象とする受け入れテストは、機能受け入れテストと呼ばれ、この区画のテストにあたる。  
その他を関心の対象とする受け入れテストは、非機能受け入れテストであり「プロジェクトを評価する技術視点のテスト」の区画となる。  
  
あるストーリーに対する開発が始まる前に書かなければならず、理想的には自動化されるのが望ましい。  
  
受け入れテストはアジャイルを行なっている場合は欠かせない。なぜなら開発者の「どうすれば完了したとわかるのか？」という問いに答えると同時に、  
ユーザーの「必要なものは手に入ったのか？」という問いにも答えるからだ。  
したがって理想的には、各要件に対する成功条件を定義した後で、顧客やユーザーが受け入れテストを書くのが良い。  
（Cucumber, JBehae, Concordion, Twistといった自動化ツールがある）  
  
  
##### 開発プロセスを支援する技術視点のテスト（テストの四象限図左下）  
この区画のテストには以下がある。  
```  
ユニットテスト... コードの特定の一部をテストする。   
コンポーネントテスト... コードを組み合わせたものをテストする。インテグレーション/システムテストと呼ばれたりする。  
```  
  
##### プロジェクトを評価するビジネス視点のテスト（テストの四象限図右上）  
この区画のテストには以下がある。  
```  
ショーケース... ユーザーにイテレーションが終わるたびに新機能のデモを披露する。   
探索的テスト... 手作業で行うテストの一形態で、テスターがテスト設計をコントロールしていくテスト。   
ユーザービリティテスト... ユーザーがソフトウェアを使って目的を達成するのがどれほど簡単かを知るためのテスト。  
```  
  
##### プロジェクトを評価する技術視点のテスト（テストの四象限図右下）  
この区画は、受け入れ基準のうち、機能以外を関心の対象としたテスト（非機能受け入れテスト）となる。  
  
  
### なぜ自動受け入れテストが欠かせないのか？  
上述しているがもう一度。  
  
アプリケーションが、ユーザーの求めるビジネス価値を提供していることを証明するテストは受け入れテスト以外にない。  
  
確かにユニットテストやインテグレーション/システムテストはテストの自動化戦略のなかで重要な役割を果たすが、  
プログラマがこう動くべきと考えた通りに動いていることを証明しているに過ぎない。  
受け入れテストの目的は、顧客が意図したアプリケーションが実行しているということを証明することにある。  
  
また自動化された機能の受け入れテストは、既存機能を破壊するようなリグレッションや障害から保護してくれる。  
受け入れテストの自動化をあきらめたチームでは、テスターが退屈なリグレッションテストを繰り返すのに多くの時間を割くことになるだろう。  
  
  
### 受け入れテストを実装する  
実行可能な仕様を作成することが、ふるまい駆動開発と呼ばれる開発手法の本質である。このプロセスをまとめると以下のようになる。  
```  
・ストーリーの受け入れ基準について顧客と議論する  
・受け入れ基準を書き出す  
・ドメインの言語だけを使ってアプリケーションドライバレイヤにアクセスするテストの実装を書く  
・テスト対象のシステムと通信するアプリケーションドライバレイヤを作成する  
```  
ストーリーの受け入れ基準について顧客と議論する  
保守しやすい受け入れテストを書くためには、何よりも分析プロセスを注意して行わなければならない。  
受け入れテストは受け入れ基準から導き出されるため、アプリケーションの受け入れ基準は自動化を念頭に置いて書かなければならない。  
受け入れ基準はエンドユーザーにとって価値がありテスト可能でなければならない。これは受け入れテストを自動化するプロジェクトにとって多少ながら重要なプレッシャーとなる。  
書き方が拙く、開発する機能がユーザーにどんな価値をもたらすか説明していない受け入れ基準を自動化してしまうと、受け入れテストスイートが貧弱で保守が難しくなってしまう。  
  
受け入れ基準を定義するために、どんな規模のプロジェクトであっても各チームに一人はビジネスアナリストがいるべきだ。  
ビジネスアナリストの役割は、まず第一に顧客やシステムのユーザーの代表になることにある。ビジネスアナリストは  
顧客と一緒になって要件を識別したり優先順位付けを行ったり、開発者やテスターとコミュニケーションをとり、彼らがユーザーの視点でアプリケーションを理解できるようにする。  
早い段階でイテレーティブに受け入れ基準を定義することで、よくわからない要件や、実装やテストが高くつく「象牙の塔」の要件を作ってしまうこともなくなる。  
  
  
  
### 受け入れ基準を書き出す  
クリス・マッツとダン・ノースは受け入れ基準を書くためのドメイン特化言語を考え出した。  
```  
前提（Given）　＜最初のコンテキスト＞という条件で、  
もし（When）　＜あるイベント＞が発生したとき、  
ならば（Then）　＜なんらかの結果＞となる。  
```  
アプリケーションの観点から見ると、「前提」節はテストケースが始まる時のアプリケーションの状態を表現する。  
「もし」節はユーザーとアプリケーションの間のやり取りを記述し、「ならば」節はやりとりが完了した後のアプリケーションの状態を記述する。  
テストケースでやるべきことは、次の三つだ。まず、アプリケーションを「前提」節で記述された状態にすること。次に「もし」節で記述されたアクションを実行すること。最後にアプリケーションが「ならば」節で記述された状態にあることを検証すること。  
  
CucumberやJBehaveのようなツールを使えば、こうした受け入れ基準をプレーンテキストとして書いて、実際のアプリケーションと同期化させて置けるようになる。  
  
  
### ドメインの言語だけを使ってアプリケーションドライバレイヤにアクセスするテストの実装を書く  
自動受け入れテストは以下のように常にレイヤ化されていなければならない。  
  
受け入れテストのレイヤ  
<img src="/picture/自動受け入れテスト6.jpg" width="500px">  
  
最上位層は「受け入れ基準レイヤ」だ。  
中間層に受け入れ基準を実装した「実装レイヤ」があり、  
最下位層にアプリケーションとやりとりする「アプリケーションドライバレイヤ」がある。  
  
受け入れ基準レイヤと実装レイヤはCucumberやJBehaveといったツールを使うことで紐付けることができるが、xUnitテストの形で受け入れ基準をコードに書くというアプローチを取ることもできる。  
  
xUnit形式の場合はレイヤは2層（受け入れ基準&実装レイヤ→アプリケーションドライバレイヤ）になり管理が楽なのでお勧めである。  
  
どちらにするかは顧客がビジネスサイドかどうかで決めるとよい。ビジネスサイドの人間であればxUnit形式よりも受け入れ基準レイヤがある方を好むだろう。  
  
重要なのは実装レイヤでドメインの用語（ユビキタス言語）を使うようにすること。つまりアプリケーションとどのようにやりとりするかという詳細を一切含まないようにすることだ。  
この原則に違反しテスト実装がアプリケーションのAPIやUIを直接参照していると、テストは脆くなってしまいUIを少し変更しただけでテストまで壊れてしまう。  
実装レイヤには受け入れテストの意味（すなわち実際の価値）が込められているべきだ。以下は実装レイヤで扱う内容の例である。  
```  
注文したら受け付けられるか？  
クレジットカードの限度額を超えたら、適切に知らせてもらえるか？  
```  
テストの実装の中では、我々がアプリケーションドライバと呼ぶ、より抽象度の低いレイヤを呼び出してテスト対象システムとやりとりすべきだ。  
アプリケーション本体が改修されるにつれてアプリケーションドライバにも修正は及ぶが、受け入れテストの意味（すなわち実装レイヤ）は変更されない。  
このように抽象度が高いものと低いものは分離しておくことが重要だ。  
  
GUIを直接叩くかどうかは、受け入れテストを書くときに重要な懸念となる。  
理想的にはシステムにユーザーインターフェースがあれば、そことやりとりすべきである。  
しかしGUIは頻繁に変更されるし、シナリオのセットアップからテスト結果取得までの処理は複雑になる。GUIのテクノロジーによってはテストできないことすらある。  
  
GUIを叩かない方法も検討すべきである。アプリケーションがうまく設計されていれば、GUIレイヤには明確に定義された表示専用のコードだけが集められていて、独自のビジネスロジックは含まれていないだろう。その場合、UIを迂回してその下にあるレイヤにあるコードに対してテストを書くことに大きなリスクはない。  
  
アプリケーションがテスタビリティを念頭に置いて書かれていれば、アプリケーションを動かすためのAPIが準備されていて、それをGUIから呼び出すこともテストハーネスから呼び出すこともできるだろう。  
  
UIを迂回する方法でビジネスレイヤに対して直接テストを実行することは理にかなっており、お勧めの方法だ。  
その場合やるべきことは、開発チームでしっかりとした規約を作ってプレゼンテーションレイヤをただのお絵かきにしておくことに集中し、ビジネスロジックやアプリケーションロジックの領域に迷い込まないようにしておくことだけだ。  
  
  
GUIを叩いてテストする場合は、ウィンドウドライバパターンが助けになる。これはGUIの各部品に対応するデバイスドライバを実装し、それをアプリケーションドライバにプラグインできるようにする方法だ。  
  
ウィンドウドライバパターン  
<img src="/picture/自動受け入れテスト2.jpg" width="500px">  
  
  
### テスト対象のシステムと通信するアプリケーションドライバレイヤを作成する  
アプリケーションドライバレイヤは、テスト対象システムとどのようにやりとりするかを理解しているレイヤである。  
  
アプリケーションドライバレイヤ用のAPIはドメインの言語（ユビキタス言語）で表現されているので、実は独自のドメイン特化言語であると考えることができる。  
```  
ドメイン特化言語（DSL）はコンピュータプログラミング言語であり、  
特定の問題領域（ドメイン）に特化した問題を解決する事を目的としている。  
DSLは特定の問題領域に対してのみ作用するように設計されているため、解決できない様々な問題も数多くある。  
その点が汎用プログラミング言語との違いである。  
  
DSLは内部DSLと外部DSLの2種類に分けられる。  
外部DSLでは命令を実行する前に言語解析処理を明示的に行う必要がある。  
Cucumberの受け入れ基準ファイルや、AntやMavenで使われるXMLビルドスクリプトもこの一例だ。  
外部DSLはチューリング完全である必要はない。  
  
内部DSLではコードで直接表現されるDSLだ。  
xUnit形式の受け入れ基準&実装レイヤは内部DSLとなる。  
言語解析処理が不要で強力だが、ベースとなる言語の構文によってはDSLが読みにくくなる場合もある。  
```  
アプリケーションの仕様をドメインと捉えたとき、それに特化した言語（すなわちDSL）が提供されていれば、それを使った解決領域を構築できる。  
  
プリケーションドライバレイヤをうまく設計すると、それはアプリケーションの仕様をドメインと捉えた場合のDSLとなる。  
あとは受け入れテストのレイヤにおける実装レイヤでDSLを使って解決領域を構築するだけだ。  
  
xUnit形式の受け入れ基準&実装レイヤの例  
<img src="/picture/自動受け入れテスト3.jpg" width="500px">  
  
アプリケーションドライバレイヤでは受け入れテストの意味に含まれない詳細を吸収することができる。  
  
例えば「管理者が登録画面でユーザーAを登録したならば、ユーザーAの情報を参照できる」のようなシナリオがあった場合、ユーザーAの登録時に必要な名前やパスワードなどは何でも良い。  
実装レイヤでは  
`adminApi.createUser("A");`  
としておき、アプリケーションドライバレイヤであるadminApiの中で名前やパスワードをデフォルト値やランダム値を適用できる。  
  
この方法の良い点は、他のテストでDBに登録されるデータの中身を気にする必要がないことだ。  
  
### 受け入れテストにおける状態  
受け入れテストをするためにはアプリケーションが特定の開始状態（「前提」節）にいなければならない。これを実現するのはテストを書く上で最も難しい。  
何よりもまずプロダクションデータのダンプを取得して受け入れテスト用DBに投入したいという誘惑に負けないこと。これには労力が必要で、かつデータの追跡までするとテスト本体に注力できない。  
  
そうではなく、統制のとれた最小限のデータセットを保守すること。テストをする上で重要な側面は、正しく動くとわかっている開始地点を確立することだ。  
この開始状態はスクリプトとしてまとめられ受け入れテスト実行前にDBに投入される。  
  
理想的にはテストはアトミックであるべきだ。アトミックなテストはどのような順番で実行しても良いので並列実行できる。  
アトミックなテストは、実行に必要なものを全て生成して、それを内部に隠蔽し、成功したか失敗したかという記録以外に痕跡を残さない。  
  
これを受け入れテストで実現することは難しい。例えばテスト開始時にトランザクションを確立し、テストの最後でロールバックする方法がある。  
だが受け入れテストとは、本番環境に限りなく近い環境にデプロイされたコンポーネントに対してサービス or E2Eスコープ※で行われるべきであるためその方法は使えないことが多い。  
  
受け入れテストに対する最も効率的なアプローチはアプリケーションの機能を使ってテストのスコープを区切ることだ。  
例えばアカウントがあるシステムでは、アプリケーションドライバレイヤで新しいアカウントをシンプルに生成できるようにしておくことで、テスト毎にアカウントを分けてデータの整合性を保つことができる。  
  
どうしても分離できない場合はテストを防御的に実装してテスト開始時の状態が期待通りでなければ即座に終了したり、相対的な結果を参照するアプローチがある。  
  
  
受け入れテストは2通りのスコープで実行するべきだ。  
  
##### ・サービススコープ（依存している外部システムをコードベースの一部として作成したテストダブルに置き換えて実行する）  
自動受け入れテストは「ユーザー受け入れテスト（UAT）」とは違う。自動受け入れテストではテストの初期状態を正しく作れる必要があるということだ。  
  
実際の外部システムと統合すると制御することはできなくなってしまう。  
そのためほぼ全ての受け入れテストスイートはこのスコープで実行する。  
<img src="/picture/自動受け入れテスト4.jpg" width="500px">  
  
##### ・E2Eスコープ（実際の依存している外部システムやサービスプロバイダ側が提供するレプリカに対して実行する）  
我々の目標は問題をできる限り早期に発見することであり、これを実現するためには問題が起きる原因となりやすい外部システムとの統合を継続的に実施するべきだ。  
そのため全てのインテグレーションポイント周りに小粒のE2Eスコープのテストスイートを構築し、外部システムと実際に通信できる環境で実行する。  
E2Eスコープで、システムの実際のふるまいに頼ってテストが成功することを検証した方が良いという考えもあるだろう。  
  
その場合はE2Eテストとして、受け入れテストとは別のタイミングで実施するとよい。またユーザー受け入れテスト（UAT）ステージでは外部システムと実際に通信させるべきだ。  
  
うまく設計されたアプリケーションでは外部システムとの結合度は最小化されている。1外部サービスに対し1コンポーネント（ゲートウェイやアダプタ）が用意されているため、通信に関わる技術的な詳細を、ビジネスロジックや他の詳細から分離できている。  
つまりテストダブルによるサービススコープのテストでも十分な威力を発揮できるということだ。  
  
  
### デプロイメントテスト  
受け入れテストを実行するときには、期待される本番環境にテスト環境をできる限り近づけるように設計する。値段が高くなりすぎなければ完全に同じであるべきだ。  
  
受け入れテストは自動デプロイメントがうまく動き、デプロイメント戦略がうまくいっていることを確認する最初の機会なのだ。  
  
### 受け入れテストの自動実行  
受け入れテストはデプロイパイプラインの中で実行される。  
  
デプロイパイプライン  
<img src="/picture/自動受け入れテスト5.jpg" width="500px">  
concourseやscrewdriver.cdで実現する  
  
  
### ユーザーストーリーと受け入れ基準  
参考：https://www.ryuzee.com/contents/blog/4264  
```  
・ユーザーストーリーの書き方と受け入れ基準の例  
ユーザーストーリーがアクターと問題と価値を含んでいること  
ユーザーストーリーがスプリントに収まるサイズであること  
ユーザーストーリーが適切にドキュメント化されていること（ワイヤーフレームは必要？画面遷移図は必要？）  
価値が明らかであること。もしそうでないなら、明確に記述すること  
ユーザーストーリーが合理的な満足条件を持っていること  
ユーザーストーリーは問題にフォーカスしており、ソリューションにフォーカスしていないこと  
```  
ユーザーストーリー：  
「顧客として、私がテレビやHi-fiやその他の製品を買う際に、同時に私が買いたいと思いそうな製品を見ることができる。それによって私は私が必要としている全てのものを同時に手に入れることができる。」  
  
受け入れ基準：  
「顧客に、その顧客が選んでいる製品を購入した他の顧客が一緒にショッピングカートに追加して購入した製品を見せ、購入した製品と同時に利用されるであろう製品を表示する。例えばTVを選択した場合は、  
ケーブルやテレビスタンドやブルーレイのプレイヤーを表示する。最終的にショッピングカートに追加した製品の購入割合やレーティングを表示する。」  
  
一つのユーザーストーリーは最低一つの受け入れ基準を持つ。  
