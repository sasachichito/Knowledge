# ソフトウェアデリバリーの問題

動作するソフトウェアは4つのコンポーネントに分けられる。
```
実行可能なコード
設定
ホスト環境
データ
```
これらのどれかひとつでも変更があった場合にはそれを確実に確かめるようにすること。

手動デプロイは再現性がなく、ヒューマンエラーを避けられない。
可能な限り全てを自動化すること。

### サイクルタイム
バグフィックスであれフィーチャであれ、変更すると決めてからユーザーが使えるようになるまでにかかる時間。
これを最小化し、効果的なフィードバックループを構築すること。

### 統合（インテグレーション）
```
1. バージョン管理にソースコードをコミットする。
2. ソフトウェアを動かしてみて期待した通りの価値を実現しているかどうかを確かめる。（統合）
```
2番のフェーズを統合と呼ぶ。
統合が行われるまで、システムは壊れていることになる。
統合を先延ばしにするとシステムが壊れている期間は長くなり、統合で発覚した不具合の原因は掴みにくくなる。
統合が痛みを伴うものになってしまう。

```
ソフトウェアの世界では、何か痛みを伴うものがあった場合にその痛みを軽減する唯一の方法は、もっとこまめに行うことだけである。
```

自動でこまめに統合するプラクティスを継続的インテグレーションと呼ぶ。
統合のおける確認（テスト）が十分に網羅的で、本番と同様の環境でテストを実行しているなら、ソフトウェアは事実上、常にリリースできる状態にあることになる。

# 構成管理
```
構成管理とはプロジェクトに関連するあらゆる成果物とそれらの間にある関係性が、保存され、検索され、一意に特定され、修正されるプロセスのこと。
```
構成管理にバージョン管理システムを使う場合もある。その場合はひとつ残らず全てをバージョン管理に保存すること。
例外としてソースコードをコンパイルしたバイナリは含めないこと。理由は
```
1. バイナリのサイズが大きい。
2. 保存しなくてもビルドシステムがソースコードから再生成できる。（ビルドプロセスで毎回コンパイルするという意味ではない）
3. ソースコードとバイナリのコミットが分かれてしまい、アプリケーションの特定バージョンに対応するコミットが二つになってしまう。
```

メインラインにこまめにコミットすること。ブランチを用いたプラクティスには反対する。
ブランチを作るといくつかの問題が発生する。（例外が三つある）
```
・新しい機能の統合が先延ばしになってしまう。
・複数の開発者がブランチを作るとマージプロセスが複雑になる。
```

### 設定  
設定情報をアプリケーションに注入するタイミングによって種類分けされる。  
```  
ビルド時  
パッケージング時  
デプロイ時  
起動時  
```  
基本的にビルド時とパッケージング時の設定は悪いプラクティスである。  
なぜならあらゆる環境に同じバイナリをデプロイできるべきだという原則に違反するから。（環境毎に別々のバイナリを準備しなければならなくなる。）  
  
設定はタプルの集合としてモデル化される。タプルの集合と値は以下の3つに依存する。  
```  
アプリケーション  
アプリケーションのバージョン  
アプリケーションの実行環境（開発環境、UAT環境、性能環境、ステージング環境、本番環境など）  
```  
これらが異なるとタプル集合モデルとその値も異なる。 
```
実行環境は決まったものがあるのではなく、合わせるものである。
別チームや別会社と協力して１からシステムを作ると、自然と環境は本番環境だけになる。
別チームが作ったシステム、別会社が作ったシステム、自分のチームが作ったシステムがネットワークを介して接続する。
本番環境だけではテストができないので、別チーム・別会社と協力してステージング環境を構築してステージング用ドメイン(IP)を共有する。
自分たちがステージング環境にデプロイするアプリの接続先にはこれらを設定する。
今度はユーザー受け入れテストをしたくなったので再度協力して、それぞれでUAT環境を構築して、同様にドメインを共有する。
自分のチームで固有の環境を作りたくなったら勝手に作れば良い。別チーム・別会社に同様の環境がないので接続先はないが、そこには自分たちでスタブやモックを作れば良い。
パフォーマンステスト環境など、むしろ別チームや別会社のサービスに接続しない方が良い場合もある。この場合はきっと全チームがパフォーマンステスト環境を持っているが、
ドメインは共有していないだろう。
固有の環境を作るとき、自分のチームでいくつかのマイクロサービスを持っているのならば、少なくともそれらでは同様の環境を作っても良い。
```
  
アプリケーションの設定を行うシステムを作る際の原則  
```  
・アプリケーションが使うことのできる設定オプションを、ソースコードと同じリポジトリ内に保持しておくこと。値は別の場所に置いておくこと。設定値のライフサイクルはコードのライフサイクルとは異なっているし、パスワードやその他機密情報はバージョン管理にチェックインしてはならない。  
・設定に対してはデプロイメント時やインストール時に確実にテストを実行すること。依存サービスにアクセスできることをチェックし、スモークテストで設定に依存している機能が期待通り動くことを確認しよう。  
```  
  
適切にデプロイされた状態にある環境は、構成管理の用語ではベースラインと呼ぶ。  
自動化されたプロビジョニングシステムは、プロジェクトで最近存在したベースラインの構築や再構築ができなければならない。  
  
# 継続的インテグレーション  
こまめに統合し、ビルドやテストプロセスが失敗したら、開発チームは何をしていても手を止めて即座に問題を修正する。  
継続的インテグレーションの目標は、ソフトウェアを常に動く状態にしておくことだ。  
  
### 継続的インテグレーション実現する  
継続的インテグレーションを行うためには、以下が必要である。  
```  
1. バージョン管理  
2. 自動ビルド  
3. チームの合意  
```  
  
### 継続的インテグレーションの前提条件  
##### 定期的にチェックインすること  
コードを1日に2回はチェックインするべきだ。定期的にチェックインすることで変更が小さくなりビルドを壊す可能性も低くなる。  
極めて限定的な状況の除き、ブランチを使ってはならない。  
  
##### 包括的な自動テストスイートを作成すること  
```  
ユニットテスト  
コンポーネントテスト  
受け入れテスト  
```  
  
##### ビルドプロセスとテストプロセスを短く保つこと  
ビルドやテストにかかる時間を短くすること。  
そうしなければ、こまめなコミットが阻害されてしまう。  
  
##### 開発ワークスペースを管理すること  
開発者が作業に取り掛かる時は、常に正しく動くとわかっている開始地点から始められるべきだ。  
そのために以下を行う。  
```  
構成管理... CIサーバー上で自動テストを全て通った状態を開発環境に再現する。ソースコードだけでなくテストデータやデータベーススクリプト、ビルド・デプロイメントスクリプトも含む。  
依存関係の構成管理... 特定のバージョンのライブラリを用意できるようにする。  
スモークテストを含む自動テスト実行... 実行にある程度の努力が必要でも、開発機上で実行できることで品質が大きく向上する。  
```  
アプリケーションアーキテクチャが優れていることを示すひとつの指標として、  
アプリケーションがそれほど労力を払わず開発機上で実行できるようになっている、というものがある。  
  
### 継続的インテグレーションの必須プラクティス  
##### ・ビルドが壊れているときにはチェックインするな  
##### ・コミットする前に、常にローカルでコミットテストを実行せよ。あるいは代わりにCIサーバーにやってもらえ  
##### ・次の作業を始める前に、コミットテストが通るまで待て  
##### ・ビルドが壊れているのに家に帰ってはならない  
##### ・常に以前のリビジョンに戻す準備をしておくこと  
##### ・リバートする前にタイムボックスを切って修正する  
##### ・失敗したテストをコメントアウトするな  
##### ・自分が変更してビルドが壊れたら、すべてに対して責任をとれ  
##### ・テスト駆動開発  
  
### 継続的インテグレーションのやったほうが良いプラクティス  
##### ・エクストリームプログラミング（XP）の開発プラクティス  
##### ・アーキテクチャ上の違反事項があった場合にビルドを失敗させる  
##### ・テストが遅い場合にビルドを失敗させる  
##### ・警告やコードスタイルの違反があったときにビルドを失敗させる  

# テスト戦略を実装する
![テストの四象限図](/picture/継続的デリバリー1.png "テストの四象限図")  

```
どのテストも必ずテスト種別に属し、テストスコープを持つ。

・テスト種別（テストの四象限で表現）... 観点で分類される
開発プロセスを支援するビジネス視点のテスト
観点：ユーザーが求める機能を実装できたかどうか

開発プロセスを支援する技術視点のテスト
観点：エンジニアのコミットがアプリを壊していないかどうか

プロジェクトを評価するビジネス視点のテスト
観点：仕様がユーザーにとって正しく満足できるものかどうか

プロジェクトを評価する技術視点のテスト
観点：非機能要件（キャパシティ・可用性・セキュリティ）を満たしているかどうか


・テストスコープ（テストピラミッドで表現）
単体スコープ
アプリケーションは起動しない。
依存関係はスタブ/モックを利用する。

サービススコープ
アプリケーションを起動する。
依存関係はスタブ/モックを利用する。

エンドツーエンドスコープ
アプリケーションを起動する。
依存関係は本物を利用する。
```
  
### 開発プロセスを支援するビジネス視点のテスト  
この区画のテストは一般的に機能テストあるいは受け入れテストとして知られている。  
受け入れテストは、ストーリーに対する受け入れ基準が満たされていることを保証するテストだ。  
  
受け入れ基準は、構築するシステムのあらゆる属性をテストする。そこには  
```  
機能、キャパシティやユーザービリティ、セキュリティ、変更のしやすさ、可用性  
```  
といったものが含まれる。  
その中でも、機能を関心の対象とする受け入れテストは、機能受け入れテストと呼ばれる。(この区画のテスト）  
その他を関心の対象とする受け入れテストは、非機能受け入れテストであり「プロジェクトを評価する技術視点のテスト」の区画となる。  
  
あるストーリーに対する開発が始まる前に書かなければならず、理想的には自動化されるのが望ましい。  
  
受け入れテストはアジャイルを行なっている場合は欠かせない。なぜなら開発者の「どうすれば完了したとわかるのか？」という問いに答えると同時に、  
ユーザーの「必要なものは手に入ったのか？」という問いにも答えるからだ。  
したがって理想的には、各要件に対する成功条件を定義した後で、顧客やユーザーが受け入れテストを書くのが良い。  
（Cucumber, JBehae, Concordion, Twistといった機能テスト自動化ツールがある）  
  
### 開発プロセスを支援する技術視点のテスト  
この区画のテストには以下がある。  
```  
ユニットテスト... コードの特定の一部をテストする。  
コンポーネントテスト... コードを組み合わせたものをテストする。インテグレーションと呼ばれたりする。  
デプロイメントテスト... デプロイがうまくいったことを確認する。  
```  
  
### プロジェクトを評価するビジネス視点のテスト  
この区画のテストには以下がある。  
```  
ショーケース... ユーザーにイテレーションが終わるたびに新機能のデモを披露する。  
探索的テスト... 手作業で行うテストの一形態で、テスターがテスト設計をコントロールしていくテスト。  
ユーザービリティテスト... ユーザーがソフトウェアを使って目的を達成するのがどれほど簡単かを知るためのテスト。  
```  
  
### プロジェクトを評価する技術視点のテスト  
この区画は、  
受け入れ基準のうち、機能以外を関心の対象としたテスト（非機能受け入れテスト）となる。  
  
# デプロイメントパイプライン  
### デプロイメントパイプラインとは何か？  
抽象的に言えばデプロイメントパイプラインとは、ソフトウェアをバージョン管理から取り出してユーザーの手に渡すまでのプロセスを自動化して表現したものだ。  
理想的には受け入れテストもローカルで実行でき、ユビキタス言語で表現されるべきだ。  

# データを管理する  
### データベースのマイグレーション  
・マイグレーション種別  
```  
新スキーマ追加  
既存スキーマの変更  
```  
  
・アーキテクチャ  
```  
単一データベース  
blue-greenデータベース  
```  
  
・制約  
```  
ゼロダウンタイムリリース  
ロールバック  
```  
  
・テクニック  
```  
データベースのバージョン管理... データベースを管理するスクリプトをバージョン管理する。任意のマイグレーションツールを利用し、特定バージョンの構築・ロールバックを実現する。  
リードモード... データベースへの書き込みを停止させる仕組みをAppに用意しておく。  
Appデプロイとのマイグレーションの切り離し... Appにデータベースの前方互換性を持たせ、先にデプロイする。  
```  
  
# メモ
```
・コンポーネント（インテグレーション）テストと受け入れテストの違いは？
コンポーネント（インテグレーション）テストの定義は様々だが、我々は依存先のサービスとうまく結合できることを確認する意味で用いている。
アジャイルコミュニティの中にはユニットテストとコンポーネント（インテグレーション）テストを包括的に書き、
しっかりとビジネスとコミュニケーションをとることで、受け入れテストはいらないという考えを持つ人もいる。
しかし、テストの四象限図にあるとおり、この二つは目的と視点が違う。
コンポーネント（インテグレーション）テストは技術視点、受け入れテストはビジネス視点である。
つまり受け入れテストだけが、ユーザーの求める機能を満たしたことを確認してくれる。
コンポーネント（インテグレーション）テストは継続的デリバリーにおいては受け入れテストの一環として行われる。

・受け入れテストのDBと依存先サービスはモックか？
当然だが、依存先の本番環境にアクセスすることはない。（そもそもファイアウォールで弾かれるべきだ）
受け入れテストは２通りのコンテキストで行われる。
・依存先サービスが用意している検証環境
・コードベースの一部として作成したテストハーネス
場合によってはテストハーネスは状態を記憶できるように作り込まなければならない。

# CIサーバー上でローカルに起動する場合… 
DB… インメモリDBかテストハーネス
依存先サービス… 検証環境かテストハーネスかスタブサーバー

# 環境にデプロイしてテストする場合… 
DB… 環境用DBかインメモリDBかテストハーネス
依存先サービス… 検証環境かテストハーネスかスタブサーバー

※デプロイしてテストする場合、ライブラリ等でテストハーネスへの切り替えが難しい。
→ DIでテストハーネス用Beanを設定する。https://qiita.com/kazuki43zoo/items/8645d9765edd11c6f1dd （「切り替え」でページ内検索）
※実際の依存先にリクエストしてしまうと負荷がかかる。受け入れテストは１日に何度も行われる。
それを緩和する戦略としては、1日に1度、1週間に1度にしたりする。
※自動受け入れテストとUATの違いのひとつは、自動受け入れテストは外部システムとすべて統合された環境で実行してはならないということだ。
そうではなく、自動受け入れテストではテスト対象のシステムが実行できる制御可能な環境を提供することに集中しなければならない。
「制御可能」とは、テスト用の初期状態を正しく作れるということだ。（P266）
※基本的に受け入れテストはデプロイメントスクリプトでデプロイしたものが正しく動くかどうかをテストするため、環境にデプロイしてテストする。
依存先サービスについてはテストハーネスで細かいところまで網羅し、検証環境に対しては重要なシナリオだけをテストする。
```

  
  
# バージョン管理システムと開発手法  
  
```  
コードフリーズ... バージョン管理システムへのチェックインを数日から数週間にかけてやめてしまうこと。  
  
バージョンナンバーは、メジャー.マイナー.パッチとし、バージョンを上げるには、  
1. APIの変更に互換性のない場合はメジャーバージョンを、  
2. 後方互換性があり機能性を追加した場合はマイナーバージョンを、  
3. 後方互換性を伴うバグ修正をした場合はパッチバージョンを上げます。  
```  
  
### ・メインライン上での開発  
最も推奨される開発手法。  
ブランチ・マージという概念はない。  
アプリケーションをリリース可能な状態に保つテクニックを用いる。（継続的デリバリー P411）  
```  
フィーチャートグル... 新機能は完成するまで隠す。https://qiita.com/TsuyoshiUshio@github/items/51c6662cd45bded95389  
インクリメンタルな開発計画  
抽象化によるブランチ  
```  
  
### ・リリース用のブランチ  
次善の開発手法。（業界標準になりうる。）  
新機能の開発をメインラインで行う。  
リリース用のバグフィックスが新機能の開発に影響を及ぼさないようにするための手法。  
  
### ・フィーチャによるブランチ  
非推奨の開発手法。  
デメリットが多い。http://bliki-ja.github.io/FeatureBranch/  
```  
意味的衝突を招く... http://bliki-ja.github.io/SemanticConflict/  
リファクタリングへの抑止力として機能する... リファクタリングが意味的衝突を招きやすくするので、躊躇しがちになる。結果として、フィーチャーブランチを使用するチームはリファクタリングすることに尻込みし、コードベースが醜くなることを招く。  
```  
デメリットへの対策として、アプリケーションをリリース可能な状態に保つテクニックと共に、明示的に継続的インテグレーションを行う。  
これによりコードレビューのタイミングを与えられる。  
  
### ・チームによるブランチ  
省略  
