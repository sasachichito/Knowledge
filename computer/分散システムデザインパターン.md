# 分散システムデザインパターン  
  
## シングルノードパターン  
  
### サイドカー  
アプリを拡張・改善するパターン。  
サイドカーコンテナは様々なアプリに適用できるようにパラメータ化すること。  
  
```  
例1）HTTPS化  
SSLプロキシコンテナをアプリと同一のPodにデプロイする。  
既存のアプリに手を加えずに対応できる。  
```  
```  
例2）動的な設定変更の実現  
クラウド上の設定保存サービスとローカルの設定ファイルを同期させ、  
動的に変更をアプリに適用させるコンテナをアプリと同一のPod内にデプロイする。  
```  
```  
例3）PaaSの構築  
アプリの実行環境コンテナと、Git同期コンテナを同一Podにデプロイする。  
ソースコードが共有ディレクトリに配置されることでPaaSを実現する。  
```  
  
### アンバサダー  
アプリの外部システムへのリクエストを仲介するパターン。  
  
```  
例1）シャーディングされたDB接続の簡易化  
アプリからリクエストされ、適切なシャードを選択しにクセスするコンテナをアプリと同一Podにデプロイする。  
アプリ内でシャードを選択するロジックを書く必要がなくなりビジネスロジックに専念できる。  
```  
```  
例2）サービスブローカの実現  
サービスディスカバリ（サービスブローカに問い合わせて目的のサービスを探索する）コンテナをアプリと同一Podにデプロイする。  
アプリ内にサービスディスカバリのロジックを書く必要がなくなりビジネスロジックに専念できる。  
```  
```  
例3）カナリア・ABテストの実現  
アプリから新システムへ本番のトラフィックをteeするコンテナをアプリと同一Podにデプロイする。  
teeであるためアプリには影響を与えずに新システムの動作を確認できる。  
teeコンテナをマイクロサービスとして別Podにしても良いが、アンバサダとしてクライアント側に配置すると比較的運用管理が楽になる。  
```  
  
### アダプター  
外部システムが要求するインターフェースをアプリから分離するパターン。  
  
```  
例1）監視の実現  
標準的な監視システム（Prometheusなど）に独自のアプリの情報を提供するためのアダプタコンテナをアプリと同一Podにデプロイする。  
独自のアプリがPrometheusの要求するインターフェースを満たしていなくても、アダプタコンテナがその違いを吸収する。  
アプリが自身のビジネスロジックに専念できる。  
```  
```  
例2）ロギングの実現  
標準的なロギングツール（Fluentdなど）に独自のアプリの情報を提供するためのアダプタコンテナをアプリと同一Podにデプロイする。  
ログのフォーマットや内容、タイミングをアダプタコンテナが管理してくれる。  
```  
```  
例3）ヘルスモニタの実現  
独自・既存アプリに対して独自のヘルスチェックを行うアダプタコンテナをアプリと同一Podにデプロイする。  
アプリはビジネスロジックに専念でき、アダプタコンテナは広く再利用可能となる。  
```  
  
## マルチノードパターン  
  
### レプリケーション  
### シャーディング  
### スキャッタ・ギャザー  
### デコレーター  
### イベントベースパイプライン  
### オーナーシップ選出  
クラスタにおいてオーナーシップ(マスタまたはリーダーともいう）が常に区別されていなければならない場合の選出パターン。  
マスタが更新系を担い、参照用スレーブがそのデータをレプリケーションする構成への適用などが考えられる。（SolrCloudにおけるZooKeeper 参考 : https://techblog.zozo.com/entry/solr_cloud ）  
```
※補足
スレーブはマスタのホスト名を静的に認識している。
そのためマスタをレプリケーションやシャーディングで冗長化し必要に応じてスケールしたりサービスアウトしたとしても、
スレーブは何らかの手段でスケール・除外されたマスタを認識する必要がある。
これを自動的に行うには分散協調システム(ZooKeeper,Consulなど)を用いる。これによりマスタという役割を自動スケールできるようになる。

ちなみにデータのレプリケーションについてはマスタ・スレーブ共有のデータベースを用いれば必要なくなるが、
その場合データベース障害時にマスタ・スレーブ（更新・参照）のどちらも機能停止することを避けられない。
```

# バッチ処理パターン  
  
### ワークキューシステム  
ワークアイテムのかたまり（バッチ）をワーカが処理する、バッチ処理の最も簡単なパターン。  
ワークキューシステムのゴールは一定時間内にワークアイテムを処理することであり、  
そのためにワーカをスケールアップ・ダウンできるパターンである。  
  
ワークアイテムのバッチを取り込みワーカで処理する仕組みを「ワークキュー」と呼んでいる。  
  
単一のワークキューで構成される場合はワークキューシステムという。  
```  
・マルチワーカパターン  
ワーカが単一のワークアイテムに対して複数の処理を実行し結果をまとめるワークキューパターン。  
複数の処理を別々のコンテナの分け1つのPodにグループ化する。  
これにより処理のコードがシンプルになり、再利用性も高めることができる。  
```  
  
対してあるワークキューの出力をワークアイテムストリームとして別のワークキューに繋げたシステムを「ワークフローシステム」という。  
  
### コピア  
ワークアイテムのストリームを1つ取り込み、それを2つ以上のストリームにコピーするワークフローパターン。  
同じワークアイテムに対して複数の違った処理を行うときに利用する。  
  
### フィルタ  
ワークアイテムのストリームを取り込み、ある一定のルールに当てはまらないワークアイテムをフィルタするワークフローパターン。  
  
### スプリッタ  
ワークアイテムのストリームを取り込み、独自のルールに応じて複数のストリームに分類するワークフローパターン。  
分類の過程で単一のワークアイテムが複数のストリームに入る可能性もあるのでコピアでもある。  
  
### シャーダ  
ワークアイテムのストリームを取り込み、シャード関数に応じて複数のストリームに分類するワークフローパターン。  
スプリッタよりも汎用的で、その目的は信頼性の確保である。  
シャーディングすることで障害時に一部のワークキューを切り離したり、カナリアリリースが可能となる。  
  
スプリッタやシャーダはMapReduceパターンにおけるMapにあたる。  
  
### マージャ  
ワークアイテムのストリームを2つ以上取り込み、それらを1つのストリームにするワークフローパターン。  
コピアの逆となる。  
  
### 結合（バリア同期）  
ワークアイテムのストリームを2つ以上取り込み、特定ワークアイテムの処理がそれら全てのストリームで完了したら  
次の1つのストリームにリリースする協調的バッチ処理のワークフローパターン。  
マージャと異なりまとめられるタイミングが制御されており、場合によっては結合のタイミングでワークアイテムの数が減ることもある。  
  
### Reduce  
ワークアイテムのストリームを2つ以上取り込み、それらを順次1つの結果にまとめていく協調的バッチ処理のワークフローパターン。  
結合よりも楽観的に結果をまとめていく。まとめ終わるまで何度も起動される。  
