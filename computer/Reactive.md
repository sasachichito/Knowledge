# Reactive Programming(RP)  
「データフロー」＋「変更の伝播」指向のプログラミングパラダイム。  
実現には  
「データフロー」を記述できるプログラミングモデルと、  
「変更の伝播」をプログラマに代わって実行するランタイムが必要。  
  
プログラミングモデル :   
オブジェクト指向RP(OORP)  
関数型RP(FRP)... データフローを宣言的に記述することが可能  
など。  
  
ランタイム :   
Reactive Extensions(Rx)... 各言語でReactive Programmingを実現できるライブラリの総称  
  
# Reactive Manifesto  
[リアクティブ宣言](https://www.reactivemanifesto.org/ja)で述べられたアーキテクチャ。  
この「リアクティブ」はRPから借りてはいるが  
「外部からの刺激に反応する」という意味合いを強調した別物である。（イベント、負荷、障害、ユーザー...）  
とはいえメッセージ駆動による非同期プログラミングが大前提となるため、実装手段としてRPは有力である。  
  
# Reactive Streams  
[Reactive Streams入門](https://speakerdeck.com/okapies/reactive-streams-ru-men-number-jjug)  
[Reactive Streams](http://www.reactive-streams.org/)  
JVMとJavaScriptにおけるノンブロッキングなバックプレッシャーを持つ非同期ストリーム処理の仕様。  
Reactor、RxJava、[Java9のjava.util.concurrent.Flow](https://codezine.jp/article/detail/10668)などが実装している。  
DBアクセスライブラリのアダプタ実装もある。  
  
# 同期(Sync)と非同期(Async)  
参考 : https://qiita.com/kencharos/items/2ad090e7a6b7e9664f04  
https://moz.hatenablog.jp/entry/2018/04/10/175643  
https://yuk1tyd.hatenablog.com/entry/2018/03/10/145159  
  
同期(Sync) : タスクの完了を待つこと。  
非同期(Async) : タスクの完了を待たないこと。  
  
CPU /  IO / スレッド それぞれの処理方法を同期・非同期の観点で捉える。  
  
### CPU  
逐次(Sequential) : 同期  
複数タスクを逐次で単一CPUで処理すること。  
  
並行(Concurrent) : 非同期  
同時に処理しているように見せかけること。  
各タスクをナノ秒ごとのタイムスライスで区切って順不同でCPUに割り振る。  
  
並列(Parallel) : 非同期  
同時に処理すること。マルチコアのCPUで可能となる。  
並列(Parallel)であれば必ず並行(Concurrent)であるが、その逆は真ではない。  
  
### IO  
ブロッキングIO : 同期  
システムリソース（ファイルディスクリプタやソケット）の準備や排他制御で待ち時間が発生したとき、待機する。  
  
ノンブロッキングIO : 非同期  
待機せずエラーを返す。  
エラータスクをキューに入れておき別のタスクを開始することで、待機時間を0にする仕組み。  
常にキューからタスクを取り出し実行を試みる。  
  
非同期IO : 非同期  
バックグラウンドで待機させて別のタスクを処理する。待機タスクは処理が終了したら通知する。  
  
### スレッド  
シングルスレッド : 同期  
プロセスが単一スレッドで処理される。  
  
マルチスレッド : 非同期  
複数スレッドで同時に処理される。  
CPUの並行もしくは並列処理で実現される。  
  
# 命令型・宣言型プログラミング  
両者の違いは、言語処理系に対するプログラムの捉えさせ方。  
  
#### 命令型   
命令と捉えさせ、その通りに処理させる。  
```  
x = 1        // xに1を代入する  
y = x + 2  // yにxに2を足したものを代入する  
print y      // yを表示する  
```  
言語処理系は上から順番に実行する → 3が表示される  
  
#### 宣言型  
宣言と捉えさせ、そういうものだと認識させる。  
```  
x = 1                // xとは1である  
y = x + 2          // yとはxに2を足したものである  
main = print y  // mainとはyを表示すること  
```  
言語処理系はmainを実行する → 3が表示される  
  
結局のところコンピュータなので命令が実行されるのだが、  
宣言型では"何が"なされるべきか(つまり仕様そのもの)の宣言の連続により、ソースコードから"どのように"という概念を取り除いている。  
従って例えばコードの順番が変わっても宣言が漏れていなければ問題ない。  
```  
main = print y  // mainとはyを表示すること  
y = x + 2          // yとはxに2を足したものである  
x = 1                // xとは1である  
```  
これによりソースコードを「仕様を満たすためのロジック」ではなく「仕様」として扱えるメリットがある。  
