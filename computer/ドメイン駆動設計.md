# エリック・エヴァンスのドメイン駆動設計  
  
### ソフトウェアのドメインとは  
ソフトウェア（システム）の動作に影響する事象  
ソフトウェア（システム）になるもの  
ソフトウェア（システム）を使った事業  
  
### モデルとは  
知識を表現するもの  
  
### ドキュメントの必要性  
システムの進化に伴いメンテナンスが必要なドキュメントは不要である。  
ソースコードが仕様書となるべき。  
  
### ユビキタス言語  
ビジネス側と開発側で統一された言語  
  
### レイヤ化アーキテクチャ  
ドメインをソフトウェアの事情から切り離し、ビジネスロジックに専念させるための考え方。  
  
# ドメインのモデルを作る  
### モデル駆動設計とは  
ドメインエキスパートがビジネス目線でドメインを分析し、ソフトウェアで果たす役割を考慮していない分析モデルが作成される。  
分析モデルには設計や実装をし始めてようやく発見できる重大な課題・問題は含まれない。  
そのため開発者は分析モデルとは別でシステムを設計する。    
この分析モデルと設計の2分法を捨て、分析・設計の両方に使える単一のモデルを探し出すことをモデル駆動設計という。  
  
### ブレインストーミングで知識を噛み砕き、クラス図に落とし込む  
クラス図でなくても、ソースコードの仕様が決まるレベルにする。  
  
### 根底のモデルは一つだけ  
設計・実装・チームでのコミュニケーション等の根底にあるモデルは一つだけ。  
それぞれで説明用のモデルを用いることは正しい。  
  
### 関連を扱いやすくする  
モデル（クラス図）の関連の実装方法は複数ある。  
関連オブジェクトをプロパティに持ったり、データベースアクセスをラップして動的に取得したりなど。  
これでは良いモデルではないので、以下を実施する。  
- 関連を辿る方向を強制する  
- 限定子を付加して多重度を減らす  
- 本質的でない関連を除去する  
  
### モジュール（パッケージ）を適切にする  
クラスと同じように、モジュール構成のリファクタリングを続けることが大事。  
モジュール名はユビキタス言語からなる。  
  
# モデルを構成する3種類の要素(ドメインオブジェクト)  
## ・エンティティ（別名：参照オブジェクト）  
連続性（ライフサイクル）と同一性（一意性）持つオブジェクト  
- 責務  
  - エンティティを識別する手段の提供  
  - 各ライフサイクルにおける振る舞いの提供  
  
## ・値オブジェクト（Value Object）  
値を保持し、操作を提供するオブジェクト  
- 責務  
  - 値の操作方法の提供  
  - 値の不変性の約束  
  
※値オブジェクトか？エンティティか？  
モデルの属性だけがドメインであれば値オブジェクトになる。  
モデルの存在（同モデルの他インスタンスとの関係）がドメインであればエンティティになる。  
  
※値オブジェクト同士で双方向の関連を持つことはない。  
そもそも双方向の関連は、関連オブジェクト同士でメッセージを交換しあえる意味がある。  
そのため相手が自分のポインタを持つ特定の状態のオブジェクトでなければならない場合に有効になる。  
特定の状態を持つオブジェクトは、エンティティとなる。  
値オブジェクトでは特定の状態を持たないので、メッセージを送りたければ動的に取得すれば良い。  
双方向の関連はモデル化の段階で除去すること。  
  
## ・サービス（Service)  
ドメインにおける重要なプロセスや変換処理が、エンティティや値オブジェクトの自然な責務にならない場合に  
モデルに追加されるインターフェース。  
- 責務  
  - 操作に状態がない  
  - 操作名がユビキタス言語の一部になること  
  
※サービスを各レイヤに分割する  
細粒度のドメインオブジェクトを作り上げていくと、その振る舞いが組み合わさる場所がアプリケーション層になり、  
ドメイン層からアプリケーション層へ知識が流出してしまう。  
サービス（ドメインサービス）を慎重に導入し、それを防ぐことが必要。  
- アプリケーション層のサービス  
ユーザーインターフェースからの入力を受け付ける。  
ドメインサービスにメッセージを送信する。  
インフラストラクチャサービスにメッセージを送信する。  
- ドメインサービス  
エンティティや値オブジェクトをまとめ上げて処理を行う。  
- インフラストラクチャサービス  
記録や通知の仕組みを提供する。  
ビジネスロジックを一切含まない。  
  
# ドメインオブジェクトのライフサイクルの課題を解決する  
- 課題  
  - 1.ライフサイクルを通じて整合性（不変条件）を維持すること  
  - 2.ライフサイクルの管理の複雑さからモデルを切り離すこと  
  
**※不変条件とは**  
モデルが責務を全うするために必要な正しい状態を保つための条件。  
複雑な関連を伴うモデルでは個々のモデルだけではなく関連するオブジェクトのグループに対して不変条件があり、    
これが適切でないとそのグループは整合性を保てない。    
  
これら2つの課題を3つのパターンを用いて解決する。  
  
## ・集約(Aggregates)  
集約とは関連するオブジェクトの集まりのこと。  
不変条件を持つドメインオブジェクトグループに対する呼び方であり、実装方法が決まっている。  
課題１を解決する。  
##### 集約はルートと境界を持つ。  
- ルート    
集約に含まれている特定の一つのエンティティ    
- 境界    
集約の中身の定義  
  
外部のオブジェクトが参照して良いのはルートだけ。  
境界内のルート以外のエンティティの同一性は集約内部だけで保たれれば良い。  
自動車の例）  
自動車を一意に識別する識別子がある。  
タイヤの走行距離と摩耗度の測定のため各タイヤに識別子を持たせる。  
特定の自動車をシステムに問い合わせ、装着しているタイヤを参照することはあるが、  
特定のタイヤをシステムに問い合わせ、それがどの自動車に装着されているか調べる人はいないし、  
タイヤが交換され自動車を離れた後、同種のタイヤの山の中で同一性を保つ必要はない。  
この場合、自動車エンティティがルートになり、境界は自動車エンティティとタイヤエンティティとなる。  
  
##### 集約の不変条件  
不変条件を満たした状態を維持する集約の実装方法  
```  
・ 集約のルートエンティティは、グローバルな同一性を持ち、不変条件をチェックする最終的な責務を負う。  
・ ルートエンティティはグローバルな同一性を持つ。境界内部のエンティティは、集約内でのみ一意となるローカルな同一性を持つ。  
・ 集約の境界外にあるオブジェクトは、ルートエンティティを除き、境界内部への参照を保持することができない。ルートエンティティは内部のエンティティへの参照を他のオブジェクトに渡せるが  
  受け取ったオブジェクトは参照を一時的に使用することができるだけで、その参照を保持してはならない。ルートは値オブジェクトのコピーを別のオブジェクトに渡すこともあるが、  
  その場合はそのコピーがどうなってもよい。渡されるのは単なる値で、集約とは何の関連もなくなるからである。  
・ 前述のルールの必然的結果として、データベースに問い合わせて直接取得できるのは、集約ルートだけとなる。それ以外のオブジェクトはすべて、関連を辿ることで取得しなければならない。  
・ 集約内部のオブジェクトは、他の集約ルートへの参照を保持することができる。  
・ 削除の操作は、集約境界の内部に存在するあらゆるものを一度に削除しなければならない  
 （ガベージコレクションがあれば簡単である。ルート以外に対しては、外部から参照されていないので、ルートを削除した際に、他もすべてガベージコレクションすればよい）。  
・ 集約境界の内部に存在するオブジェクトに対する変更がコミットされる時には、集約全体の不変条件がすべて満たされていなければならない。  
  
Eric Evans. エリック・エヴァンスのドメイン駆動設計 (Kindle の位置No.3141-3143). 翔泳社. Kindle 版.   
```  
一つの集約内のデータに変更があったとき不変条件は、トランザクションの完了時に満たされることを強制する。  
不変条件が複数の集約にまたがる場合は一時的に不変条件を満たさないタイミングがあるが、バッチ等で一定時間内に解消する。  
  
## ・ファクトリ（Factories）  
3種類のドメインオブジェクトそれぞれが持つ責務の中に自身のオブジェクト作成は含まれない。  
そのためドメイン層にはドメインオブジェクトに加え、ドメインオブジェクト作成を担当する要素（ファクトリ）が追加される。    
課題2を解決する。  
  
##### ファクトリのデザインパターン  
ファクトリメソッド  
抽象ファクトリ  
ビルダ  
  
##### ファクトリの実現方法  
1. 集約のルートにファクトリメソッドを定義する  
2. 生成対象に渡すパラメータを持つ別境界のドメインオブジェクトにファクトリメソッドを定義する  
3. 専用のファクトリオブジェクトかサービスを新規に作成する  
  
※1→2→3の優先順  
  
##### 優れたファクトリの条件  
- ファクトリが生成するドメインオブジェクトはその必ず不変条件を満たした状態で作成される。  
不変条件を満たせない場合は例外をスローしたりnullを返却するなどのコーディング規約に従った動作をする。　　  
- 集約のルートの抽象クラスやインターフェースに対して１つのファクトリを用意する(?)  
- ファクトリは引数を単純に使うこと。引数を生成物に設定するだけが理想であり引数はオブジェクトでも良い。  
  
##### ファクトリが不要な場合  
クラスコンストラクタでインスタンス生成する方が良い場合がある。  
1. 構造が簡単なドメインオブジェクト  
2. 抽象化されていないクラス(?)  
  
※コンストラクタの中で他のクラスのコンストラクタを呼び出す場合は複雑となるため素直にファクトリを用意する。  
  
##### ファクトリは新規作成だけでなく再構成も担う  
ファクトリで担う再構成の責務は、与えられた引数からドメインオブジェクトを生成し返却することである。  
  
## ・リポジトリ（Repositories)    
ドメインオブジェクトのストレージへの移動、ストレージからの移動（再構成）を担うドメイン層の要素。  
クライアントに、すでに存在するドメインオブジェクトの参照を手に入れる手段を提供する。    
課題2を解決する。  
  
##### リポジトリの責務  
- 全ての集約のルートオブジェクトで構成されるコレクションがメモリ上にあると錯覚させること  
- ストレージ（DB等）への問い合わせの技術をカプセル化する(リポジトリとはユビキタス言語でやり取りする)  
- インスタンス化されたドメインオブジェクトか、ドメインオブジェクトのコレクションを返却するメソッドを提供する  
- ストレージ上での集約のルート以外へのグローバルアクセスを防ぐ  
  
##### リポジトリの利点  
- 永続化技術からドメインの設計を切り離せる  
- テスト用にダミー実装と切り替えることが容易になる  
  
##### リポジトリの内部動作  
- SQLを実行し結果セットをファクトリで再構成してクライアントに返却する  
- ORマッパーを使ってオブジェクトを取得して返却する  
  
##### リポジトリ実装時と注意点    
- 型を抽象化すること(?)  
集約のルートの抽象クラスやインターフェースに対して１つのリポジトリを用意する  
- カプセル化の利点を活かすこと    
SQLをDB実装に合わせて最適化したり、結果をキャッシュすることができることを意識しておく。  
- トランザクション制御はしない  
作業単位を知っているのはアプリケーション層かドメイン層なので、そちらに任せる。    
  

# メモ
```
第3部 より深い洞察へ向かうリファクタリング
【序章】
リファクタリングはコードの良し悪しが動機となることが多いが、ドメインについての洞察に基づくリファクタリングは重要になる。
・深いモデル
深いモデルは、ドメインエキスパートの主要な関心事と、それに最も深く関連した知識に関する明快な表現を提供する。
・発見のプロセス
抱えている問題に本当に合った設計を作り出すためには
まずはドメインと最も関連の深い、中心となる概念を捉えるモデルを発見する必要がある。これを第9章「暗黙的な概念を明示的にする」で扱う。
コードのリファクタリングが難しいとモデリングのプロセスが止まってしまう。
ソフトウェア開発者のためにソフトウェアを作成する方法が必要だ。これを第10章「しなやかな設計」で扱う。
見つけだした概念をモデルにする上で適切な方法を見つける必要がある。そこですでに使えるパターンがあるかもしれない。
これを第11章「アナリシスパターン」、第12章「デザインパターン」で扱う。
・ブレイクスルー
ドメイン駆動設計を行っていると、ソフトウェアを予想以上に表現力豊かで用途が多いものへと変える機会が訪れる。
これをブレイクスルーと呼ぶ。ブレイクスルーは前もって計画しておくことができないものだ。
第8章「ブレイクスルー」でその一例を紹介する。


【第8章 ブレイクスルー】
狙って起こるものではないから焦らずにコツコツのリファクタリングを行うこと。


【第9章 暗黙的な概念を明示的にする】
ドメインエキスパートの言葉をよく聞こう。
それほど明白ではない概念をモデル化する方法を学ぼう。これにより設計が鋭くなる。これには3つのカテゴリがある。
1 明示的な制約
ドメインオブジェクトの操作一つ一つに明示的な制約（ルール）があることはよくある。
操作メソッドの中にルールを記載すると、ルールが複雑になっていくと、ドメインオブジェクトの操作をルールが圧倒してしまう。
その制約を該当ドメインオブジェクトのプライベートなメソッドに適切な名前をつけて切り出すことで、わかりやすく、変更もしやすくなる。

2 ドメインオブジェクトとしてのプロセス
複雑なアルゴリズムを伴う手続きをプロセスと呼んでいる。
基本的にオブジェクトは手続きをカプセル化してくれるものである。
ドメインの中に登場するプロセスは、ドメインモデルとして設計しなければならない。（例えば輸送アプリケーションの経路選択プロセス）
そういう場合は、ドメインモデルの中に「〜サービス」クラスを用意することで、そういったプロセスがあることを言葉で明示的に表現しつつ、カプセル化できる。
また、プロセスの実行方法が複数あるときは、アルゴリズムをストラテジーパターンで実装する手段も考えられる。
プロセスの実装がドメインモデルに含まれるべきか、インフラストラクチャ層にあるべきかを判断するのは簡単で、
そのプロセスについてドメインエキスパートが話題にあげるかどうかである。

3 仕様
これはいわゆる仕様パターンである。
仕様が複数ある場合は、それぞれを仕様オブジェクトにするようだ。


【第10章 しなやかな設計】
オーバーエンジニアリング（必要以上の設計）だとクライアントが操作しきれない。
モデル駆動設計では、適度に厳密な設計スタイルが必要である。
開発者には2つの役割がある。1つがクライアント開発者である。クライアント開発者は設計の持つ能力を活用しながら、ドメインオブジェクトをアプリケーションコード
や他のドメインオブジェクトに織り込んでいく。
クライアント開発者は、疎結合した概念を最低限集めたものを柔軟に使用して、ドメインにおける幅広いシナリオを表現できる。
もう一方のモデル開発者にとっても、モデルは変更に強く、わかりやすいものでなくてはならない。
そういったしなやかな設計に貢献するパターンを紹介していく。

・意図の明白なインターフェース
ある開発者があるコンポーネント（オブジェクト）を使用するために、その実装についてじっくり考えなければならないのであれば、カプセル化の価値は失われる。
たまたま開発者の要求を満たしているからという理由で、コンポーネントが意図しない目的で利用されてしまうかもしれない。
さしあたりコードは動くかもしれないが、後ほど修正したときに不具合が発生することは明白である。
それゆえ：
　クラスと操作には、その効果と目的を記述する名前をつけ、その手段には言及しないこと。こうすることでクライアント開発者はインターフェースの内部を理解しなくて良くなる。
こうした名前にはユビキタス言語を用いること。

・副作用のない関数
操作はクエリとコマンドに分けられる。コマンドは更新処理であり、副作用を持つ。
更新処理が副作用を持つのは、メソッド呼び出しの深いネストにより意図しない更新処理が起こることがよくあるためである。
コマンドを使わないシステムはないが、副作用を防ぐために2つの手段がある。

・表明
契約による設計を使う。不変条件・事前条件・事後条件をユニットテストで表現しておく。
モデル図とソースコードコメントにその表記を加えること。

・概念の輪郭
機能を細かく切り刻んでメソッドにすれば、クライアントがそれを組み合わせることになる。
機能を大きくまとめてメソッドにすれば、クライアントの要求に合わず、機能が重複する。
概念的に意味のある機能の単位を見つけ出すこと。

・独立したクラス
独立したクラスとは、低結合を極限まで進めたものだ。

・閉じた操作
・宣言的な設計
・設計の宣言的スタイル

これらのパターンはモデルに適用していくものだが、モデルは巨大なため、簡単に適用できるものではない。まずは対象を決めなければならない。
より大きな設計を引き受けるに当たってのアプローチを2つ紹介する。どのようにパターンを適合させ、利用するかを説明する。

・サブドメインを切り取る
どのようにサブドメインを選択するかは第15章で議論する。

・可能な場合には、確立された形式主義を利用する

【第11章 アナリシスパターンを適用する】

【第12章 デザインパターンをモデルに関係づける】
・ストラテジーパターン
ストラテジーパターンを使うと、クライアントがどのストラテジーを使うのか知らなければならないが、
ユーザーが画面上などからストラテジーを選択しているのであれば区分オブジェクトにストラテジーの実装を埋め込んでおけば
アプリケーションコードでif文は必要ない。
クライアントが様々なストラテジークラスの存在（クラス名）を自然と理解できるようなモデルであればこのパターンを使う価値がある。
つまりストラテジーを使うクラスのクラス名やメソッド名に加えて、意味のレイヤをもう一つ追加しなければならない。

・コンポジットパターン

【第13章 より深い洞察へ向かうリファクタリング】

第4部
```

```
ドメイン＝論理モデルの集合

一つの論理モデル＝アプリケーションの用途の一つを実現する仕組み

コンテキスト＝論理モデルに統一性を与える条件の集合（コードの一部、チームでの作業、会話、資料）

論理モデルに統一性がある＝論理モデルを構成するユビキタス言語に一貫性がある状態

オブジェクトモデル（モデルオブジェクト）＝論理モデルをコードで表したもの

サブドメイン＝一つの論理モデル（アプリケーションの用途の一つ）

コアドメイン＝サブドメインの中で最も重要なもの。

汎用サブドメイン＝サブドメイン中のコアドメイン以外のもの。

複数の論理モデルに起因する問題（複数の論理モデルに基づくコードが組み合わされる問題）
→顧客への請求（論理）モデルと、ベンダーへの支払い（論理）モデルが一つの料金オブジェクトを使う。
発生する問題：「料金」というユビキタス言語に一貫性がない（請求するものなのか、支払うものなのか分からない）
原因1:もともと複数の論理モデルであるということを認識できていない
原因2:本来一つの論理モデルがチームが違う、コードベースが違う、データベースが違うことが原因で複数のコンテキストに適用され、複数の論理モデルとして認識される

境界づけられたコンテキスト＝複数の論理モデルに起因する問題を解決するための手法。サブドメイン（一つの論理モデル）に対して明示的に一つのコンテキストがあることを宣言することで、一つのチーム、一つのコード、一つのデータベースを割り当てて、論理モデルの統一性を保つことができる。
```
  
  
# 実践ドメイン駆動設計  
  
### ドメインエキスパート   
ドメインに関する深い業務知識を持つ人  
  
### 軽量DDD  
サブドメイン、境界づけられたコンテキスト、コンテキストマップ、ユビキタス言語を見つけていく戦略的設計を行わず、  
```ドメインオブジェクト ＋ 集約の概念 ＋ ファクトリ ＋ リポジトリ```  
を利用する戦術的アプローチのこと。良くない。  
  
### 境界づけられたコンテキスト  
ドメインモデル上の概念的な区切り。一つあるいは複数のサブドメインを含む。  
名前は「モデル名＋コンテキスト」になる。  
  
### コンテキストマップ  
境界づけられたコンテキストどうしの関連  
  
### ヘキサゴナルアーキテクチャ  
ドメインモデルにおける境界づけられたコンテキストの表現方法。  
サービス指向やマイクロサービスなどの様々なアーキテクチャに対応できる書き方。  
  
### ドメインモデル貧血症  
大半がpublicなゲッターセッターで、単に属性と値を保持するだけのオブジェクト  
  
### 貧血誘発性記憶喪失  
ドメインモデル貧血症によりコードから意図が読み取れない状態  
  
### 実装  
ユビキタス言語を用いたテスト駆動で開発し、ドメインエキスパートにレビューをもらう  
  
### ドメインとサブドメイン  
##### そもそもドメインとは？  
ドメイン（広義）=  組織が行う事業や、それを取り巻く世界。  
事業が市場（顧客）の定義し、プロダクトやサービスを販売する。  
様々な業務により事業は成り立つ。業務にはノウハウと物事の進め方がある。  
「どこかの組織のためのソフトウェアを作る = その組織のドメイン（事業を取り巻く世界）で作業する」  
  
##### サブドメインとは？  
ドメイン（組織が行う事業）を成り立たせる、一つの業務を指す。  
業務は「〇〇を〜〜する」と表現でき、〇〇がサブドメインとして取り上げられる。  
  
・なんで戦略的設計が大事？  
サブドメインがハッキリすることで、システムが大きな泥団子にならない。  
コアドメインなのか、他のサブドメインから利用される汎用ドメインとなるかハッキリさせることができる。  
  
サブドメインの種類  
  - コアドメイン...ドメインのコア  
  - 支援ドメイン...業務に不可欠だがコアドメインほどではない  
  - 汎用ドメイン...業務上で特別なことはしていないがドメインを支援している  
  
### ドメインは問題空間と解決空間を持つ  
- 問題空間  
解決すべきビジネス戦略上の課題。  
「問題空間を評価する」とは、その課題を浮き彫りにすること。  
評価した結果はドメインモデル上でサブドメインとして表現される。  
  
- 解決空間  
問題空間のソリューション。  
「解決空間を評価する」とは、問題空間をソフトウェアでどのように解決するかに注目すること。  
評価した結果はドメインモデル上で境界づけられたコンテキストとコンテキストマップして表現される。  
  
サブドメインと境界づけられたコンテキストを一対一で対応させることが望ましい。  
  
  
# メモ  
```  
・システム間連携パターンは4種類（書籍「Enterprise Integration Patterns」）  
データベース共有（Shared Database）  
ファイル転送（File Transfer）  
リモートメソッド呼び出し（Remote Method Invocation）  
メッセージング（Messaging）  
  
・腐敗防止層とは？  
下流の「境界づけられたコンテキスト」が、上流の「境界づけられたコンテキスト」からオブジェクトを受け取るときに用いる。  
上流では集約だったものも、下流で受け取るときは値オブジェクトにするべき。  
そうすることで下流に責務が流れ込まず、管理するオブジェクトの数も減るので扱いが楽になる。  
腐敗防止層の技術的な実装は、専用のアダプターと変換サービスの組み合わせになることが一般的。  
  
・自己カプセル化  
クラス内部からのアクセスもアクセサメソッド経由で行うこと  
アクセサメソッドにバリデーションチェック処理（ガード）を設定しておくことで、  
「契約による設計」における事前条件を満たしていることを確認している。（不正な値でればExceptionをスロー）  
エンティティでは「属性単位」「オブジェクト全体」「複数オブジェクト時」という3つの粒度に分けてバリデーションを管理する。  
「属性単位」はエンティティ生成時に自己カプセル化のガードで実装。  
「オブジェクト全体」は専用のバリデータクラスを生成し、「遅延バリデーション（可能な限り先送り）」を行う。  
「複数オブジェクト時」は集約のルートのEntityに対して、「遅延バリデーション（可能な限り先送り）」を行う。  
ドメインサービスで制御する場合は、エンティティがチェック可能なタイミングになったら、オブジェクト側からバリデーション可能な旨のイベントを  
サービス（クライアント）側へ通知して、チェックを実行。  
  
・ドメインサービスとは？  
ドメインオブジェクトの自然な責務にならない処理を持つ、ステートレスなオブジェクト。  
ドメインサービスの主な役割として、様々なエンティティや値オブジェクト、集約を利用して計算するビジネスルールが挙げられる。  
本来ドメインオブジェクトが持つべき責務がドメインサービスに染み出さないように注意すること。  
また、ドメインサービスの処理をアプリケーション層のサービスには書いてはいけない。  
アプリケーション層のサービスは、トランザクションやセキュリティといった、ドメインの外側の関心ごとの実装を受け持つ。  
集約の境界が他の集約のリポジトリを持つべきではないから、ドメインサービスに持たせる。  
アプリケーションサービスが、ユースケースを実現するために、複数あるいは別種類の集約どうしの連携を担当してはいけない。  
それはもはや業務ロジックであり、ドメインサービスが担当すべきだ。  
ドメインサービスは、複数の集約をリポジトリから取得でき、比較・計算・判断・加工処理を行える。  
アプリケーションサービスがプロパティの絞り込みで集約のコレクションをもらってデータとして出力したい場合は、業務ロジックを含まないし  
更新処理でもないのでコマンドモデルである集約を取得するのではなく、クエリーモデルを使うべきだ。  
クエリーモデルを取得する際に、SQL文で別種類の集約分のデータをJOINしてWHERE句でロジックを実現してはいけない。それはもはや業務ロジックである。  
このような場合は、ドメインサービスが各種類の集約のリポジトリを使って集約のコレクションを取得し、モデルのメソッドを使って判断・加工していく。  
そして結果を値オブジェクトで返却してもらう。  
クエリーモデルを使うのは、単一集約分のデータをプロパティで絞り込んで取得し、そのまま利用するだけ。  
ファクトリとしてのドメインサービスが存在するが、わかりやすくするために〜Factoryクラスを作った方が良い。  
  
・標準型・タイプコード・区分オブジェクト  
区分や種類を表すオブジェクトを指す。  
１グループの区分や種類に対して、〜タイプという値オブジェクトを一つ作成しても良いが  
シンプルさを求めてenumを使うことが推奨される  
  
・セパレートインターフェースとは？  
実装クラスとは別のパッケージでインターフェースを定義すること。  
依存関係逆転の原則で用いられる。  
ヘキサゴナルアーキテクチャのport&adapter層にあるリポジトリ実装の  
インターフェースをドメイン層に持たせているのもセパレートインターフェースである。  
実装の選択にはDIコンテナを使うと良い。  
  
・ドメインイベントとは？  
ドメインエキスパートが注目する出来事にフォーカスする。  
「〜する時に」「〜した場合に知らせて」などをイベントとして定義する。  
イベントの発行を「パブリッシャー」で行い、イベントの受信を「サブスクライバ」で行う。  
ドメインイベントクラスは不変クラスになる。  
パブリッシャーとサブスクライバが一つの境界づけられたコンテキスト内にある場合で、同期処理の場合オブザーバーパターンで実装する。  
別の境界づけられたコンテキストに別れている場合や、非同期処理の場合は、サブスクライバは自コンテキスト内のイベントストアにイベントを格納する。  
別コンテキストのイベント検知用クライアントが、イベントストアをポーリング(RESTfullAPI)して、イベントを受信する。  
非同期の場合、イベント発行側のコンテキストが「自立型のサービス」となるため、外部システムの影響を受けない良い設計となる。  
同じイベントを何度も受診しても問題ないように設計する。  
  
・認証アクセスコンテキストの「ユーザー」「ロール」からコラボレーションコンテキストの「コラボレーター」にはどう変換された？  
認証アクセスコンテキストにRESTfullAPIでデータを取得し、腐敗防止層を経て、ファクトリとしてのドメインサービスのメソッドから取得する。  
クライアント  
↓  
ここからドメイン層  
ドメインサービス(抽象)  
↓  
ここからport&adaptor層  
ドメインサービス(実装)  
↓  
アダプター(抽象)  
↓  
アダプター(実装)  
↓REST  
認証アクセスコンテキスト（公開ホスト）  
  
・ファクトリの場所、種類  
DDDでは集約を作成するファクトリを用意する。ファクトリの場所は  
1.集約ルートのコンストラクタ  
2.別の集約上のメソッド  
3.ドメインサービスクラス  
に作られる。ファクトリを使えば、処理中の通常のインスタンス化も、別の境界づけれたコンテキスト(公開ホスト)からのドメインモデル連携  
も同じように扱える。  
2.別の集約上のメソッド（いわゆるファクトリーメソッド）ではガードを入れることができる。  
ファクトリの種類はファクトリー、ファクトリーメソッド、アブストラクトファクトリー、ビルダーパターンが挙げられる。  
アブストラクトファクトリーパターンを用いるのは、クラス階層ができた場合である。どういう風に使うのか？  
値オブジェクトの生成にもファクトリが利用される。リポジトリと違ってファクトリの利用場所にシビアになる必要はない。  
それはインスタンスの生成自体に問題はなく、結局のところ集約が保存されるときに不変条件さえ満たしていればシステムは壊れないから。  
ファクトリは複雑なインスタンス生成処理をラップする目的であれば抽象化する必要はないが、  
別コンテキストや永続化層からデータを取得してインスタンス化する場合はインターフェースを定義し、port&adaper層に実装をおくべき。  
  
・リポジトリの実装  
・コレクション指向のリポジトリ  
すでにリポジトリに登録されている集約を変更しても保存し直す必要がない。  
そのためには裏側にある永続化メカニズムに、自身が管理する永続オブジェクトについて、その変更の履歴を  
暗黙のうちに追跡できる仕組みがなければならない。  
・永続指向のリポジトリ  
集約を変更した時にsave()のように明示的にコミットする必要がある。  
リポジトリのインターフェースは、その実装が永続指向になる前提で定義しておくべき。  
なぜなら永続指向→コレクション指向の差し替えは簡単だが、その逆はコレクション指向がトランザクション管理が前提にされていなかったせいで  
永続指向に切り替えたタイミングでトランザクション管理のための修正が必要になるからである。  
ドメインモデルの中で抽象化し、クラス階層ができると  
・何がダメになるのか？  
クライアントが実装クラスを知り、選択しなければならなくなる。  
・どうすれば良いのか？  
抽象化を行わず、標準型（区分オブジェクト）を使って、モデルのタイプによりif文で処理を分ける。  
ifがややこしくなってきたら、区分オブジェクトに振る舞いを持たせる。参考 https://www.slideshare.net/masuda220/ss-57352072  
標準型が合わない場合、ロールベースのインターフェースを使うこともできる。（実践ドメイン駆動設計を参照）  
ロールごとにインターフェースを用意し、その全てを実装したエンティティを、リポジトリから特定ロールを指定して取得し、そのロール型に格納する。  
あとはロールインターフェースのメソッドを実行する。  
リポジトリはアプリケーションサービスかドメインサービスにしか持たないこと。  
ある集約が別の集約のリポジトリを持ったりすると、どこで集約が取り出し、保存されたかわからなくなる。  
集約上のメソッドが別の集約のファクトリメソッドになっている場合、作成された別集約を保存するためにはその集約を一度呼び出し元に返却して、  
リポジトリに保存する。  
  
・実際にファクトリにはどのパターンが使われている？  
Collaboratorの場合、抽象クラスであるCollaboratorクラスに対して  
CollaboratorService(ドメインサービス、抽象クラス)を用意し各Collaborator実装クラスを生成しているので、ファクトリーパターンである。  
  
・CQRSとは？  
https://qiita.com/ledmonster/items/22b00c65208dffeff7e4  
メリットは、実装がわかりやすいこと。  
参照のために集約を構成する必要がなく。パフォーマンスが良いこと。  
コマンドモデルストアと、クエリモデルストアを必ず分ける必要はないと考える。  
単純にアプリケーション層のサービスクラスを参照系と更新系で分けるだけでも効果はある。  
  
・RabbitMQとは？   
https://qiita.com/gambaray/items/3cc02b419c860a96bc94  
AMQPについて http://labs.gree.jp/blog/2010/06/262/  
ExchangeListener  
ExchangePublisher  
  
  
・イベント駆動アーキテクチャとは？  
ドメインイベントを用いたアーキテクチャを指す。  
  
・イベントソージングとは？   
https://www.slideshare.net/shuheifujita90/ss-14294169  
  
・ドメイン駆動設計において、Batch、WebAPI、UIアプリはどういったパッケージ構成になるのか、commonの概念はどうなるのか  
特に決まりはない。commonはDDDにおいては共有カーネルと呼ばれる。  
  
・ファブリックとは？  
イベント駆動アーキテクチャで利用出来る、イベントストアの一種。  
マルチノードキャッシュとレプリケーション機能を提供するインメモリデータベースのことを指す。  
インメモリデータグリッドとも呼ばれ、分散同期処理をサポートする。  
製品としてはGemFireが挙げられる。  
キャッシュレベルおよびエントリレベルでのイベントの発生を自動的に通知する仕組み  
  
・CQRSの実装はどうなってる？  
更新系メソッドの戻り値はvoidとし、参照系メソッドを用意する。  
それぞれコマンド、クエリと呼ばれる。  
集約にはコマンドメソッドしかない。  
CQRSにおけるリポジトリにはいくつかのコマンドメソッドと、一つのクエリメソッド（集約の識別子から該当集約を取得）がある。  
CQRSにおけるリポジトリはクエリメソッド以外（別のプロパティによる絞り込みなど）で集約を取得してはいけない。  
このパターンの登場人物と流れは、  
・更新系の場合  
クライアント  
↓更新  
コマンドプロセッサ（アプリケーションサービス）  
↓呼び出し  
コマンドモデル（集約）  
↓更新・保存、クエリモデル（ドメインイベントとして）発行  
コマンドモデルストア  
↓  
イベントサブスクライバ  
↓クエリモデル保存  
クエリモデルストア（ビュー）  
・参照系の場合  
クライアント  
↓参照  
クエリプロセッサ（アプリケーションサービス）  
↓参照  
クエリモデルストア（ビュー）  
となる。  
クエリモデルストアのビューは、ユーザーインターフェースの表示形式毎に用意し、全行・全カラムを読み込んで利用する。  
あまりにもビューが増えすぎる場合はある程度まとめたビューにして、クエリのWHERE句で調整する。  
コマンドプロセッサは可能であれば1コマンド1クラス（専用方式）にすべき。  
対して1コマンドを1メソッドと捉え、1クラスにまとめる方式（分類方式）もある。  
専用方式コマンドプロセッサをイベントストアに格納しておき、非同期で検知クライアントシステム側で実行する方式（メッセージング方式）もある。  
コマンドモデルとクエリモデルの格納は同じトランザクションで行うこと。ストアが異なる場合でもグローバルトランザクションを利用すること。  
  
・エンティティ、値オブジェクトにインターフェースは必要か？  
エンティティ同士の比較がエンティティの識別子で行われるようにequalsとhashcodeをオーバーライドするため必要があり、  
識別子の取得やクローン取得処理なども実装されるべきなのでインターフェースを用意すべき。  
値オブジェクトについても、equalsは全プロパティが同じならtrueを返すようにしないといけないが、そこはLombokのアノテーションの方がシンプルで良い。  
  
・CQRS的に、リポジトリの実装は更新系と参照系の両方のメソッドを持って良い？  
リポジトリの存在意義はドメインモデルをメモリ上にあるかのように見せることなので、ここにCQRSは適用しないほうが混乱しない。  
  
・port&adapter層のパッケージの切り方  
明確な答えはなさそう。まずは目的で切って後は任意とする。/目的/{目的}/…/方法/詳細が良いと考える。  
目的…web(http)の実装、モデルの永続化と取り出し、メッセージングのやりとり、通知、イベント通知、腐敗防止層(ドメインサービスの実装)  
方法…VIEW、API、DB、ファイル、メモリ、MQ、KVS  
詳細…LevelDB、RabbitMQ、Redis  
詳細は、方法(DB・MQ・KVS等)の実装の種類ごとにクラスが必要な場合（専用パッケージが必要だったりドライバーを共有できないなど）に用いる。  
例）  
web/view  
web/api  
persistence/db  
persistence/file  
persistence/eventsourcing/db  
persistence/eventsourcing/db  
messaging/mq  
notification/mq  
event/db  
event/kvs  
domainservice/  
eventとeventsourcingの違いは、eventは永続化目的でないこと。だからpersistence配下のパッケージではない。  
  
・リポジトリ実装の選択タイミングは？  
アプリケーション初期化時。  
springの機能で、config等でDI対象の実装を選択する。  
  
・実装したいところ  
別コンテキストとのREST連携  
CQRSの実装(アプリケーションサービスクラスの分け）  
CQRSの実装(イベント駆動によるクエリーモデルの作成）  
イベント駆動(パブリッシャー・サブスクライバ連携)によるイベントストア格納  
別コンテキストのイベントストア検知クライアント  
腐敗防止層の実装  
区分オブジェクトによるポリモーフィズムの実現  
施策の優先度の実装  
コンフィグファイルによる複数実装のDI切り替え  
自前のではなくSpringBootのバリデーション機能を使う  
  
・実装してみた所感  
CQRSはアプリケーション層の中でcommandとqueryでパッケージを分けた。  
commandの方は専用コマンド方式でクラスを作って、queryは分類方式とするとわかりやすかった。  
クエリーモデルをドメイン層に配置する実装もネットにあったが、IDDD書籍ではクエリーモデルはデータモデルと断言しており  
ドメインモデルではないのでやめた。  
アプリケーション層のqueryパッケージには〜Serviceという抽象クラスを追加して、その実装はport&adapter層においた。  
こうすることでヘキサゴナルアーキテクチャにおいてcommandと比較すると、単純にdomain層をスキップした形になってスッキリする。  
  
  
  
・そもそも腐敗防止層の目的って？  
上流モジュールと下流モジュールの関係が顧客/提供者の場合、下流モジュールは上流モジュールのインターフェース(提供してくるデータ)でモデルに変換する変換層を持つ。  
上流モジュールが、下流モジュールの言うことを全く聞いてくれない場合（関係が順応者）に、  
下流モジュール側は変換層が必要とするインターフェースを用意し、上流モジュールのインターフェース(提供してくるデータ)をそれに合わせる腐敗防止層を持つ。  
  
・spring bootでドメイン駆動設計を実現する  
  
  
・イベントストアフラッシュのタイミングは？  
  
  
・サービス指向って具体的にどんな実装？  
  
  
・なぜエンティティを使う？  
データに着目したCRUDシステム  
  
  
・エンティティの識別子の生成タイミング  
早期生成…エンティティ生成時に識別子を割り当てる  
遅延生成…エンティティ永続化時に識別子を割り当てる  
早期生成ではUUIDや、oracleのシーケンス機能が使える（MySQLならそれを模した物を作る）  
遅延生成はAutoIncrementが使える  
  
・境界づけられたコンテキスト間の結合方法にデータベースを介する場合はあるのか？  
共有データベースがあっても良いが、それだけでコンテキスト間の結合度が高まってしまう。  
そのため共有DBがダウンしたり運用ミスがあったりすると両方のコンテキストが使えなくなる。  
また概念的にも、同じレコードが両コンテキストで別々のモデルになるので、混乱を招く。  
少なくともDBのインスタンスを分けるべきだし、コストが厳しければスキーマを分ける。  
正しい形は、片方のコンテキストが公開ホストになりRESTfullなAPIでアクセスしてデータをもらうか、  
メッセージングを使うの2択。  
  
・コンテキスト間の結合の基本  
情報のやり取りの仕方は2種類  
・プログラミング言語のシリアライズ  
これは関係するシステムが同じシリアライズ機能に対応していることが前提。  
結合するコンテキスト間で同じクラス・インターフェース定義を保持する必要があるため二重管理となり変更に弱い。  
・標準化された中間フォーマットの利用  
JSONやXMLを利用してデータを共有する。通信するデータ量が増え、オブジェクトに変換するコストが高い。  
また強い型付けによる安全性を優先して、結局のところ結合するコンテキスト間で同じクラス・インターフェースを保持する場合もある。  
共有カーネルを用いてコンテキスト間でソースコードを共有することで二重管理を避けることもできるが、変更管理が複雑になる。  
結局どの方法が良いか？  
標準化された中間フォーマットで、型を共有しない方法が最良。  
コンテキスト間でドメインモデルを共有するという考え方は間違っている。各コンテキストで最良のドメインモデルがあるべき。  
そのため中間フォーマットでやり取りするのはデータだけで、別コンテキストのモデルの振る舞いを使おうとするべきではない。  
何よりデータのみのやり取りの方が疎結合である。  
データからモデルへの変換はport&adapter層で行う。  
  
・RESTfullなAPIはどのように設計する？  
クライアント側は可能な限り自立できるように、APIサーバー側にアクセスできなくても障害とならないように設計する。  
  
・メッセージングはどのように設計する？  
通知するイベントに発生時刻を持たせて、順番を維持すること。  
  
・RESTfullAPIとメッセージングはどっちが良い？  
RESTは多数のコンシューマーが単一のプロデューサーの発行するイベントに関心がある（Observerパターン）時に利用し、  
その逆の場合で、コンシューマー側が複数のプロデューサーから所定の手順でリソースを取得しないとタスクを実行できない場合は、メッセージングを利用する。  
RESTはコンシューマーのことを考慮しないので、RESTが返却するデータはプロデューサー側の都合で変わっていく。  
そのためコンシューマーが必要とするデータが取得できない可能性がある。  
コンシューマー側がデータの消失を恐れ、処理手順を大事にしているならば、そのコンシューマー向けにデータを用意しメッセージングを利用すべきだ。  
逆にRESTは多数のコンシューマー向けの汎用的なデータを提供する。  
  
・なぜメッセージングはイベントストアをポーリングする？イベントストアを介さずにメッセージキューにパブリッシュしても良い？  
イベントストアがない場合、キューイングに失敗した時にイベントが消失してしまうためコンテキストの自立性が低下してしまう。  
  
・連携のデータ量が多い場合はどうする？  
共有DBでデータを共有する？でも共有DBが落ちた時、連携している二つのコンテキストでリカバリ作業が必要になる。  
キューでデータを連携する？でもキューのサイズに限度がある。  
ファイル連携？  
  
・別コンテキストに毎回RESTでアクセスすると時間がかかるが、どうすれば良い？  
非同期でコンテキスト内にデータを持ってくる。重複管理となるがトレードOFF。  
  
・識別子以外のプロパティで検索する場合、リポジトリを使わないならどうするのか？  
クエリモデルから直接SQLでデータを取得し、集約(コマンドモデル)を作る  
  
・長期プロセスとは？  
イベント駆動で分散システムで並列処理を行うパターン。サーガとも呼ばれる。  
イベントを発行すると、複数の別コンテキストのイベント検知クライアントが並行に処理し、その結果をイベント発行元のコンテキストに返却する。  
イベント発行元コンテキストは並行処理の結果を突き合わせて、結果を保存する。  
  
・集約について  
集約の目的…不変条件を満たすこと。  
不変条件は「トランザクション整合性」か「結果整合性」の2種類。  
「トランザクション整合性」… 一つのトランザクションで保持される不変条件。  
「結果整合性」… 遅延するが保持される不変条件。  
基本的に一つのトランザクションでは、一つの集約しか変更できない。（※目標にすべきルール）  
ここで守られる不変条件はトランザクション整合性のことである。またこれを満たすために一つの大きな集約が作られがちである。  
しかし大きな集約はパフォーマンスに影響が出るため、ドメインイベントを用いた結果整合性で「小さな集約」にすることを検討すべき。  
小さな集約を設計していくと複数の集約の依存関係を解決する必要が出てくる。  
集約の依存関係の解決方法は2つある。  
「切り離されたドメインモデル」… 集約が内部でリポジトリやドメインサービスを利用して全ての依存関係を解決するテクニック  
「アプリケーションサービスによる解決」… アプリケーションサービスが集約のメソッドを実行する前に依存オブジェクトを検索し、引数に渡して解決するテクニック。  
「切り離されたドメインモデル」では集約の振る舞いに自由度が増して複雑になりやすく、意図せず複数の集約を変更してしまう。  
「アプリケーションサービスによる解決」では上記を予防できるが、依存関係の解決が複雑でドメインに特化している場合がある。  
その時は集約のメソッド引数にドメインサービスを渡し、ダブルディスパッチする。  
  
・ドメインサービスの役目は？  
集約のメソッドを実行するための依存関係の解決が複雑な場合にその責務を負う。（ダブルディスパッチ）  
複数種類の集約を連携させた結果を知りたいときに、そのメソッドがどの集約にも持たせるべきではない場合にその責務を負う。  
ある集約の複数形の処理がアプリケーション層で管理するには複雑な場合で、その処理メソッドを該当集約に持たせるべきではない場合にその責務を負う。  
ドメインオブジェクトをインフラストラクチャ層を経由して生成する責務を負う。  
※基本的に一つの処理で更新される集約は一つなので、ドメインサービスで集約の永続化は行わず、永続化は最終的な結果を受け取ったアプリケーションサービスで行う。  
  
・そもそもドメインとは？  
ドメイン（広義）=  組織が行う事業や、それを取り巻く世界。  
事業が市場（顧客）の定義し、プロダクトやサービスを販売する。  
様々な業務により事業は成り立つ。業務にはノウハウと物事の進め方がある。  
「どこかの組織のためのソフトウェアを作る = その組織のドメイン（事業を取り巻く世界）で作業する」  
  
・サブドメインとは？  
ドメイン（組織が行う事業）を成り立たせる、一つの業務を指す。  
業務は「〇〇を〜〜する」と表現でき、〇〇がサブドメインとして取り上げられる。  
  
・なんで戦略的設計が大事？  
サブドメインがハッキリすることで、システムが大きな泥団子にならない。  
コアドメインなのか、他のサブドメインから利用される汎用ドメインとなるかハッキリさせることができる。  
  
・ドメインモデリング  
アナリシスパターン  
「知識レベル」と「操作レベル」に分ける  

ドメインモデル内のバリデーションは  
・個別の属性/プロパティ  
・オブジェクト全体(集約)  
・オブジェクト(集約)同士の合成  
の3つの視点がある。  
  
属性やプロパティ(値オブジェクト)のバリデーション方法  
→自己カプセル化  
  
オブジェクト全体(集約)のバリデーション方法  
→仕様クラス  
  
オブジェクト(集約)同士の合成  
→ドメインサービスで複数の集約のバリデーション結果を取りまとめる。  
バリデーション方法は仕様クラスを用いる。  
  
  
値オブジェクト...   
ドメイン内の何かを計測したり定量化したり、あるいは説明したりする。  
例）年齢はその人が生まれてから何年経ったかを計測して定量化したもの。  
例）名前はその人がなんと呼ばれているのか説明したもの。  
値オブジェクトは一つあるいは複数の属性を保持している。それらが関連することで値について説明している。  
他と切り離した属性単体では意味のある内容が得られない。  
  
属性とプロパティの違い...   
親オブジェクトからの値オブジェクトへの参照は単なる属性などではない。  
これは親オブジェクトのプロパティでありモデル内のあるモノへの参照を保持しているものだ。  
  
仕様クラス...   
集約のルートにはドメインの振る舞いを扱う責務があるため、  
いくら集約の境界を参照できるとはいえバリデーションの責務を持たせると責務が増えすぎてしまう。  
そのため集約が仕様を満たしているかチェックする仕様クラスを用意し、集約のルートにvalidate()メソッドでそれを利用しチェックさせる。  
これを仕様パターンという。  


# オブジェクト生成の約束
・コンストラクタの中で別のコンストラクタを呼んではいけない（コンストラクタは単純でなければならない）
理由：クライアントが予期しないオブジェクト生成が含まれ、混乱やバグを招く。

・オブジェクトの生成は単純であればコンストラクタ、複雑ならば別オブジェクトで行う。
理由：集約の責務はビジネスロジックを実行することであり、オブジェクト生成はそこに含まれない。

# まずはコンストラクタで生成して良いか考える。
抽象クラスを継承/実装したクラスではなく（レイヤスーパータイプは除く）、
オブジェクトの持つ属性を全てクライアントが取得できる（コンストラクタ内でオブジェクト生成が行われる心配がない）

# ファクトリメソッドで生成できないか考える。
・既存の集約に要素を新たに追加する場合は、集約ルートにその要素のファクトリメソッドを用意しても良い。
理由：要素追加時に集約の整合性を保証する責務を集約ルートに閉じることができる。

・他のオブジェクトの生成に密接に関わるオブジェクト(別集約ルート)にファクトリメソッドを用意しても良い。
理由：あるオブジェクトの持つデータやルールが、別のオブジェクトを生成する上で非常に支配的である場合に有効である。
注意：そのオブジェクトが生成物を所有するわけではない。

# ファクトリやサービスを作る。
ここまでくると、生成が複雑であるにも関わらずファクトリメソッドの自然な置き場所がないことになる。
そこで専用のファクトリクラスかドメインサービスクラスを作成する。

・専用のファクトリで集約全体を作成する。（エンティティファクトリ）
専用のファクトリは集約全体を生成してルートへの参照を渡し、生成された集約の不変条件が必ず強制されることを保証する。
不変条件によって求められないのであれば、生成時は本質的な属性だけを受け取り、詳細は後から追加しても良い。

・専用のファクトリで集約の内部にあるオブジェクトを生成する。（値オブジェクトファクトリ）
あくまで集約の内部のオブジェクトであるので、集約外部のオブジェクトから利用は一時的なもの（集約のプロパティにセットしたりしない）に留めること。

おまけ
# ファクトリで再構成を行う場合の注意点
ファクトリは新規生成だけでなく再構成も行う。
・追跡IDは絶対に新規採番ではないのでパラメーターで受け取ること。
・新規作成とは違い、不変条件を満たさないときに単に例外を投げるだけではうまくいかないことが多く柔軟な対応が必要。


集約は意味ある単位で区切る（不変条件を満たすため）
二つの集約を一つにまとめることもできる。
一つにまとめてもルート経由の操作は守られるので問題ない。
しかし大きな集約は扱いずらい。
小さく分けて参照した方が良い。（集約Aと集約B）
パッケージを分けるかどうかは好み
集約Aが集約Bを参照している場合、集約Aのパッケージのサブパッケージに集約Bを配置しても良い。
どちらにせよ、集約が二つあることに変わりはない。
```  

メモ2
```
・一つのイベントストア（テーブル）に全種類のイベントを格納する？  
→YES イベント毎にテーブルを分ける理由がない。  
  
・イベントの通知トラッカーの仕組み  
トラッカーは、どのチャネル（エクスチェンジ）に対して、どのイベントIDまで送ったか（送信履歴）管理する。パブリッシャーから利用される。  
複数のチャネルにイベントを送りたいときは通知トラッカー用テーブルのレコードが一行増えて（違いは新しいチャネル名だけ）、  
それを元にトラッカーをインスタンス化してパブリッシャーに渡す。パブリッシャーはトラッカーのチャネル名と送信履歴を使って未送信のイベントを送信する。  
全種類のイベントでイベントIDを共有している場合、特定のイベントだけ通知できないのでは？  
→YES 特定のイベントだけを通知するということは、通知する側が、通知される側が欲しているイベントを知らなければならない。  
疎結合にするためには単純に全てのイベントを通知するか、全くしないかのどちらかになる。  
また、別コンテキスト向けにイベントを通知する、という考え方は間違っていて、単純にMQサーバーの複数チャネルにイベントを送信できる仕組みを  
備えるだけで良い。イベントを受信したいコンテキストは一つのチャネルに接続する。接続すればそのコンテキストの全てのイベントを受信できる。  
  
・集約の遅延読み込みとは  
ある集約Aは、別の集約Bとの関連を示すために、集約Bの識別子をもつ。  
「切り離されたドメインモデル」設計の場合は、集約Aの処理の中で集約Bのリポジトリに識別子を渡して集約Bを取得するし、  
「アプリケーションサービスによる解決」設計の場合は、ドメインサービスが集約Bのリポジトリに集約Aがもつ集約Bの識別子を渡して集約Bを取得する。  
集約Aが集約Bの識別子ではなく、集約Bそのものをプロパティとして持っている場合、（つまり集約Bを無くして全て集約Aとして扱う）  
そのプロパティのメソッドを利用する際にORMの遅延読み込み機能を使用して永続化層から読み込むことができる。これを遅延読み込みという。  
  
・ドメインモデルをユーザーインターフェース向けにレンダリングする方法  
・DTOパターン（データトランスファーオブジェクト）  
アプリケーションサービスがリポジトリを使って必要な集約を集めて、DTOアセンブラクラスに処理を委譲し、DTOアセンブラが  
集約のメソッド経由でDTOにレンダリングに必要な情報を集める。  
メリット：リポジトリから取得した集約を使うため遅延読み込みにも対応できる。  
デメリット：DTOはもともとプレゼンテーション層とビジネス層が物理的に切り離されていて、ビジネス層からネットワーク越しにプレゼンテーション層に  
データをシリアライズして送りたいがために考案されたパターンであり、ネットワークをかまさないのならばYAGNIである。  
また集約を設計するときにDTOアセンブラから必要とされるデータを提供できるようにしなければならない。  
集約に余計な責務を持たせてしまうし、プレゼンテーション層とビジネス層の結合度が高くなってしまう。  
・メディエイターパターン  
メディエイターインターフェースを目的の集約毎に用意し、そこには必要な集約の情報を収集するメソッドを定義する。  
集約に自身の内部状態を提供するメソッドを一つ用意し、引数にメディエイターインターフェースを受け取る。  
その中でメディエイターをダブルディスパッチして内部状態を提供して行く。（集約の細かい形状を伝えるのではなく属性・プロパティを渡すだけ）  
メリット：DTOパターンのデメリットだった集約がもつデータ提供に関する責務をメディエイターに移せる。（集約はprivateなプロパティをメディエイターに渡すだけ）  
デメリット：集約に自身の内部状態を提供するメソッドを一つ用意しなければならない。  
・DPOパターン（ドメインペイロードオブジェクト）  
必要な集約の参照をDPOに集めて、プレゼンテーション層ではDPOから集約の参照を要求する。その集約に対して表示対象の属性を要求する。  
メリット：DTOよりも設計が楽になる  
デメリット：結局のところDTOと同じで必要とされるデータを提供できるようにしなければならない。またDPO作成時には遅延読み込みが完了しておらず、  
プレゼンテーション層に渡す前にセッション（トランザクション）が終了してしまうと、プレゼンテーション層で遅延読み込みしようとしたときに例外が発生されてしまう。  
それを防ぐためにドメイン依存リゾルバを使う。これはストラテジパターンでDPO作成時に必要な遅延読み込みを完了させる。  
・集約の表現オブジェクトを使う  
複数集約をコンストラクタに受け取る表現オブジェクトを作る。コンストラクタで必要なデータを集約から受け取り、プリミティブ型のプロパティで持つ。  
メリット：  
デメリット：  
・ユースケース最適化リポジトリクエリを使う  
リポジトリにファインダーメソッドを用意して必要な集約を集めたカスタムオブジェクトを取得し、結果を値オブジェクトとして扱う。  
メリット：  
デメリット：  
・データトランスフォーマーを使う  
アプリケーションサービスのメソッドの引数にトランスフォーマーオブジェクトを渡す。  
メリット：  
デメリット：  
・プレゼンテーションモデルを使う  
メリット：ビューにロジックが一切含まれない。  
デメリット：  
・サービスの出力切り離し  
メリット：  
デメリット：  
  
・ユーザーインターフェースからアプリケーションサービスを呼ぶ方法  
ユースケース毎にコマンドオブジェクトを作ってアプリケーションサービスクラスのメソッドに渡す。  
  
・コマンドハンドラ  
上流コンテキストのイベントを受け取る場合、受け取るイベント毎にリスナークラスを作る。  
リスナークラスをタイマーキックする。  
イベントのデータからコマンドオブジェクトを作りサービスクラスに渡す。  
このリスナーをコマンドハンドラと呼ぶ。  
  
・ファクトリー周りを詳しく  
  
  
・アプリケーションファサード  
  
・DDDにおけるテスト  
  
・アダプターパターンについてもう一度考える  
ポート＆アダプター層に設けるアダプターの目的は？  
httpリクエストを例にする。  
ポートを通ってきたhttpリクエストを処理する仕組みは、WEBコンテナが用意している。  
例えばtomcatならばweb.xmlに定義しているマッピングに従いServletクラスのメソッドを実行する。  
このインターフェースに従って、実行されるServletクラスのメソッドに、アプリケーションの処理を書けばアプリケーションは動く。  
しかし、このServletクラスは単一責任の原則に違反している。  
Servletクラスは本来、「WEBコンテナからリクエストに従って起動されること」が責務であって、この起動方法が仕様変更で変わることは十分考えられる。  
それに加えてServletクラスに「アプリケーションの処理」の責務を持たせてしまっている。  
これを回避するためにAdapterを用いる。ServletクラスをAdapterと捉えて、WEBコンテナから起動された後、処理をアプリケーション処理を行うクラスに処理を委譲する。  
つまりはヘキサゴナルアーキテクチャにおけるポート&アダプター層のクラスの役割は、アプリケーション層のクラスが余計な責務（インフラの仕組みに準拠する）  
を持つことを防ぐAdapterとなることである。  
```

```
・コマンドオブジェクトとDTO
コマンドオブジェクトは、クラインアントからコマンドを受け取ってアプリケーションが動く設計で用いる。
ユーザーインターフェース層でリクエストをコマンドオブジェクトで受け取る。
コマンドオブジェクトはDTOよりも明示的な名前をつけることができる点で有利である。
もちろんDTOと同じようにシリアライズできるため外部システム（MQなど）に連携できる。
一つのコマンドオブジェクトに対応するコマンドバリデーターを用意しても良いし、コマンドにバリデーションチェックメソッドを持たせても良い。

・表現モデルとDTO
表現モデルは、ドメインモデルを変換してクライアントへ返却する設計で用いる。
ファウラーのプレゼンテーションモデルパターンとなる。
表現モデルは必要な集約をコンストラクタで受け取り、クライアントが求める形式となる。

・値オブジェクトと契約による設計
契約による設計では、メソッドは事前条件を明示し、メソッド利用者はそれを満たす必要がある。
値オブジェクトを用いるとそれを推進できる。
メソッドは引数として値オブジェクトを必要とするため、メソッド利用者は値オブジェクトを作成しなければならない。
値オブジェクトは完全コストラクタで設計されているため作成された時点で正しいことが保証される。
つまり「メソッド利用者がメソッドを利用する＝正しい引数（値オブジェクト）を渡した」という構図になり、事前条件を満たしたことになる。
```

```
・集約とコンポジションの違い
コンポジション... 寿命が同じ
集約... 寿命が違う

コンポジション（要は値オブジェクトの塊）は、塊全体として生まれるし、消される。つまりコンポジションを構成する一部に変更が加わることはない。
集約は、それを構成する一部に変更を加えることができる。
```








# サンプルコードを実行する
### Docker環境を準備  
省略  
  
### java7をインストール  
古いバージョンなので以下からインストーラーをダウンロード  
http://www.oracle.com/technetwork/java/archive-139210.html  
  
環境変数JAVA_HOMEを切り替え  
export JAVA_HOME='/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/'  
  
### 環境構築  
```  
[localhost private_projects]$ git clone https://github.com/VaughnVernon/IDDD_Samples.git  
[localhost private_projects]$ cd IDDD_Samples/  
[localhost IDDD_Samples]$ ./startContainers.sh start  
Starting MySQL Server container...  
Error: No such container: iddd-mysql  
d7d9359aecdc0c9acabe00905da8d0c9bdffaf6d72bda2f04e3f8fda3f498017  
Waiting for MySQL Server to be up and running...  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_common/src/main/mysql/test_common.sql]  
mysql: [Warning] Using a password on the command line interface can be insecure.  
ERROR 2013 (HY000): Lost connection to MySQL server at 'reading initial communication packet', system error: 0  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_common/src/main/mysql/common.sql]  
mysql: [Warning] Using a password on the command line interface can be insecure.  
ERROR 2013 (HY000): Lost connection to MySQL server at 'reading initial communication packet', system error: 0  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_identityaccess/src/main/mysql/iam.sql]  
mysql: [Warning] Using a password on the command line interface can be insecure.  
ERROR 2013 (HY000): Lost connection to MySQL server at 'reading initial communication packet', system error: 0  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_collaboration/src/main/mysql/collaboration.sql]  
mysql: [Warning] Using a password on the command line interface can be insecure.  
ERROR 2013 (HY000): Lost connection to MySQL server at 'reading initial communication packet', system error: 0  
Starting RabbitMQ container...  
Error: No such container: iddd-rabbitmq  
Unable to find image 'rabbitmq:3-management' locally  
3-management: Pulling from library/rabbitmq  
be8881be8156: Already exists   
ab96a756674d: Pull complete   
1afa3c8b1ac8: Pull complete   
8d6ac301ca22: Pull complete   
665d14f5b3ec: Pull complete   
c8c7fea479bc: Pull complete   
1f57b98898fc: Pull complete   
c57de6ff1fda: Pull complete   
eb20b6079db3: Pull complete   
bfcd2c7011de: Pull complete   
71a3874699ee: Pull complete   
5b914bcc4a84: Pull complete   
f63e1b988a2d: Pull complete   
e39cb8f0eaed: Pull complete   
Digest: sha256:0b36ea1a8df9e53228aaeee277680de2cc97c7d675bc2d5dbe1cc9e3836a9d9f  
Status: Downloaded newer image for rabbitmq:3-management  
0e8e82e05a1e5e0f4ccf900f4a622b7995d488539b8740601e0e7ece7a0560ff  
Waiting for RabbitMQ to be up and running...  
  
RabbitMQ Management available at [http://localhost:8080]  
(Login with user/pass of [guest/guest])  
[localhost IDDD_Samples]$ docker ps  
CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS              PORTS                                                                                       NAMES  
0e8e82e05a1e        rabbitmq:3-management   "docker-entrypoint.s…"   22 seconds ago      Up 21 seconds       4369/tcp, 5671/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:5672->5672/tcp, 0.0.0.0:8080->15672/tcp   iddd-rabbitmq  
d7d9359aecdc        mysql                   "docker-entrypoint.s…"   46 seconds ago      Up 45 seconds       0.0.0.0:3306->3306/tcp                                                                      iddd-mysql  
[localhost IDDD_Samples]$   
```  
コンテナは立ち上がっているけど、mysqlの初期化に失敗した模様。mysqlサーバーの起動に時間がかかったか？  
手動で初期化する。  
```  
[localhost IDDD_Samples]$ testSqlFiles="$(find $(pwd) -name *.sql | grep -i "test")"  
[localhost IDDD_Samples]$ sqlFiles="$(find $(pwd) -name *.sql | grep -vi "test")"  
[localhost IDDD_Samples]$  for sql in ${testSqlFiles}; do  
echo "Importing [${sql}]"  
MYSQL_PWD="root" mysql --host="0.0.0.0"  --port=3306 --protocol=TCP --user="root" < ${sql}  
done  
  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_common/src/main/mysql/test_common.sql]  
[localhost IDDD_Samples]$ for sql in ${sqlFiles}; do  
echo "Importing [${sql}]"  
MYSQL_PWD="root" mysql --host="0.0.0.0"  --port=3306 --protocol=TCP --user="root" < ${sql}  
done  
  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_common/src/main/mysql/common.sql]  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_identityaccess/src/main/mysql/iam.sql]  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_collaboration/src/main/mysql/collaboration.sql]  
ERROR 1074 (42000) at line 11: Column length too big for column 'event_body' (max = 16383); use BLOB or TEXT instead  
[localhost IDDD_Samples]$   
```  
collaboration.sqlの実行でエラーになった。定義するカラムサイズが大きすぎたので変更。  
```  
[localhost IDDD_Samples]$ git diff iddd_collaboration/src/main/mysql/collaboration.sql  
diff --git a/iddd_collaboration/src/main/mysql/collaboration.sql b/iddd_collaboration/src/main/mysql/collaboration.sql  
index d996321..9f87b00 100644  
--- a/iddd_collaboration/src/main/mysql/collaboration.sql  
+++ b/iddd_collaboration/src/main/mysql/collaboration.sql  
@@ -10,7 +10,7 @@ CREATE TABLE `tbl_dispatcher_last_event` (  
   
 CREATE TABLE `tbl_es_event_store` (  
     `event_id` bigint(20) NOT NULL auto_increment,  
-    `event_body` varchar(65000) NOT NULL,  
+    `event_body` varchar(6500) NOT NULL,  
     `event_type` varchar(250) NOT NULL,  
     `stream_name` varchar(250) NOT NULL,  
     `stream_version` int(11) NOT NULL,  
@@ -123,7 +123,7 @@ CREATE TABLE `tbl_vw_post` (  
     `author_email_address` varchar(100) NOT NULL,  
     `author_identity` varchar(50) NOT NULL,  
     `author_name` varchar(200) NOT NULL,  
-    `body_text` varchar(64000) NOT NULL,  
+    `body_text` varchar(6400) NOT NULL,  
     `changed_on` datetime NOT NULL,  
     `created_on` datetime NOT NULL,  
     `discussion_id` varchar(36) NOT NULL,  
[localhost IDDD_Samples]$   
```  
再実行。  
```  
[localhost IDDD_Samples]$ for sql in ${sqlFiles}; do  
echo "Importing [${sql}]"  
MYSQL_PWD="root" mysql --host="0.0.0.0"  --port=3306 --protocol=TCP --user="root" < ${sql}  
done  
  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_common/src/main/mysql/common.sql]  
ERROR 1050 (42S01) at line 12: Table 'tbl_es_event_store' already exists  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_identityaccess/src/main/mysql/iam.sql]  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_collaboration/src/main/mysql/collaboration.sql]  
[localhost IDDD_Samples]$   
```  
テーブルが既に存在するエラーが出てるが無視。これで初期化完了。  
  
### ソフトウェアをビルド  
`./gradlew build`実行。テストでエラーになった。  
```  
省略...  
  
com.saasovation.collaboration.domain.model.collaborator.CollaboratorServiceTest > testCollaboratorTranslator FAILED  
    org.springframework.beans.factory.BeanCreationException at CollaboratorServiceTest.java:99  
        Caused by: org.springframework.beans.BeanInstantiationException at CollaboratorServiceTest.java:99  
            Caused by: java.lang.IllegalStateException at CollaboratorServiceTest.java:99  
                Caused by: java.lang.IllegalStateException at CollaboratorServiceTest.java:99  
                    Caused by: org.apache.commons.dbcp.SQLNestedException at CollaboratorServiceTest.java:99  
                        Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException at CollaboratorServiceTest.java:99  
  
70 tests completed, 70 failed  
:iddd_collaboration:test FAILED  
  
FAILURE: Build failed with an exception.  
  
* What went wrong:  
Execution failed for task ':iddd_collaboration:test'.  
> There were failing tests. See the report at: file:///Users/sacnakag/private_projects/IDDD_Samples/iddd_collaboration/build/reports/tests/index.html  
  
* Try:  
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.  
  
BUILD FAILED  
  
Total time: 1 mins 31.028 secs  
```  
mysql関連のエラーのようなので、ログを確認する。  
詳細ログを出力するため設定ファイルを用意し、コンテナ起動スクリプトを以下のように変更。  
```  
[localhost IDDD_Samples]$ cat /tmp/mymysql/custom.cnf   
[mysqld]  
general_log=1  
[localhost IDDD_Samples]$   
[localhost IDDD_Samples]$ git diff startContainers.sh  
diff --git a/startContainers.sh b/startContainers.sh  
index c2bcc34..c707c69 100755  
--- a/startContainers.sh  
+++ b/startContainers.sh  
@@ -17,7 +17,7 @@ containers[1]="${rabbitmqContainerName}"  
 function start() {  
     echo "Starting MySQL Server container..."  
     docker rm -f "${mysqlContainerName}"  
-    docker run --name "${mysqlContainerName}" -p "${mysqlPort}":3306 -e MYSQL_ROOT_PASSWORD="${mysqlPassword}" -d mysql  
+    docker run -v /tmp/mymysql/:/etc/mysql/conf.d --name "${mysqlContainerName}" -p "${mysqlPort}":3306 -e MYSQL_ROOT_PASSWORD="${mysqlPassword}" -d mysql  
   
     echo "Waiting for MySQL Server to be up and running..."  
     waitForContainer "${mysqlContainerName}" "mysqld: ready for connections."  
[localhost IDDD_Samples]$   
```  
再度環境構築するためコンテナとイメージを全て削除。  
```  
[localhost IDDD_Samples]$ docker stop $(docker ps -aq)  
[localhost IDDD_Samples]$ docker rm $(docker ps -aq)  
[localhost IDDD_Samples]$ docker rmi $(docker images -aq)  
```  
環境構築手順を実施して、ビルド実行。  
mysqlコンテナにログインし、詳細ログを確認してみるとテストエラー時に以下が出力された。  
```  
root@26fbfc2915de:/# tail -f /var/lib/mysql/26fbfc2915de.log  
...省略...   
  
2018-08-26T13:15:27.302624Z	   12 Connect	Client does not support authentication protocol requested by server; consider upgrading MySQL client  
2018-08-26T13:15:27.302687Z	   12 Connect	root@172.17.0.1 on iddd_collaboration using TCP/IP  
  
...省略...  
```  
どうやら以下の問題のよう。  
https://dev.mysql.com/doc/refman/5.6/ja/old-client.html  
試しにmysqlサーバーのバージョンを5.7に指定した。（バージョンを下げた）  
```  
[localhost IDDD_Samples]$ git diff startContainers.sh  
diff --git a/startContainers.sh b/startContainers.sh  
index c2bcc34..f1a3a5a 100755  
--- a/startContainers.sh  
+++ b/startContainers.sh  
@@ -17,7 +17,7 @@ containers[1]="${rabbitmqContainerName}"  
 function start() {  
     echo "Starting MySQL Server container..."  
     docker rm -f "${mysqlContainerName}"  
-    docker run --name "${mysqlContainerName}" -p "${mysqlPort}":3306 -e MYSQL_ROOT_PASSWORD="${mysqlPassword}" -d mysql  
+    docker run -v /tmp/mymysql/:/etc/mysql/conf.d --name "${mysqlContainerName}" -p "${mysqlPort}":3306 -e MYSQL_ROOT_PASSWORD="${mysqlPassword}" -d mysql:5.7  
   
     echo "Waiting for MySQL Server to be up and running..."  
     waitForContainer "${mysqlContainerName}" "mysqld: ready for connections."  
[localhost IDDD_Samples]$   
```  
再度環境構築を行うとビルドが成功した。  
```  
[localhost IDDD_Samples]$ ./gradlew build  
:compileJava UP-TO-DATE  
:processResources UP-TO-DATE  
:classes UP-TO-DATE  
:jar UP-TO-DATE  
:assemble UP-TO-DATE  
:compileTestJava UP-TO-DATE  
:processTestResources UP-TO-DATE  
:testClasses UP-TO-DATE  
:test UP-TO-DATE  
:check UP-TO-DATE  
:build UP-TO-DATE  
:iddd_common:compileJava UP-TO-DATE  
:iddd_common:processResources UP-TO-DATE  
:iddd_common:classes UP-TO-DATE  
:iddd_common:jar UP-TO-DATE  
:iddd_agilepm:compileJava UP-TO-DATE  
:iddd_agilepm:processResources UP-TO-DATE  
:iddd_agilepm:classes UP-TO-DATE  
:iddd_agilepm:jar UP-TO-DATE  
:iddd_agilepm:assemble UP-TO-DATE  
:iddd_common:compileTestJava  
:iddd_common:processTestResources UP-TO-DATE  
:iddd_common:testClasses  
:iddd_agilepm:compileTestJava UP-TO-DATE  
:iddd_agilepm:processTestResources UP-TO-DATE  
:iddd_agilepm:testClasses UP-TO-DATE  
:iddd_agilepm:test  
:iddd_agilepm:check  
:iddd_agilepm:build  
:iddd_collaboration:compileJava UP-TO-DATE  
:iddd_collaboration:processResources UP-TO-DATE  
:iddd_collaboration:classes UP-TO-DATE  
:iddd_collaboration:jar UP-TO-DATE  
:iddd_collaboration:assemble UP-TO-DATE  
:iddd_collaboration:compileTestJava  
:iddd_collaboration:processTestResources UP-TO-DATE  
:iddd_collaboration:testClasses  
:iddd_collaboration:test  
:iddd_collaboration:check  
:iddd_collaboration:build  
:iddd_common:assemble UP-TO-DATE  
:iddd_common:test  
:iddd_common:check  
:iddd_common:build  
:iddd_identityaccess:compileJava  
:iddd_identityaccess:processResources  
:iddd_identityaccess:classes  
:iddd_identityaccess:jar  
:iddd_identityaccess:assemble  
:iddd_identityaccess:compileTestJava  
:iddd_identityaccess:processTestResources  
:iddd_identityaccess:testClasses  
:iddd_identityaccess:test  
:iddd_identityaccess:check  
:iddd_identityaccess:build  
  
BUILD SUCCESSFUL  
  
Total time: 2 mins 51.353 secs  
[localhost IDDD_Samples]$   
```  
ここまで色々と確認している間にコネクション数が上限に達して接続できなくなったので、そうならないように以下を設定しておく。  
```  
MYSQL_PWD="root" mysql --host="0.0.0.0"  --port=3306 --protocol=TCP --user="root" -e "SET GLOBAL max_connect_errors=99999;"  
```  
  
# サンプルを動かす  
サンプルはJava EEのWebサービス仕様であるJAX-RSを利用している。  
JAX-RSは、RESTに準拠したWebサービスを作るためのJava EEの仕様。  
その実装として Jersey（リファレンス実装）や Apache CXF 、RESTEasy などがある。サンプルではRESTEasyが利用されている。  
【RESTEasy】https://access.redhat.com/documentation/ja-jp/jboss_enterprise_application_platform/5/html-single/resteasy_reference_guide/index  
  
WEBコンテナに乗せるのは面倒、かつ（多分）サンプルの操作インターフェースが揃っていないので、アプリケーション層に対するテストを記述して動かしていく。  
以下のように動かしたいコンテキストのプロジェクトルートに移動し、テストクラスを指定してtestTaskを実行していく。  
```  
[localhost IDDD_Samples]$ cd iddd_collaboration/  
[localhost iddd_collaboration]$ ../gradlew -Dtest.single=**/CalendarEntryApplicationServiceTest test  
:iddd_common:compileJava UP-TO-DATE  
:iddd_common:processResources UP-TO-DATE  
:iddd_common:classes UP-TO-DATE  
:iddd_common:jar UP-TO-DATE  
:iddd_collaboration:compileJava UP-TO-DATE  
:iddd_collaboration:processResources UP-TO-DATE  
:iddd_collaboration:classes UP-TO-DATE  
:iddd_common:compileTestJava UP-TO-DATE  
:iddd_common:processTestResources UP-TO-DATE  
:iddd_common:testClasses UP-TO-DATE  
:iddd_collaboration:compileTestJava UP-TO-DATE  
:iddd_collaboration:processTestResources UP-TO-DATE  
:iddd_collaboration:testClasses UP-TO-DATE  
:iddd_collaboration:test  
  
BUILD SUCCESSFUL  
  
Total time: 7.188 secs  
[localhost iddd_collaboration]$   
```  

# メモ
メモ
```
エンティティはグローバルで一意な識別子を必ずもつが、だからと言ってそれがエンティティとは限らない。
エンティティは自身の振る舞いによって状態（エンティティを構成するオブジェクト部品を）変更する（ライフサイクルを持つ）ものだ。
エンティティが自身の振る舞いによって状態（エンティティを構成するオブジェクト部品を）変更する必要があるのか？
全体を丸ごと置き換えて対応できるのならエンティティではなく値オブジェクトとして設計した方がシンプルになる。
状態の変更にロジックがある場合やイベントが発生する場合、全体を丸ごと置き換えることが不自然な場合はエンティティとなるだろう。
変更点と、その他の再構成に必要な全データが取得でき、前の状態を考えることなく置き換えることができるなら値オブジェクトの方が良い。

エンティティ(集約ルート)か、ローカルエンティティか、値オブジェクトか？
エンティティ(集約ルート)：複数のローカルエンティティ/値オブジェクトで構成される。
ローカルエンティティ：複数のローカルエンティティ/値オブジェクトで構成される。
値オブジェクト：複数のプリミティブ型/値オブジェクトで構成される。

エンティティ(集約ルート)ファクトリ（できれば必須）、
ローカルエンティティファクトリ（必要に応じて）、
値オブジェクトファクトリ（必要に応じて）



集約は意味ある単位で区切る（不変条件を満たすため）
二つの集約を一つにまとめることもできる。
一つにまとめてもルート経由の操作は守られるので問題ない。
しかし大きな集約は扱いずらい。
小さく分けて参照した方が良い。（集約Aと集約B）
パッケージを分けるかどうかは好み
集約Aが集約Bを参照している場合、集約Aのパッケージのサブパッケージに集約Bを配置しても良い。
どちらにせよ、集約が二つあることに変わりはない。
```
```
エヴァンスまとめ
第3部 より深い洞察へ向かうリファクタリング
【序章】
リファクタリングはコードの良し悪しが動機となることが多いが、ドメインについての洞察に基づくリファクタリングは重要になる。
・深いモデル
深いモデルは、ドメインエキスパートの主要な関心事と、それに最も深く関連した知識に関する明快な表現を提供する。
・発見のプロセス
抱えている問題に本当に合った設計を作り出すためには
まずはドメインと最も関連の深い、中心となる概念を捉えるモデルを発見する必要がある。これを第9章「暗黙的な概念を明示的にする」で扱う。
コードのリファクタリングが難しいとモデリングのプロセスが止まってしまう。
ソフトウェア開発者のためにソフトウェアを作成する方法が必要だ。これを第10章「しなやかな設計」で扱う。
見つけだした概念をモデルにする上で適切な方法を見つける必要がある。そこですでに使えるパターンがあるかもしれない。
これを第11章「アナリシスパターン」、第12章「デザインパターン」で扱う。
・ブレイクスルー
ドメイン駆動設計を行っていると、ソフトウェアを予想以上に表現力豊かで用途が多いものへと変える機会が訪れる。
これをブレイクスルーと呼ぶ。ブレイクスルーは前もって計画しておくことができないものだ。
第8章「ブレイクスルー」でその一例を紹介する。


【第8章 ブレイクスルー】
狙って起こるものではないから焦らずにコツコツのリファクタリングを行うこと。


【第9章 暗黙的な概念を明示的にする】
ドメインエキスパートの言葉をよく聞こう。
それほど明白ではない概念をモデル化する方法を学ぼう。これにより設計が鋭くなる。これには3つのカテゴリがある。
1 明示的な制約
ドメインオブジェクトの操作一つ一つに明示的な制約（ルール）があることはよくある。
操作メソッドの中にルールを記載すると、ルールが複雑になっていくと、ドメインオブジェクトの操作をルールが圧倒してしまう。
その制約を該当ドメインオブジェクトのプライベートなメソッドに適切な名前をつけて切り出すことで、わかりやすく、変更もしやすくなる。

2 ドメインオブジェクトとしてのプロセス
複雑なアルゴリズムを伴う手続きをプロセスと呼んでいる。
基本的にオブジェクトは手続きをカプセル化してくれるものである。
ドメインの中に登場するプロセスは、ドメインモデルとして設計しなければならない。（例えば輸送アプリケーションの経路選択プロセス）
そういう場合は、ドメインモデルの中に「〜サービス」クラスを用意することで、そういったプロセスがあることを言葉で明示的に表現しつつ、カプセル化できる。
また、プロセスの実行方法が複数あるときは、アルゴリズムをストラテジーパターンで実装する手段も考えられる。
プロセスの実装がドメインモデルに含まれるべきか、インフラストラクチャ層にあるべきかを判断するのは簡単で、
そのプロセスについてドメインエキスパートが話題にあげるかどうかである。

3 仕様
これはいわゆる仕様パターンである。
仕様が複数ある場合は、それぞれを仕様オブジェクトにするようだ。


【第10章 しなやかな設計】
オーバーエンジニアリング（必要以上の設計）だとクライアントが操作しきれない。
モデル駆動設計では、適度に厳密な設計スタイルが必要である。
開発者には2つの役割がある。1つがクライアント開発者である。クライアント開発者は設計の持つ能力を活用しながら、ドメインオブジェクトをアプリケーションコード
や他のドメインオブジェクトに織り込んでいく。
クライアント開発者は、疎結合した概念を最低限集めたものを柔軟に使用して、ドメインにおける幅広いシナリオを表現できる。
もう一方のモデル開発者にとっても、モデルは変更に強く、わかりやすいものでなくてはならない。
そういったしなやかな設計に貢献するパターンを紹介していく。

・意図の明白なインターフェース
ある開発者があるコンポーネント（オブジェクト）を使用するために、その実装についてじっくり考えなければならないのであれば、カプセル化の価値は失われる。
たまたま開発者の要求を満たしているからという理由で、コンポーネントが意図しない目的で利用されてしまうかもしれない。
さしあたりコードは動くかもしれないが、後ほど修正したときに不具合が発生することは明白である。
それゆえ：
　クラスと操作には、その効果と目的を記述する名前をつけ、その手段には言及しないこと。こうすることでクライアント開発者はインターフェースの内部を理解しなくて良くなる。
こうした名前にはユビキタス言語を用いること。

・副作用のない関数
操作はクエリとコマンドに分けられる。コマンドは更新処理であり、副作用を持つ。
更新処理が副作用を持つのは、メソッド呼び出しの深いネストにより意図しない更新処理が起こることがよくあるためである。
コマンドを使わないシステムはないが、副作用を防ぐために2つの手段がある。

・表明
契約による設計を使う。不変条件・事前条件・事後条件をユニットテストで表現しておく。
モデル図とソースコードコメントにその表記を加えること。

・概念の輪郭
機能を細かく切り刻んでメソッドにすれば、クライアントがそれを組み合わせることになる。
機能を大きくまとめてメソッドにすれば、クライアントの要求に合わず、機能が重複する。
概念的に意味のある機能の単位を見つけ出すこと。

・独立したクラス
独立したクラスとは、低結合を極限まで進めたものだ。

・閉じた操作
・宣言的な設計
・設計の宣言的スタイル

これらのパターンはモデルに適用していくものだが、モデルは巨大なため、簡単に適用できるものではない。まずは対象を決めなければならない。
より大きな設計を引き受けるに当たってのアプローチを2つ紹介する。どのようにパターンを適合させ、利用するかを説明する。

・サブドメインを切り取る
どのようにサブドメインを選択するかは第15章で議論する。

・可能な場合には、確立された形式主義を利用する

【第11章 アナリシスパターンを適用する】

【第12章 デザインパターンをモデルに関係づける】
・ストラテジーパターン
ストラテジーパターンを使うと、クライアントがどのストラテジーを使うのか知らなければならないが、
ユーザーが画面上などからストラテジーを選択しているのであれば区分オブジェクトにストラテジーの実装を埋め込んでおけば
アプリケーションコードでif文は必要ない。
クライアントが様々なストラテジークラスの存在（クラス名）を自然と理解できるようなモデルであればこのパターンを使う価値がある。
つまりストラテジーを使うクラスのクラス名やメソッド名に加えて、意味のレイヤをもう一つ追加しなければならない。

・コンポジットパターン

【第13章 より深い洞察へ向かうリファクタリング】

第4部
【第14章 モデルの整合性を維持する】
境界づけられたコンテキスト間の関係
・共有カーネル

モデルのサブセットを共有

機能面での統合が制限されると、継続的な統合（継続的インテグレーション）にかかるオーバーヘッドが大きくなる。
機能面による統合が制限されると、継続的な統合（継続的インテグレーション）にかかるオーバーヘッドが大きくなる。
機能面で統合できれば、継続的な統合（継続的インテグレーション）をしやすい。

機能面での統合が制限される＝アプリケーションの機能面でシステムを分けて統合、することができない
機能面で統合する＝各機能ごとにサブドメインにする

継続的な統合のスキルがチームにない、または、1チームが扱うにしては大きすぎるシステム
↓
継続的な統合が大変なんじゃないかと思う
↓
境界づけられたコンテキストを複数定義する
↓
複数チームで、それぞれに取り組む
↓
まとまりのない複数チームの場合、分けたコンテキストがうまく統合できない
↓
変換作業に時間を費やす
↓
最初から頑張って継続的な統合をすればよかったのでは？


複数のチーム間で、モデルとコードベース全体を同期させると（継続的インテグレーションの）オーバーヘッドが大きくなる。
モデルのサブセットを同期させることは良い。
稼働しているサブシステム間は頻繁に統合すること。
チームの中（一つのサブシステム）で行われる継続的な統合よりは頻度は低くなる。


・顧客/供給者
上流コンテキストが供給者、下流コンテキストが顧客として振る舞う。
顧客の要求が最優先である。
顧客は複数いることがあるので、供給者はその中でバランスをとる。
富者と貧者の関係ではない。（貧者が富者に対して要求を懇願するのではない）
しかしこのままでは、上流コンテキストチームがコードを変更するたびに顧客である下流コンテキストチームのことに気にしなければならない。
そのために自動化された受入テストを用意すること。
顧客/供給者チームが成功するのは、2つのチームが同じ経営陣の下にいて、最終的な目標を共有しているか、
実際に顧客と供給者の関係である別々の企業にいる場合であるようだ。
上流チームを動機づけるものが何もない場合は非常に難しい。

・順応者（/供給者）
上流に下流チームの要求に応える動機がない場合、下流はどうすることもできない。
人の役に立ちたいという思いから上流開発者は約束するかもしれないが、それが守られるとは思えない。
そういう善意を信じると、下流チームは決して手に入れられない機能に基づいて計画を立ててしまうことになる。
そういった場合、下流が上流を頼らない選択もある。（別々の道）
上流のソフトウェアをどうしても使いたいが、下流とは異なるパラダイムを用いたモデリングにより、
その設計を扱うのが難しすぎる場合、下流は変換が複雑化しても独自のモデルに変換して使用する選択を取る。（腐敗防止層）
上流のモデリングスタイルにそれなりの互換性がある場合は、上流に与えられたモデルで我慢する選択を取ることもできる。
これが順応者/供給者の関係である。
当然、供給者チームとユビキタス言語を共有する。
この決定により上流への依存関係は深くなり、アプリケーションの可能性は上流モデルに今ある能力と純粋に付加的に行われる機能追加によって制限される。
心情的に魅力的ではないので、実際に選択すべき時でも用いられないことが多い。
必ずしも順応者となることが悪というわけではない。利用コンポーネント（上流）が巨大で、結合する意味が重大（上流ありき）な場合は、その上流に従う順応者となることは道理にかなっている。
この関係は共有カーネルと似ているが、共有カーネルが密接に関係し合う2つのチームによる共同作業であるとすれば、
順応者は共同作業に興味がないチームとの統合を扱うものだ。

・腐敗防止層
あるシステムからデータを取り出し、それを別システムで間違って解釈してしまうと、確実にエラーが起きる。データベースが破壊されてしまうかもしれない。
やり取りしているプリミティブなデータが、各システムにどう関連づけられているか。そこに違いが必ずある。
プリミティブなデータ要素が厳密に同じ意味であっても、他システムへのインターフェースをこのような低レベルで動作させることは一般的に間違えている。
低レベルのインターフェースでは、他システムに向けてデータを説明できない。受け取る側にもそれを解釈する負担が生じる。
必要なのは別のモデルと接している部品の間で変換することで、異質なモデルの要素を消化しきれずにモデルが崩壊するのを防ぐことだ。
腐敗防止層は、あるモデルやプロトコルが持つ概念オブジェクトやアクションを、別のものに変換する仕組みなのだ。
腐敗防止層は、それ自体で複雑なソフトウェアになり得る。腐敗防止層を作る上で設計上、考慮すべきことを概観しよう。
　腐敗防止層のインターフェース… インターフェースは通常サービスの集合となる。稀にエンティティにもなる。
　腐敗防止層の実装…. ファサードとアダプタと変換サービスの組み合わせで実装する。
ファサードは接続先の別システムが巨大で複雑なひどいインターフェースを持っているときに、モデルの変換の負担とならないようにアクセスを簡略化するものである。
ファサードは通常別システム側に統合して配置すべきもので、当然モデルの変換は行わない。別システム側に統合することができない場合は、自システム側に配置する。
ファサードはモデルの利用者に配慮するものであり、利用者が同プロセスか、別プロセスかは
アダプタは振る舞いを実装している側が理解しているものとは別のプロトコルをクライアントが利用できるようにするラッパーである。
定義するサービスそれぞれに対して、そのインターフェースをサポートし、他システムやそのファサードに対して同等のリクエストをどうやって作成するのか知っているアダプタが必要となる。
アダプタの仕事はリクエストをどうやって作成するか知っていることであり、モデルの変換作業は行わない。
変換サービスはモデルを変換する。アダプタから使用される。
通信リンクを配置する箇所は、アダプタとファサードの間が適切である。
他のサブシステムがシンプルであるか、インターフェースが整理されている場合はファサードは不要かもしれない。


・別々の道
どんな統合にもオーバーヘッドはつきものである。
単一の境界づけられたコンテキスト内で徹底的して継続的な統合を行う場合から、
共有カーネルや顧客/供給者といった深く関わらない関係を経て、
順応者や腐敗防止層といった防御的な態度に至るまで、
オーバーヘッドは存在する。統合は非常に有益かもしれないが、必ず高くつく。
統合は高くつくが、それによる利益は小さいこともある。チーム間を調整するという通常のコストに加え、統合には妥協が避けられない。


・公開ホストサービス
こちらのサブシステムにアクセスできるようにするプロトコルを、サービスの集合として定義すること。
そのプロトコルを公開し、こちらのサブシステムと統合する必要のある人が全員使用できるようにすること。
結果として、他のサブシステムは公開ホストのモデルと結合することになり、他のチームはホストチームが使用する特定の方言を習得せざるを得なくなる。
そこで知名度の高い公表された言語を交換可能なモデルとして用いることで、結合度が低くなり、理解が容易になる。


・公表された言語



・単一の境界づけられたコンテキスト


・データの連携方法
データベース共有（Shared Database）… 依存度が高すぎて身動きが取れなくなる
ファイル転送（File Transfer）… 時間がかかる
リモートメソッド呼び出し（Remote Method Invocation）
メッセージング（Messaging）

オブジェクトモデル＝クラス（データと振る舞いのセット）
データはユーザーが送ってくるか、他のコンテキストから取得する。

コンテキストが連携する、とはデータをもらうこと。もしくは渡すこと（true/falseや、ユーザーのデータセットなど）
データをもらったら、それを元にオブジェクトモデルを作って動かす。

・データのもらい方・渡し方
データベース共有
ファイル転送
リモートメソッド呼び出し
メッセージング

・オブジェクトモデル（クラス）の共有
同じソースコードを使う（共有カーネル）
同じユビキタス言語を使う（順応者）
独自のモデルを使う（腐敗防止層）

別々の道ではそもそもデータをもらわない

【第15章 蒸留】
・抽象化されたコア
サブドメイン間で大量の相互作用があると、モジュール間で多数の参照を生成する必要が生じて分割した意味がなくなってしまう。
分割する線を垂直ではなく水平に引くこと。

モデルにおける最も根本的な概念を識別し、それを別のクラス・抽象クラス・インターフェースに括り出すこと。この抽象的なモデルは
重要なコンポーネント間の相互作用をほとんど表現するように設計すること。これが抽象化されたコアである。

こうすることで、各コンポーネント（サブドメイン）は、抽象的なコアを参照するようになる。

多態性によって、抽象型のインスタンス間にある詳細なバリエーションの多い実装を無視できる。
モジュール間の相互作用をインターフェースで表現できれば、リファクタリングして、それらの型を特別なコアモジュールに入れるとよい。

【第16章 大規模な構造】
・進化する秩序
・システムのメタファ
・責務のレイヤ
個々のオブジェクトがそれぞれ手作りの責務を与えられていると、ドメインの広い範囲をまとめて処理する上で指針も統一性もない。
巨大なモデルに一貫性を与えるには、そうした責務を割り当てる際に何らかの構造を課すことが有効である。

ドメインの構造を可視化して役立つものにするパターンとしてレイヤ化がある。
レイヤ化のルール（上位レイヤは下位レイヤを知り、下位レイヤは上位レイヤを知らない）だけをドメインに適用しても
ある程度効果はあるが、これらはモデルに対して洞察を与えたり、モデリング上の意思決定を導いたりすることはない。
より計画的なレイヤを行う必要がある。
階層が自然に形成されるモデルにおいては、概念的なレイヤは主要な責務を中心として定義される。
この時、レイヤ化と責務駆動設計という2つの強力な原理が働く。
レイヤに割り当てられる責務は、ここのオブジェクトよりも広範なものでなければならない。
責務をグループ化して、設計するモジュールや集約をどれか一つの境界内に収まるように括り出すとシステムがわかりやすくなる。
一方で、高次の責務とレイヤ化を組み合わせると、システムをまとめ上げるための原則となる。

モデルの中にある概念的な依存関係を調べること。
またドメインの様々な部分の変更について、変化の割合とその原因を調べること。
ドメインに自然な階層が認められたら、それに幅広い抽象的な責務を割り当てること。（責務のレイヤの構築）
それらの責務は、システムの高次の目的と設計について語るものでなければならない。
モデルをリファクタリングして、各ドメインオブジェクトと集約、モジュールの責務が、一つのレイヤに与えられた責務の範囲にうまく収まるようにすること。

責務のレイヤに最適なレイヤ化パターンは、緩やかなレイヤ化システムと呼ばれるものの変種で、
あるレイヤが直下のレイヤだけでなく、どの下位レイヤへもアクセスできるものである。

システムの主要テーマを明らかにして、全員の考えを統一しておける大規模な構造が求められている。

貨物の存在を考えることなく、船舶や鉄道会社のスケジュールについて考慮することはある。
逆に運送を考えることなく、貨物を追跡することはできない。
このことから、2つのレイヤが区別される。

「業務」の責務のレイヤ
このレイヤには、会社の活動が入る。
「貨物」と、貨物の「経路仕様」と、経路仕様を満たす「輸送日程」によって成り立つ。

「能力」の責務のレイヤ
このレイヤには、業務を行うために会社が利用するリソースが入る。
「運送行程」

顧客は難しい。
ほとんどの場合、荷物が配送されている間は関心の対象となるが、そのあとは次の配送時までほとんど忘れられる。
この場合は個人顧客向け配達サービスにおける業務のレイヤになる（こういう活動するから顧客という概念が必要だ。）
サンプル輸送業者では、顧客と長期にわたって関係を結び、リピータを増やし、リピータから活動が生まれる。
顧客という概念があって初めて活動ができる。だから「能力」のレイヤになる。

ドメインにとってふさわしい責務のレイヤを見つける必要がある。
レイヤはどうあるべきか？
ストーリーテリング：レイヤはドメインの基本的な現実や優先事項を伝えるものでなければならない。
概念的な依存関係：上位の層にある概念は、下位層を背景とした意味を持つべきであるのに対し、下位層は単独でなければならない
概念の輪郭：別々のレイヤにあるオブジェクトを見たとき、変化のスピードや原因が別々となるはずである。

基本的な責務のレイヤ一覧
「潜在能力」… 何ができるか？リソースを見るためのレイヤ。
「業務」… 何がなされたか？我々自身の取り組みと活動を見るためのレイヤ。
「意思決定」… どのように活用すべきか？分析と意思決定のためのレイヤ。

潜在能力のレイヤと、業務のレイヤはどう違うのか？
先に述べたレイヤのルールを思い出す。
上位層の概念は、下位層を背景としなければならない。
Ex. 顧客がいるから業務活動がある。活動の中で顧客がいる。



・知識レベル

・着脱可能コンポーネントのフレームワーク
成功しているプロジェクトには、設計を、特定のカテゴリの機能に関する責務を負わせたコンポーネントに分割しているものがある。
これらのコンポーネントは中央のハブに接続され、そのハブがあらゆる必要なプロトコルをサポートして、各コンポーネントが提供するインターフェースと通信方法を理解している。
コンポーネントのインターフェースとハブの設計の間には調整が必要だが、こうすることでコンポーネントを独立して開発できるようになる。

高次の抽象はシステムの広い範囲で識別・共有されるのに対し、専門化はモジュール内で起きる。
アプリケーションの中心的なハブになるのは、共有カーネル内の抽象化されたコアである。

着脱可能コンポーネントのフレームワークとは、中央のハブ（抽象化されたコア）から様々なコンポーネント（実装）を自由に置換できるフレームワークのこと。
つまり抽象化されたコアのインターフェースを経由して操作される限り、あらゆるアプリケーションがこのコンポーネントを使用できる。
```
```
戦略的設計の3つの基本原則
・コンテキスト
複数の論理モデルに基づいたコード、データが発生しないようにする原則。
パターン：境界づけられたコンテキスト

・蒸留
コアドメインに混ざっている雑念を取り除き、コアドメインを洗練させる原則。
パターン：ビジョン声明文、蒸留ドキュメント

・大規模な構造
ドメイン全体に包括的なルールを与え、ドメインを構成する各論理モデルそれぞれの役割と関連の仕方を理解しやすくする。
またはサブドメインに包括的なルールを与え、サブドメインを構成する各オブジェクトモデルそれぞれの役割と関連の仕方を理解しやすくする原則。
パターン：メタファ、責務のレイヤ、知識レベル
```
```
サブドメインとは何か、に結論をつける。
DDDの手順を決める
4部を頭から読んでいく。

ドメイン＝論理モデルの集合

一つの論理モデル＝アプリケーションの用途の一つを実現する仕組み

コンテキスト＝論理モデルに統一性を与える条件の集合（コードの一部、チームでの作業、会話、資料）

論理モデルに統一性がある＝論理モデルを構成するユビキタス言語に一貫性がある状態

オブジェクトモデル（モデルオブジェクト）＝論理モデルをコードで表したもの

サブドメイン＝一つの論理モデル（アプリケーションの用途の一つ）

コアドメイン＝サブドメインの中で最も重要なもの。

汎用サブドメイン＝サブドメイン中のコアドメイン以外のもの。

複数の論理モデルに起因する問題（複数の論理モデルに基づくコードが組み合わされる問題）
→顧客への請求（論理）モデルと、ベンダーへの支払い（論理）モデルが一つの料金オブジェクトを使う。
発生する問題：「料金」というユビキタス言語に一貫性がない（請求するものなのか、支払うものなのか分からない）
原因1:もともと複数の論理モデルであるということを認識できていない
原因2:本来一つの論理モデルがチームが違う、コードベースが違う、データベースが違うことが原因で複数のコンテキストに適用され、複数の論理モデルとして認識される

境界づけられたコンテキスト＝複数の論理モデルに起因する問題を解決するための手法。サブドメイン（一つの論理モデル）に対して明示的に一つのコンテキストがあることを宣言することで、一つのチーム、一つのコード、一つのデータベースを割り当てて、論理モデルの統一性を保つことができる。

よく使われるビジネスモデルという言葉で考えてみると
ビジネスモデル＝ビジネスを成功させるという用途を実現する仕組み
となる。
重要なのは、具体的にどんな仕組みかは分からないというところである。
例）ビジネスモデルを考えよう

コンテキストマップ
```
```
前知識
ドメイン＝論理モデルの集合
一つの論理モデル＝アプリケーションの用途の一つを実現する仕組み
コンテキスト＝論理モデルに統一性を与える条件の集合（コードの一部、チームでの作業、会話、資料）
論理モデルに統一性がある＝論理モデルを構成するユビキタス言語に一貫性がある状態
オブジェクトモデル（モデルオブジェクト）＝論理モデルをコードで表したもの
サブドメイン＝一つの論理モデル（アプリケーションの用途（責務）の一つ）
コアドメイン＝サブドメインの中で最も重要なもの。
汎用サブドメイン＝サブドメイン中のコアドメイン以外のもの。
複数の論理モデルに起因する問題（複数の論理モデルに基づくコードが組み合わされる問題）
→顧客への請求（論理）モデルと、ベンダーへの支払い（論理）モデルが一つの料金オブジェクトを使う。
発生する問題：「料金」というユビキタス言語に一貫性がない（請求するものなのか、支払うものなのか分からない）
原因1:もともと複数の論理モデルであるということを認識できていない
原因2:本来一つの論理モデルがチームが違う、コードベースが違う、データベースが違うことが原因で複数のコンテキストに適用され、複数の論理モデルとして認識される
境界づけられたコンテキスト＝複数の論理モデルに起因する問題を解決するための手法。サブドメイン（一つの論理モデル）に対して明示的に一つのコンテキストがあることを宣言することで、一つのチーム、一つのコード、一つのデータベースを割り当てて、論理モデルの統一性を保つことができる。
エリック・エヴァンスのドメイン駆動設計（エリック・エヴァンス）
第4部(第14章〜第17章)
　システムが複雑になると巨大なモデルを扱うことになる。
複雑なシステム（非常に入り組んだドメイン）を把握し、モデリングするための原則を紹介する。
この原則は「戦略的設計の原則」であり、複雑なシステムを設計する際の意思決定の指針となる。
この意思決定はチーム、チーム間で交渉して適用する。
この意思決定は社内政治が絡む。
　大抵の大掛かりなエンタープライズシステムが掲げる目標は、ビジネス全体をまかなう統合されたシステムを作ることである。
しかしビジネスモデルは巨大で複雑なため単一ユニットで管理することはできない。
このようなシステムは、概念も実装も、より小さい部分に分解しなければならない（モジュール性を実現する）。
ここでの課題は、システムを一つに統合することによる恩恵を失わずに、モジュール性を実現することだ。
モジュール性を実現するということは、システムにおける別々の部分の相互運用を可能にすることで、ビジネスにおける多様な業務を支援できるようにすることだ。
IEEEは相互運用性について「2つかそれ以上のシステムまたはコンポーネントが情報交換でき、また交換した情報を使用できる能力」と定義している。
あらゆるものを含む一枚岩のドメインモデルは大きすぎて扱いにくく、そこには微妙な重複と矛盾が詰め込まれる。
逆に別々の小さなサブシステムの集合がその場凌ぎのインターフェースでつなぎ合わされていると、システム間の接続のあらゆるポイントで一貫性に関する問題が発生する。（相互運用性が低い）
この両極端にある落とし穴は、体系化された設計戦略（「戦略的設計の原則」）によって回避できる。
「戦略的設計の原則」はシステムを設計する際に以下のような意思決定に導けるものでなければならない。
・実装と結びつかない（無駄な）モデルを作り出さない
・各部分の相互依存関係を減らす
・設計をより明確にする
・モジュール間の相互運用性と相乗効果を失わないようにする
・システムにおいて概念的にコアとなる場所、つまりシステムの「ビジョン」を捉えるモデルに集中する。
相互依存とは、それぞれがしっかりと自立ができているうえで、状況によっては、お互いに依存し合うこともできる関係性のこと。
逆に共依存とは、自分以外の存在がなくては存在できないこと。
しかも「戦略的設計の原則」に則った設計は全てプロジェクトが行き詰ることのないように行わなければならない。
これらの目標を達成するために3つのテーマを考察する。
この段階では戦略的設計の原則とはこういうものだよとは言っておらず、その原則がどんなものであるべきかを説明している。
その原則を守れば実現されるべきことを「目標」と表現し、その目標を達成するための方法をこれから説いていく。
つまりここから戦略的設計の原則とは何かが語られていく。
3つのテーマとは「コンテキスト」「蒸留」「大規模な構造」である。
　コンテキストは最も根本的なものである。
成功するモデルはその大小を問わず、最初から最後まで一貫しているべきで、矛盾や、定義が重複してはならない。
エンタープライズシステムが統合するサブシステムの中には、出自が多様なものがある。
またサブシステムのアプリケーションがあまりに異なるため、エンタープライズシステムのドメインと同一視できない場合がある。
異質なもので構成される部分の中で、モデルが暗に示されているだけであれば、そのモデルを統合するということは無理な注文かもしれない。
モデルの一貫性を保つためには、モデルを一つの統合するのか、統合せずに別々のモデルにするのかを決める。
明示的に境界づけれらたコンテキストを定義して、モデルを適用するのはその内部に限定し、さらに必要に応じてコンテキスト同士の関係も定義することにより
モデラはモデルの質が低下するのを避けられる。
　蒸留によって雑音が減り、注意の対象が適切に絞られる。
ドメインにおいて周辺的な重要でない問題に、かなりの努力が費やされるのはよくあることだ。
ドメイン全てを包括するドメインモデルは、システムにおいて最も付加価値のある特別な側面を目立たせて、その部分にできるだけ多くの力を与えるような構造にする必要がある。
補助的なコンポーネントにも重要なものはある。大切なのはチームで焦点を合わせることである。そうすることで
システムの極めて重大な部分に努力を向けやすくするだけでなく、システムのビジョンを失わずにいられる。
この戦略的蒸留により巨大なモデルは明確になる。
　大規模な構造によって全体像が完成する。
非常に複雑なモデルにおいては「木を見て森を見ず」になってはならない。
事物の末梢的部分にこだわりすぎて、本質や全体をとらえられないことのたとえ。
蒸留によって注意の対象をコアとなる場所に絞り、他の要素を脇役として示せるようになる。
しかし包括的なテーマがなければ、それらの要素の関係は紛らわしいままになるかもしれない。
包括的なテーマとはシステム全体に対して適用する、大規模な構造を把握するための設計要素やパターンだ。
そのパターンの一つである責務のレイヤについて後ほど掘り下げる。
　これら3つの原則「コンテキスト」「蒸留」「大規模な構造」は別々に使っても役に立つが、一緒に使うことで特に強力になり、優れた設計を作り出す上で助けになる。
適用するシステムが無秩序に広がっていて、完全に理解している人がいなくても優れた設計を作り出せるのだ。
大規模な構造は、全く異なるものから構成される部分に一貫性をもたらし、その部分を調和する上で助けになる。
大規模な構造と蒸留によって、各部分にある複雑な関係を理解できるようになる上で、全体を見失わずに済む。
コンテキストによって、別々の部分で作業を進めてもモデルを壊してしまったり意図せず断片化してしまったりすることがなくなる。
これらの概念をチームのユビキタス言語に追加することで、開発者は独自の解決策を考え出せるようになる。
　複数のチームが並行して新システムの開発に取り組んでいた。
顧客に請求書を送るモジュールを担当するチームが「料金」オブジェクトを実装しようとしたとき、別チームで既に「料金」オブジェクトが構築されていた。
そこで彼らは「料金」オブジェクトに必要なメソッドやプロパティを追加していくと、元の実装に影響を与えずに必要とする機能を実現することに成功した。
数日後、不思議なバグが発生した。（バグ内容は省略）原因は彼らが追加したプロパティだった。
　ここでの問題は、この2つのグループが異なるモデルを持ちながら、それを認識しておらず、さらに検出するプロセスもなかったことだ。
どちらのグループも自分たちのコンテキスト（顧客への請求とベンダへの支払）に都合のいいように、料金の性質に推測を立てていた。
実際には料金の性質は2つの文脈（コンテキスト）で異なる。この矛盾を解消せずにコードにしてしまったことで信頼できないソフトウェアが出来上がってしまった。
彼らが気づいてさえいれば、ユニットテストを追加したり、別のモデルを開発することができたかもしれない。
いずれにしても問題を解決するには、それぞれのモデルが適用される境界を明示的に定めるところから始まるのだ。
　モデルに対する根本的な要件は、システムの内部で一貫していることだ。
これは用語の意味が常に同じであることであり、矛盾したルールが含まれていないことでもある。
各用語の意味が明瞭で矛盾したルールがないという、モデルの、システム内部におけるこうした一貫性は「統一性」と呼ばれる。
複雑なエンタープライズシステム全体で統一性を維持するのは難しい。
そのためシステムの色々な部分で、複数のモデルを開発できるようにする必要があるが、システムのどの部分なら枝分かれして良いのか、
それらの相互関係がどうなるのかは慎重に選択しなければならない。モデルにおける極めて重要な部分を、緊密に統一する方法が必要なのだ。
これは設計上の意識的な決定と、独自のプロセスを確立することによってのみ生まれる。
巨大なシステムのドメインモデルで完全に統一性を確率するのは現実的ではないしコストにも見合わない。
　だが時には、複数のモデルが存在すると、それらの結合が制限されてコミュニケーションが煩雑になると考えたり、複数のモデルがあることがエレガントではないと考えて
一つの巨大なモデルの下に統一しようとしてしまう。これにはリスクがある。
・システム移行が大変
・リリース調整が大変
・特殊な要件をもつアプリの場合、統一性の問題から専用のモデルを用意できず振る舞いがオブジェクトの外に出る可能性がある
・一つのモデルで万人の要求を満たすため条件分岐が多くなる
　また複数のモデルが存在するのは、技術的な関心だけでなく、政治や経営方針、チーム編成や開発プロセスの結果による可能性もある。
複数のモデルに分割するつもりがなくても結果としてそうなってしまうこともありうるということだ。
　我々がすべきことは、何を統一すべきかについての前向きな意思決定と、何を統一しないでおくかについての現実に即した認識を組み合わせることだ。
こうすることで置かれている状況の全体像を共有でき、確実に統一したい部分を統一する方向に向けつつ、
統一しない部分のせいで混乱や破損が生じないように開発に着手できる。
　様々なモデルの境界と関係性をはっきりさせる方法（戦略）が必要である。
これらの戦略を意識的に選択し、そのあとは一貫してその戦略に従わなければならない。
本章で提示するのは、モデルの境界や他のモデルとの関係性を認識し、伝達し、選択するためのテクニックである。
全ては、プロジェクトの現在の領域（ドメイン）をマッピングすることから始まる。
境界づけられたコンテキストにより各モデルを適用できる範囲が定義され、
コンテキストマップによりプロジェクトのコンテキストの把握と、それらコンテキスト間の関係性を全体的に概観できるようになる。
一旦境界づけられたコンテキストができると「継続的な統合のプロセス」によってモデルの統一性が保たれる。
　そしてこの安定した（コンテキストマップが完成した）状況から始めることで、コンテキストを境界づけ、コンテキスト同士を関係づけるためのより効果的な戦略へと移行できるようになる。
効果的な戦略とは、共有カーネルを用いた緊密な連携から、別々の道を行く疎結合な連携まで幅広く存在する。
大きなプロジェクトにおいて、複数のモデルが共存し上手く機能することは多々ある。様々なモデルが、様々なコンテキストに適用される。
モデルはユーザーが適用する領域のことなので、具体的なソースコードは存在しない。
開発者がモデルに取り組むことで具体的なオブジェクトモデル（ソースコード）になる。
その時（オブジェクトモデルができる時）、開発者は無意識のうちにモデルをコンテキストに適用している。開発者が「自分が取り組んでいるモデルはこういうものだ」と解釈しているからだ。
コンテキストはモデルの統一性を保つものだ。コンテキストはモデルの解釈とも取れる。
だから当然、モデルの解釈（コンテキスト）が二つ以上あると、オブジェクトモデルがおかしな挙動になる。
作成するソフトウェアをコントロールできない外部システムと統合する場合、その外部システムが自分たちのドメインの一部を担っているとはいえ、
統合先のコンテキストが全く別であって、開発中のモデルに適用することができないのは明白である。
では冒頭の2チームは同じシステムを開発しているからといって、同じモデルに取り組んでいたのだろうか？
彼らが意図していたのは、お互いのやったことの一部を共有することだったが、何を共有し、何を共有しないのかを教えてくれる境界は存在しなかった。
2チームが一つのオブジェクトモデルを共有したときに、分岐してしまっている（2チームがそれぞれでコンテキストを持っている）ということを検知するプロセスも整っていなかった。
　1つのチームでさえも複数のモデルができてしまうことがある。
それはコミュニケーションが途切れ、モデルの解釈がずれてしまうことを指す。オブジェクトモデルのコードを変更する時にずれたモデルの解釈が適用されてしまう。
　他システムと連携するときデータ形式が異なっていて変換の必要があることは誰でも気づくが、より本質的な問題は2つのシステムで暗に示されているモデルが異なっているということだ。
多くのチームで行う巨大なプロジェクトでは、このモデルの異なりが同一システム内で起きることがよくある。
　複数のモデルの問題はどんな巨大なプロジェクトにも存在する。
別々のモデルに基づくコード（オブジェクトモデル）で構成されるソフトウェアはバグの温床になり、信頼できず、理解しにくいものになる。
そしてチームメンバ間のコミュニケーションは混乱し始める。あるオブジェクトモデルをどのコンテキストで適用すべきでないのかについては、ほとんどの場合不明瞭である。
　物事を正しく保つのに失敗したということが最終的に判明するのは、稼働中のシステムが正しく機能しなくなる時である。
しかし、問題はチームが編成されて、人々が交流するそのやり方（プロジェクト）から始まっているのだ。
したがって、モデルを適用すべきコンテキストを明確にするには、プロジェクトと最終成果物（コードやDBスキーマ）の両方を見なければならない。
　モデルが適用されるのは、あるコンテキストの中においてである。
そのコンテキストというのは、コードの中のある部分だったり、特定チームによる作業だったり、ブレインストーミングで考案されたモデルならば具体的な会話に限定されるかもしれない。
本書の例で使用しているモデルが適用されるコンテキストは、その具体例を説明している場所と、その具体例に関するその後の議論全てである。
モデルのコンテキストとは、モデル内の用語が特定の意味を持つと言えるようにするために適用しなければならない、あらゆる条件の集合である。
　複数のモデルに起因する問題（複数のモデルに基づく単一のオブジェクトモデルがバグの温床となる問題）を解決するためには、ある特定のモデルのスコープを明示的に定義しなければならない。
このモデルのスコープは、ソフトウェアシステムにおける境界づけられたコンテキストとして定義される。
この境界づけられたコンテキストには、単一のモデルが適用されるので、できるだけ統一性が保たれる。
当然だが、この定義はチーム編成と一致させなければならない。（複数チームで単一のモデルに取り組むと、モデルが複数のコンテキストに適用されてしまう）
この明示的な境界は、チーム編成、アプリに特有な部分が持つ用途、コードベース、データベーススキーマなどの観点から設定する。
その境界内では、モデルを厳密に一貫性のあるものに保つこと。
　境界づけられたコンテキストは、特定のモデルが適用される範囲を制限する。
そうすることでチームメンバーは、何が一貫性を持つべきで、それを他のコンテキストとどう関係づけるかということについて明確な理解を共有できるようになる。
　境界を明示的に引くことによって、モデルを純粋に保つことができる。注意を他のコンテキストに向けた際の混乱も避けられる。
境界を横断して統合するには必然的に変換が行われるが、それを明示的に分析することができる。
　境界づけられたコンテキストは、特定のモデルによって駆動されるシステムの持つ、あらゆる側面によって構成される。
　モデルの統一性が崩壊したらどうなるのだろうか？
2つの問題が生じる。「重複した概念」と、「偽同族語」だ。
概念の重複とは、実際には同じ概念を表しているモデル要素が2つあるということだ。
偽同族語とは、同じ用語を使って同じことを話しているのに、実際にはそうでないことをいう。
こうした問題に対処するパターンをを取り上げていく。
　境界づけられたコンテキストを定義したら、それを安定させなければならない。
多くの人々が同一の境界づけられたコンテキストで作業していると、モデルが分裂する傾向は強くなる。
チームが大きければ大きいほど問題も大きくなるが、3,4人ほどの少人数でも深刻な問題に直面することがある。
だからと言ってコンテキストを小さくしすぎると、一貫性に問題が出てしまう。
　別の人が作成したオブジェクトモデルを、開発者が理解せずに修正し、元々の目的に使用できなくなることがある。
自分が取り組んでいる概念がすでにモデルの別の部分に埋め込まれていることに気づかず、その概念と振る舞いを重複させてしまうこともある。
またはそうした他の表現があることに気づいていながら、既存の機能を壊すことを恐れて手を加えられず、概念と機能を重複させてしまうことさえある。
　これらを防止するセーフティネットが必要である。
XPはこれらの問題を解決するために本領を発揮する。そのXPを採用するにしてもしないにしても、継続的な統合のプロセスを行うことは不可欠だ。
　継続的な統合とは、そのコンテキスト内で行われる全ての作業について、頻繁にマージして一貫性を保つことにより、
分派が見られた時にすぐに発見して修正できるようにすることを意味する。
他のパターンと同様、継続的な統合も2つのレベルで作用する。それが①モデル概念の統合と②実装の統合である。
　概念の統合はチームメンバ間の絶え間ないコミュニケーションによって実現される。
チームは常に変化するモデルに関して共有された理解を培わなければならない。
ユビキタス言語を継続的に練り上げること。
　実装の統合はシステム的なマージ/ビルド/テストのプロセスによって実現され、
モデルの分派を早い段階で明らかにする。
　二つをまとめると、コードや他の成果物を頻繁にマージすること。
その際、モデルの分派を素早く警告する自動化されたテストも一緒に用いること。
ユビキタス言語の執拗な鍛錬を絶え間なく行い、モデルに対する共有された見方を練り上げること。
概念は、別々の人の頭の中で進化していくからだ。
これらは一つの境界づけられたコンテキスト内で行われる。
蒸留とは混ざり合ったコンポーネントを分離するプロセスであり、価値があって役立つ形式で本質を抽出するためのものだ。
本章ではドメインモデルを蒸留する方法を見ていく。
蒸留する努力の動機になっているのは、特別に価値がある部分をたった1つ抽出したいという欲求である。
それが我々のソフトウェアを特徴付け、構築する価値のあるものにする部分、すなわち「コアドメイン」である。
ドメインモデルに対する戦略的蒸留は、次に挙げることを全て行う。
①システムの全体的な設計と、設計同士がどう関係するのかを、チームメンバー全員が把握できるようにする。
②ユビキタス言語に入れやすいサイズのコアモデルを識別することで、コミュニケーションを促進する。
③リファクタリングの指針となる。
④モデルで最も価値がある領域に作業を集中させる。
⑤アウトソージングと既成コンポーネントの利用、その割り当てについて決定する際の指針となる。
　巨大なシステムを設計する際には、寄与するコンポーネントの数が非常に多い。
しかも、どれも複雑な上に成功には全てが絶対に必要である。
そのためドメインモデルの本質である実際のビジネスの資産が不明瞭になり、おろそかにされてしまうかもしれない。
　モデルの中には専門的な知識を捉えることも伝えることもなく、複雑さを付け加えるだけの部分もある。
ドメインの本質とは無関係なものがあると、それが何であれコアドメインを見分け、理解するのが難しくなる。
モデルを停滞させるのは、誰もが知っている一般原理や、専門領域に属する主要な焦点ではない補佐役を果たすような詳細である。
しかしながらこういった要素はシステムを機能させ、ドメインモデルを完全に表現する上で欠かせない。
　設計中のプロジェクトにとって動機となっていない高凝集のサブドメインを識別すること。
そうしたサブドメインから汎用的なモデルを括り出して、別のモジュールに入れること。その中に特化した要素を入れてはいけない。
一旦分離したら、その部分の開発の優先順位をコアドメインより下げ、その作業にコアとなる開発者の割り当てを避けること。
このような汎用サブドメインに対しては、既製品による解決策や公表されているモデルの採用も検討すること。
①既製品による解決策
②公表されている設計やモデル
③実装のアウトソージング
④自社での実装
　ドメインモデルのうち、公表されている設計やモデル（アナリシスパターンなど）で代替できる部分（サブドメイン）を、コアから分離する。
　開発の後期になるとモデルを詳細に調べなくてもわかる形でシステムの価値を説明する必要がある。
多くのプロジェクトチームは、管理のために「ビジョン声明文」を作成する。
このドキュメントの最も良いところは、アプリケーションが組織にもたらす具体的な価値を並べて示している点だ。
この声明文は開発のあらゆるフェーズで経営陣と技術系の担当者が直接使うことができて、リソースの割り当てや、モデリングの選択における指針、チームメンバーの教育に使われる。
ビジョン声明文には：
　コアドメインとそれがもたらす価値に関する簡潔な記述を作成すること（約1ページ）
　これは「価値の提議」となり、ドメインモデルのうち他と差別化するものでない側面を無視する。
　ドメインモデルがどのように役立つか示すこと。
　この声明文は早期に作成し、新しい洞察を得たら改訂する。
ドメインビジョン声明文は、広い観点から見た場合のコアドメインを識別するものだ。
しかし具体的なコアモデルの要素の識別は、予測できない個人の解釈に委ねられる。
このようなチームがコアドメインの構成を大まかに知っているだけの状態では、絶えずモデルをフィルタリングして主要な部分（強調されたコア）を識別しなければならない。
それを防ぐための、特殊なテクニックが2つある。
　蒸留ドキュメント
コアドメインを記述して説明するために、独立したドキュメントを作成する。
そこには最も本質的な概念オブジェクトの一覧程度の単純なものや、その関連を示した図一式、テキストベースのものでもよい。
この蒸留ドキュメントは決して全てが揃ったものではない。
コアに境界を引いて説明するのに必要な最低限なエントリポイントである。
詳細な記述は控え、抽象的に表現することで、資料の安定度は増し、ドキュメントが古くなることも防げる。
非技術系のメンバーにも理解できるようにすること。
　コアにフラグを立てる
ドメインビジョン声明文が200ページ以上に及ぶ大きな資料になってしまっている場合もある。
その場合すべきことは、ドメインの中で本質的で他との差別化の要因となっている概念を示すことである。
そしてその部分をプロトタイプ実装や、オブジェクト図のようなもので明確なものにする。
ドメインビジョン声明文と強調されたコアは、情報を伝えて道案内するが、モデルやコードそのものを変更することはない。
汎用サブドメインを切り分けると、気を散らす要素をいくつか物理的に除去できる。
　凝集されたメカニズムと汎用サブドメインはどちらも、コアドメインの負担を軽減したいという同じ願望に基づいている。
これらを比較してみると、
汎用サブドメインを括り出すことで雑音が減り、凝集されたメカニズムにより複雑な操作がカプセル化される。
　処理が設計を肥大させ始めるくらい複雑なレベルに達することがある。
概念的な「何が」が、機械的な「どのように」に侵食されてしまうのだ。
この問題を解決するためのアルゴリズムを提供するメソッドが大量に存在してしまうと、モデルを表現するメソッドがわかりにくくなる。
　最初に検討すべき解決策は、処理のメカニズムを単純にするモデルである。
システムにとって重要な巨大な境界づけられたコンテキストがあり、モデルの本質的な部分が大量の補助的な機能のせいでわかりにくくなってきたとき、隔離されたコアを切り出す作業を行う。
抽象化されたコアは、最終的に蒸留ドキュメントに非常に似たものになるはずだ。
もちろん抽象化されたコアはコードに書かれることになるので、より厳密で完全なものになる。
　巨大なシステムに包括的な原則がなく、そのせいで各要素を解釈する際に、設計全体にまたがるパターンにおいてどういう役割を果たすかという観点から考えることができなければ
開発者は「木を見て森を見ず」状態になってしまう。
全体の詳細を徹底的に調べなくても、全体の中で個々の部分が果たす役割を理解できる必要があるのだ。
「大規模な構造」は、システムをおおよその構造から議論し、理解できるようにするための言語である。
高次の概念の集合やルールの集合、もしくはその両方によって、システム全体に対する設計パターンが確立される。
様々な部分の果たす役割が、どのように全体を構成するかについての概念が共有されているのだ。
　ルールについてのパターンや、役割や関係性についてのパターンを考え出すこと。
このパターンはシステム全体に行きわたる。また、このパターンがあることで、全体における各部分の位置付けが、その部分の責務を詳細に知らなくても
理解できるようになる。
　大規模な構造は一つの境界づけられたコンテキスト内に限られることもあるが、通常は複数のコンテキストにまたがっていて、プロジェクトに携わる全てのチームとサブシステムを
一つにまとめる概念的な構成を提供する。
優れた構造は、モデルについての洞察を与え、蒸留を補完するのだ。
　多くの開発者が、設計が構造化されていないことによる損失を経験している。
無秩序を避けるためにプロジェクトはアーキテクチャを課して、開発を様々な方法で制約する。
しかしそのアーキテクチャによって開発者が上手く設計とモデルを作れなくなる場合もある。
　設計に制約がなければ、出来上がるシステムの全体像が誰にも理解できない上に、保守するのも非常に困難になる。
しかし、それを防ぐためのアーキテクチャもプロジェクトを束縛し、設計者や開発者から多くを奪ってしまうかもしれない。
　決して、指針となるルールの有無が問題なのではない。
そうしたルールの厳格さと成り立ちが問題なのだ。
設計を支配するルールが本当に状況に適合していれば、開発の妨げになることなく、むしろ開発を役立つ方向に推し進めると同時に一貫性をもたらす。
　それゆえ、概念上の大規模な構造をアプリケーションとともに進化させ、場合によっては途中で全く別の種類の構造に変更すること。
「コンテキスト」「蒸留」「大規模な構造」をどう組み合わせるのか？
実践ドメイン駆動設計（ヴァーン・ヴァーノン）
```

```
・エンティティか値オブジェクトか
モノか、モノの性質についての説明か。
これが全てであり、唯一の答えである。

要は一つのコンテキストの概念レベルのモデリングの段階で、ある概念をエンティティとして扱うのか
値オブジェクトとして扱うのかの決めの問題である。
当然、モノの性質についての説明でしかない概念をエンティティとして扱うことはできないが、（例えば誕生日など）
モノを、性質についてのみ着目した概念として捉えればエンティティではなく値オブジェクトとして扱える。

例えば
ユーザーそのものを概念として捉えればモノなのでエンティティとなり、ユーザーが情報を変更すればそれを反映し続ける義務が発生する。
ユーザーという概念を正しく捉え続けなければならない。
しかしユーザー情報として捉えれば値オブジェクトであり、任意のタイミングで取得したユーザーエンティティの性質についての説明を扱える。

ユーザーエンティティを永続化する必要が出てくるのは自然である。
ユーザー情報値オブジェクトを永続化する必要は基本的にない。なぜならユーザーがどこかにいるはずで、その情報はいつでも取得できるからである。
しかし負荷を考慮してユーザー情報を先に取得しておきたい場合もあるだろう。
```
```
・ファクトリ
導入する動機：
1. ドメインモデルのクライアントが、必要とするドメインオブジェクトを構築する段階で、その内部を（ドメインについてを）知り過ぎる場合。
言い換えれば、クライアントが構築に必要な情報（データや他のオブジェクトの状態や構築ルール）を全て、わかりやすく持っているならファクトリは不要だ。
そういった場合ではクライアントが構築に必要な値オブジェクトを生成し、目的のドメインオブジェクトを構築していけば良い。
ファクトリが必要となる内部を（ドメインについてを）知り過ぎている場合とは、
構築時に必要な情報がクライアントの手元にあるものだけでは足りず、他のドメインオブジェクトを利用したり、ドメイン特有の構築ルール(このパラメーターがあるときはこのパラメーターも必須とか）がある場合は、ファクトリクラスやファクトリメソッドを用意しなければ、クライアントがドメインについて知り過ぎてしまうことをいう。

2. 構築対象のオブジェクトが階層を持つ。
クライアントがコンストラクタを使うと具象クラスに依存してしまう。
階層を持つ利点としては、クライアントが抽象クラスに依存することで、クライアントのコードを変更することなく、具象クラスの切り替えで変更を可能にできることだ。
この利点を活かすためには、クライアントはコンストラクタではなく、ファクトリから抽象クラスの型で受け取らなければない。
```
