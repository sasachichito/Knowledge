# NOSQL  
NOSQLとは、Not Only SQLの略で「SQLだけでは十分でない」という意味である。  
これは"SQL(RDB)ではビッグデータ対応には"十分でない、という意味である。  
  
# ビッグデータ対応  
ビッグデータとはサイズの小さなデータが膨大に集まり、大きなデータの塊になったものを指す。  
単に大きなファイルは「ラージオブジェクト」と呼ばれる。  
  
「ビッグデータ対応」とは3Vに対応するということである。  
```  
3V  
・膨大な量 = Volume  
・速さ = Velocity  
・多様性 = Variety  
```  
  
### 膨大な量 = Volume  
ビッグデータを格納・処理することはハードウェアの性能向上（ハードディスクを大きく速いものにする）だけでは到底追いつけない。  
安価ながらそれなりの性能を持ったハードウェアを複数ならべ、あたかも一つの最高性能の装置のように扱う必要がある。  
  
### 速さ = Velocity  
ビッグデータを高速に処理することはハードウェアの性能向上だけでは到底追いつけない。  
こちらも分散して処理する仕組みが必要である。  
  
### 多様性 = Variety  
ビッグデータはデータの形が多種多様に変化していくもので、複雑なデータ構造と、複雑な相互関係を持つ。  
これらに対応できる仕組みが求められる。  
  
RDBは単一ハードウェアで稼働する場合は最適だが、データを分散させるには不向きだ。  
また多種多様なデータにおいてRDBでいう構造化は不可能である。  
結果、NOSQLが求められた。  
  
# NOSQLのデータモデル  
### SQLのデータモデル  
表の形でデータ構造を設計し、正規化でデータの冗長性と不整合を排除している。  
これにより個々のデータは定型化され、相互の関係性が明確に定義される。  
データの発生よりも先にデータ構造をテーブルの形に固定しておくことで、その関係性に揺らぎが生じないようになっている。  
  
### キー・バリュー型NOSQLのデータモデル  
テーブルや関係性を定義せずに、「キー」と「バリュー」の組み合わせからなるシンプルなデータモデル。  
キーによりバリューを一意に識別する。  
  
データが増えるに従って縦方向（行）に伸びていく。  
  
特徴  
```  
・データモデルがシンプル  
SQLのようなスキーマがなく、多くはキーはstring, バリューはBLOB（Binary Large OBject : ブロブ）でもつ。  
  
・スケールアウトに最適  
データ間の関係性がないため整合性を保つための排他ロックが不要なため、複数サーバーでデータをシャーディングすることが容易である。  
  
・レプリケーションが可能  
シャーディングだけではなくレプリケーションを考慮したNOSQL製品もある。  
```  
  
### カラム指向型NOSQLのデータモデル  
キー・バリュー型を少し高度にしたデータモデルで、1つのキーが1つのバリューと対になるのではなく、  
複数のキー・バリューを1キー（行キー）でグループ化するデータモデル。個々のキー・バリューをカラムと呼んでいる。  
グループ化されたカラム群と行キーを合わせてカラムファミリーと呼ぶ。  
  
テーブルではないのでキー毎のカラム数は固定されておらず、動的に追加できる。  
また全てのカラムにバリューが挿入されていないことも許容される。  
  
データが増えるに従って縦方向（行）と横方向（列）に伸びていく。  
  
特徴  
```  
カラムファミリー名と行キーは予め定義しておく必要があるが、その中のカラム（キー・バリュー）は動的に増やしていくことができる。（横方向に伸びていく）  
例えばカラム名（つまりキー）をタイムスタンプにして追加していくなど。  
当然、行キーが追加されていくこともある。（縦方向に伸びていく）  
  
キー・バリューと同様にスケールアウトに最適である。  
```  
  
### ドキュメント指向型NOSQLのデータモデル  
JSONやXMLなどの書式で記述されたドキュメントの形でデータを管理するデータモデル。  
  
特徴  
```  
内容をクエリできる  
```  
  
### グラフ型NOSQLのデータモデル  
データとデータのつながりを管理できるデータモデル。  
  
特徴  
```  
ノード・リレーションシップ・プロパティを使って経路を書くこと（グラフ化）を機能として提供している  
```  
  
# NOSQLのアーキテクチャ  
NOSQLのアーキテクチャは大きく、GoogleのBigtable系と、AmazonのDynamo系の2種に分類される。  
  
### Google Bigtable系  
GoogleのBigtable系は「マスタ型」と呼ばれ、一つのマスタノードが、配下にある多数ノードを管理する構成をとる。  
マスタノードがダウンする障害にはマスタ選出パターンで備える。  
  
CP（CAP定理）システムであり、必ず整合性が保たれるが可用性は低い。  
  
### Amazon Dynamo系  
AmazonのDynamo系は「P2P」と呼ばれ、マスタノードに該当するものは存在せず、全てのノードが対等にお互いを管理し合う構成をとる。  
こちらは単一障害点がないというメリットがある。  
  
AP（CAP定理）システムであり、高い可用性を持つが結果整合性である。  
  
### CAP定理  
分散システムにおける定理。  
```  
DBMSの分散システムとは、各ノードが互いにデータを複製して持っていることを意味する。  
マイクロサービスの分散システムとは、各サービスが互いに連携して1業務を実現していることを意味する。  
```  
今回はDBMSの分散システムの話。  
  
ノードA・Bがあったとき、  
```  
・クライアント1がAに書き込み→AはBに連携→Bも書き込み→Aがクライアント1にレスポンス返す  
・クライアント2がBにクライアント1が更新したデータの参照を要求する→Bがクライアントに最新データを渡す  
```  
という流れを守ることにより整合性を保ち、クライアント1,2の可用性を維持している。(これはABが分断されることを考慮していない）  
  
もしネットワーク障害によりAとBの間が分断された場合、この構成は破綻するためABを停止するしかない。  
つまり分断耐性（P）が無い。(RDBはこのCAシステム)  
  
ABが分断された時にサービスを停止しない（分断耐性を持たせる）にはどうすればよいか。このときがCPとAPへの分かれ道となる。  
**・整合性を担保するCPシステムにする**  
```  
AかBどちらかを停止する。  
例えばBを停止してクライアント2の参照・書き込みを失敗させることで、Aのクライアント1は常に整合性の取れた最新のデータで処理を続行できる。  
しかし当然クライアント2の可用性は失う。  
```  
**・可用性を担保するAPシステムにする**  
```  
AとBを稼働させ続ける。  
これによりクライアント1・2の可用性を維持したままサービスを続行できる。  
しかしクライアント1は2が書き込んだデータを参照できないし、その逆も然りなのでデータの整合性は失われる。  
```  
  
### 整合性の調整  
CAP定理はあくまで理論的に割り切ったものであり、実際には整合性は調整することができる。  
それにはQuorum（クォーラム）という基本概念を用いる。  
```  
Quorum : R + W > N の場合には整合性を保証できる。  
  
R（読み込み数）とW（書き込み数）の合計がN（ノード数）より大きい場合、必ず最新のデータを見つけることができるということである。  
例えば  
3ノード(ABC)あったとき、書き込みを2ノード(AB)に行い、読み込みを2ノード(BC)に行うと、必ず書き込まれたデータがあるノード(B)にアクセスすることができる。  
```  
  
Quorumの整合性調整により、サーバーダウンやネットワーク障害で1ノードと通信できなくなったときもサービスを稼働させ続け（分断耐性を実現し）、  
クライアントは2ノードにアクセスできるので可用性が保たれ、かつ整合性までも確保している。（この構成では2ノードダウンには耐えられないが）  
  
当然、書き込みや読み込みの処理が大きくなるため、性能とのトレードオフになる。  
  
### データのバージョン管理  
複数クライアントから同時に書き込みがありその内容が衝突する場合、どうやってデータのバージョンを管理し、最新バージョンに落ち着かせるのか。  
方法としては「タイムスタンプ」と「ベクタークロック」がある。  
  
##### タイムスタンプ  
その名の通り時間的な後先に従ってバージョン管理し、「新しいものが勝つ」というシンプルなルールを適用する。  
しかし完全に同時に書き込まれた場合や、ノード間でタイムスタンプの同期が難しい場合は「ベクタークロック」を用いる。  
  
##### ベクタークロック  
  
