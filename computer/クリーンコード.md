### 神は細部に宿る  
建築家のルートヴィッヒ・ミース・ファン・デル・ローエの名言「神は細部に宿る。」は、現代のアジャイル界においてアーキテクチャが果たす役割に対する議論を思い起こさせる。  
彼は自分が設計した全ての家のドアノブを自分自身で選ぶ人だった。それは小さなことこそが重要だからである。  
  
### 5s  
5sの原則はリーンの基礎である。  
5s：整理・整頓・清掃・清潔・しつけ  
```  
・整理（Sort）  
どこに何があるか把握すること。識別子の名前付けは重要である。  
  
・整頓（Systemize / Set in Order）  
何物に相応の場所がある。コードがあるべき場所にないのならリファクタリングして移動すること。  
  
・清掃（Shine）  
作業場所が汚れていないか。コメントやコメントアウトで散らかしているのなら清掃すること。  
  
・清潔（Standardize）  
3s（整理・整頓・清掃）を標準化すること。  
  
・しつけ（Self-Discipline / Sustain）  
決めたことを守るように習慣づけること。  
```  
  
リーン原則をソフトウェアへ実践的に適用する。  
  
# クリーンコード  
### そこにコードありき  
未来では、ビジネス領域の人達が仕様を元にプログラムを生成できるようになるので、プログラマは必要なく、コードに関する原則・パターン・実践は古いと考える人がいるがそれは間違いである。  
  
要件を詳細に明示し、機械的に実行可能なものにすることがプログラミングであり、そうした仕様がコードである。  
今後コードは抽象化されていき、ドメイン特化言語（DSL）も増えていくだろうが、それによって書かれるコードがなくなることは絶対にない。  
  
あいまいに提示された要望を寸分違わず満たせる機械など生まれるはずがない。  
また、よく定義された要件はコードのテスト仕様にはなりえるが、コードではない。  
  
コードは究極的な要求表現である。より要求に則した言語を作ることもできるだろうし、要件をパースして構造化するツールもできるだろう。  
しかしそこには必要最低限の正確さが要求され、その正確さこそがコードである。  
  
### 粗悪なコード  
粗悪なコードは会社を廃業にすら追い込む。  
粗悪なコードによる障害は、ぬかるみを歩くことから「ウェーディング（wading）」と呼ばれる。  
  
とりあえず動くものを作り後できれいにしたらいいじゃないかという考えは間違っている。  
レブランの法則「後で、とはやらないに等しい」  
  
### 混乱のために支払う総コスト  
プログラマ経験が2〜3年あれば他人の書いたぐちゃぐちゃなコードのせいで仕事の進行がひどく妨げられたことがあるだろう。  
当初は速いペースで仕事をしていたプロジェクトチームが1〜2年後にはカタツムリのごとく遅くなってしまっていることに気づくだろう。  
途中で基礎設計からやり直すことになる場合もある。  
  
エンジニアは納期を守るためにコードに混乱を埋め込んでしまうプレッシャーに駆られるだろう。  
真のプロであれば、混乱を埋め込んで納期を守ることなどできないことに気づかなければならない。  
混乱を埋め込めば、たちまち生産性は低下し、結局納期など守れなくなる。  
納期を守れるようにするには、コードを、常に、きれいな状態に保つしかない。  
  
管理者の言う通りの納期に間に合わなければクビになってしまう？  
手術前の準備で、ばかげた手洗いを行うのをやめてほしいと訴える患者がいるとしよう。  
患者が上司か顧客だったとしても、医師はきっぱり断らなければならない。なぜなら医師は患者よりも感染症のリスクに詳しいからだ。  
プログラマも同じだ。  
  
### クリーンコードとは？  
プログラマの数だけ定義がある。有名なプログラマたちのクリーンコードの定義には以下のようなものがある。  
```  
エレガントで効率が良い  
単純で直接的である  
決して設計者の意図をないがしろにしない  
明快な抽象化とまっすぐな境界線に溢れている  
原作者以外にも読むことができ、拡張できる  
単体テストと受け入れテストがある  
コードが文芸的である  
常に誰かが気配りを持って書いているように見える  
重複がない  
クラス・メソッド・関数といったものが最低限である  
```  
  
### ボーイスカウトの規則  
アメリカのボーイスカウトには単純な規則がある。  
```  
キャンプ場を、自分が見つけたときよりもきれいにすること  
```  
コードをチェックアウトしたときよりもきれいにして、チェックインするようにすればコードが腐ってしまうことはないだろう。  
プロジェクトの中で、時間の経過とともにコードが良い方向に向かっていく。これがプロ意識の本質である。  
  
# 意味のある名前  
  
# エラー処理  
  
### リターンコードではなく、例外を使用すること  
エラーフラグをセットしたり、エラーコードを戻したりしないこと。  
呼び出し元が、呼び出した後にすぐに特殊なエラーをチェックしなければならず、それは忘れやすい。  
  
そのため例外を送出すること。  
  
### 非チェック例外を使用すること  
チェック例外（検査例外）は、呼び出し元でキャッチもしくは再スローしていなければコンパイルエラーになる。  
これにより例外の検査漏れを防ぐことができる。  
  
しかしデメリットが大きい。  
呼び出し階層の奥深くでチェック例外が送出され、それが数レベル上の呼び出し元でキャッチされると、  
そのキャッチとの間にあるメソッド全てのシグネチャに例外を追加しなければならない。  
これは下位レベルの変更が、上位レベルのシグネチャ変更を強制することになり、オープン・クローズドの原則に違反する。  
要はチェック例外に関する変更が永遠に呼び出し元に波及してしまい影響が大きくなりすぎるということだ。  
  
チェック例外は重要なライブラリを書く場合にはキャッチを強制できるため有用なこともあるが、  
一般的なアプリケーション開発においては利用すべきでない。  
  
### 例外で状況を伝えること  
例外からスタックトレースを得ることはできるが、それだけでは失敗した処理の意図まではわからない。  
十分な情報を持ったエラーメッセージを作成し、それを例外に含めること。  
アプリケーションにロギングの仕組みがあるのならば、catchした場所でロギングを行うのに十分な情報を渡すこと。  
※ロギングしてはならないものを含めないこと（個人情報等）  
  
### 呼び出し元が必要とする例外クラスを定義すること  
例外クラスを定義してエラーを分類すること。その例外がどのようにキャッチされるかが重要になる。  
様々な種類の例外が飛び交うアプリケーションでは例外がどのようにキャッチされるかが不明瞭になってしまう。  
特定の領域のコード（パッケージやレイヤ）では、1つの例外クラスを使用すること。その方法としてサードパーティAPIをラッピングすることもベストプラクティスの一つである。  
  
特定の領域において、ある例外はキャッチしたいけれど、別の例外はキャッチしたくないというケースがある場合に限って2つ目以降の例外クラスを作成すること。  
  
### 正常ケースのフローを定義すること  
例外によってビジネスロジックを分離してはいけない。  
「例外をcatchした場合は〜」というロジックは正常ケースなのか異常ケースなのかわからない。  
Null Objectパターン（スペシャルケースパターン）を使って、例外を送出するのではなくNullオブジェクトやスペシャルケースオブジェクトを返却することを検討すること。  
  
### nullを返さないこと  
nullを返してしまうと、呼び出し元でnullチェックをしなければNullPointerExceptionが送出されてしまう。  
これは忘れやすく、コードを複雑にする。  
  
メソッドからnullを返そうとするときには、例外を送出するか、Nullオブジェクト（スペシャルケースオブジェクト）を返却すること。  
  
### nullを渡さないこと  
nullを渡された側でnullチェックをしなければならない。  
これは忘れやすく、コードを複雑にする。  
  
契約による設計を用いて、nullを渡さないようにルールを決めること。assertionなどで表明することも検討できる。  

# 単体テスト  
### TDD三原則  
```  
第一則：失敗する単体テストのコードを書く前に、製品のコードを書いてはならない  
第二則：コンパイルが通り、適切に失敗する単体テストができるまでは、次の単体テストを書いてはならない。  
第三則：現在失敗している単体テストが通るまで、次の製品コードを書いてはならない  
```  
  
### テストをきれいに保つこと  
汚いテストを持つということはテストを持たないことと同値である。  
テストが汚いほど、製品コードの変更は困難になる。  
テストも製品コードと同じようにきれいに保つこと。  
  
### テストは、xxx性を可能とする  
  
