### 神は細部に宿る  
建築家のルートヴィッヒ・ミース・ファン・デル・ローエの名言「神は細部に宿る。」は、現代のアジャイル界においてアーキテクチャが果たす役割に対する議論を思い起こさせる。  
彼は自分が設計した全ての家のドアノブを自分自身で選ぶ人だった。それは小さなことこそが重要だからである。  
  
### 5s  
5sの原則はリーンの基礎である。  
5s：整理・整頓・清掃・清潔・しつけ  
```  
・整理（Sort）  
どこに何があるか把握すること。識別子の名前付けは重要である。  
  
・整頓（Systemize / Set in Order）  
何物に相応の場所がある。コードがあるべき場所にないのならリファクタリングして移動すること。  
  
・清掃（Shine）  
作業場所が汚れていないか。コメントやコメントアウトで散らかしているのなら清掃すること。  
  
・清潔（Standardize）  
3s（整理・整頓・清掃）を標準化すること。  
  
・しつけ（Self-Discipline / Sustain）  
決めたことを守るように習慣づけること。  
```  
  
リーン原則をソフトウェアへ実践的に適用する。  
  
# クリーンコード  
### そこにコードありき  
未来では、ビジネス領域の人達が仕様を元にプログラムを生成できるようになるので、プログラマは必要なく、コードに関する原則・パターン・実践は古いと考える人がいるがそれは間違いである。  
  
要件を詳細に明示し、機械的に実行可能なものにすることがプログラミングであり、そうした仕様がコードである。  
今後コードは抽象化されていき、ドメイン特化言語（DSL）も増えていくだろうが、それによって書かれるコードがなくなることは絶対にない。  
  
あいまいに提示された要望を寸分違わず満たせる機械など生まれるはずがない。  
また、よく定義された要件はコードのテスト仕様にはなりえるが、コードではない。  
  
コードは究極的な要求表現である。より要求に則した言語を作ることもできるだろうし、要件をパースして構造化するツールもできるだろう。  
しかしそこには必要最低限の正確さが要求され、その正確さこそがコードである。  
  
### 粗悪なコード  
粗悪なコードは会社を廃業にすら追い込む。  
粗悪なコードによる障害は、ぬかるみを歩くことから「ウェーディング（wading）」と呼ばれる。  
  
とりあえず動くものを作り後できれいにしたらいいじゃないかという考えは間違っている。  
レブランの法則「後で、とはやらないに等しい」  
  
### 混乱のために支払う総コスト  
プログラマ経験が2〜3年あれば他人の書いたぐちゃぐちゃなコードのせいで仕事の進行がひどく妨げられたことがあるだろう。  
当初は速いペースで仕事をしていたプロジェクトチームが1〜2年後にはカタツムリのごとく遅くなってしまっていることに気づくだろう。  
途中で基礎設計からやり直すことになる場合もある。  
  
エンジニアは納期を守るためにコードに混乱を埋め込んでしまうプレッシャーに駆られるだろう。  
真のプロであれば、混乱を埋め込んで納期を守ることなどできないことに気づかなければならない。  
混乱を埋め込めば、たちまち生産性は低下し、結局納期など守れなくなる。  
納期を守れるようにするには、コードを、常に、きれいな状態に保つしかない。  
  
管理者の言う通りの納期に間に合わなければクビになってしまう？  
手術前の準備で、ばかげた手洗いを行うのをやめてほしいと訴える患者がいるとしよう。  
患者が上司か顧客だったとしても、医師はきっぱり断らなければならない。なぜなら医師は患者よりも感染症のリスクに詳しいからだ。  
プログラマも同じだ。  
  
### クリーンコードとは？  
プログラマの数だけ定義がある。有名なプログラマたちのクリーンコードの定義には以下のようなものがある。  
```  
エレガントで効率が良い  
単純で直接的である  
決して設計者の意図をないがしろにしない  
明快な抽象化とまっすぐな境界線に溢れている  
原作者以外にも読むことができ、拡張できる  
単体テストと受け入れテストがある  
コードが文芸的である  
常に誰かが気配りを持って書いているように見える  
重複がない  
クラス・メソッド・関数といったものが最低限である  
```  
  
### ボーイスカウトの規則  
アメリカのボーイスカウトには単純な規則がある。  
```  
キャンプ場を、自分が見つけたときよりもきれいにすること  
```  
コードをチェックアウトしたときよりもきれいにして、チェックインするようにすればコードが腐ってしまうことはないだろう。  
プロジェクトの中で、時間の経過とともにコードが良い方向に向かっていく。これがプロ意識の本質である。  
  
# 意味のある名前  
### 意図が明確な名前にすること  
コード上で何が行われているかを理解できるような名前をつけること。  
DDDにおける意図の明白なインターフェースにも関連する。  
  
### 偽情報を避けること  
コードの意味を曖昧にしてしまうような、間違った情報をコードに入れるのを避けること。  
よく使われる略語などと間違われるような変数名、  
順番を保持する必要がない複数形を扱うList、  
ごく一部のみが異なる名前、  
を避けること。  
  
### 意味のある対比を行うこと  
変数名・メソッド名・クラス名では意味のある対比を行うこと。  
意味のない対比には以下のようなものがある。  
```  
moneyAmountとmoney  
customerInfoとcutomer  
accountDataとaccount  
theMessageとmessage  
```  
読み手に違いがわかるように明確な名前をつけること。  
  
### 発音可能な名前を使用すること  
話し言葉を扱うために進化した脳の大部分を使わないのは勿体無い。  
また、発音できないコードについてのやりとりは混乱を招く。  
  
### エンコーディングを避けること  
型やスコープ情報を名前の中にエンコーディングしないこと。（組み込まないこと）  
インターフェースの接頭辞に「I（大文字アイ）」や、メンバー変数に「m_」をつけるなど。  
名前は読みづらくなり、またエンコーディングに関する知識が必要になる。  
  
### 解決領域と問題領域の用語の使用を区別すること  
コードの中にコンピューターサイエンスの用語、アルゴリズムの名前、パターンの名前が出てきて良いのは解決領域である。  
問題領域であるドメイン層ではビジネスの用語を使用すること。  
  
# 関数  
### 1つのことを行うこと  
関数の名前で抽象レベルと目的が決まる。  
関数の内部が、その抽象レベルにおけるいくつかのステップのみで表現されているのであれば、その関数は1つのことをしている。  
  
### 1つの関数に1つの抽象レベル  
1つの関数が複数の抽象レベルのことを行ってはならない。  
本質的な概念について述べているのか、実装詳細なのかわからず混乱を招く。  
  
### 関数の引数  
関数の引数は理想的には0（ニラディック、niladic）  
その次が1（モナディック、monadic）  
そして2（ダイアディック、dyadic）が続く。  
3（トライアディック、triadic）はできれば避けるべきで、  
4（ポリアディック、polyadic）とするのは、よほどの理由がなければやめるべきである。  
  
引数はやっかいである。  
読み手に解読させるし、別の抽象レベルが渡ってくることもある。  
またテストもしにくくなる。  
  
### 共通モナディック形式  
関数に一つの引数を渡す理由として、非常に一般的なものが2つある。  
引数で渡したものについて照会を行うケース、  
引数に対して操作して変換を行ってから返すケースの2つである。  
（イベントの発行などその他もある）  
  
この2つ違いが明確になるように名前を選ぶこと。（CQRS）  
また、もしも入力引数に対して何らかの変換を行うのであれば、それは戻り値として返すべきである。  
  
### フラグ引数は使わないこと  
フラグ引数は関数に2つのことをさせる。trueの時に1つ、falseの時に1つだ。  
それぞれ別のメソッドに分けること。  
  
### 2引数以上の関数  
ダイアディック（2つ）、トライアディック（3つ）、ポリアディック（4つ）は、モナディック（1つ）と比べて理解が難しくなる。  
2つの引数が概念的に正しい場合もあるが、2つの引数の間に概念的なつながりや順序がないのならばモナディックにする努力をしたほうが良い。  
方法としては引数のうち一つをプロパティとして持たせたり、クラスとして抽出したり、パラメータオブジェクトを利用する。  
  
### 動詞とキーワード  
1引数の場合、関数名と引数名は洗練された動詞/名詞の組み合わせになる。  
```  
write(name)  
```  
2引数以上では関数名にキーワードを入れることで、利用者がわかりやすいようにできる。  
assertEqualsは例えば  
```  
assertExpectedEqualsActual(expected, actual)  
```  
のようにすると、第一引数にactualを入れてしまうことがなくなる。  
  
### 出力引数を避けること  
関数が引数の状態を変更する場合に、その引数を出力引数と呼ぶ。  
関数の処理の出力先となる引数という意味。本来は関数の処理の入力である入力引数を渡すべきである。  
  
以下は出力引数を利用したappendFooter関数の利用例である。  
```  
public void main() {  
    this.appendFooter(s)  
}  
  
public void appendFooter(StringBuffer s) {  
    s.append(〜);  
}  
```  
このメソッドは利用者を混乱に招く。このメソッドを呼ぶことで引数の状態が変わってしまうことを見過ごすからだ。  
本来この関数は存在する必要がない。以下のように  
```  
public void main() {  
    s.append(〜);  
}  
```  
とできる。  
関数は、引数ではなく自分自身を変更すべきだ。つまりオブジェクト指向では出力が引数ではなくthisとなるべき。  
 
### コマンド・照会の分離原則  
関数は何らかの処理を行うか、何らかの応答を返すかのどちらかを行うべきで、両方を行ってはならない。  
つまり関数は、オブジェクトの状態を変更するコマンド関数であるか、オブジェクトの何らかの情報を返す照会関数のどちらかであるべき。  
  
両方同時に行うと混乱を招く。  
なぜならコマンド関数の関数名から、戻り値の意味を正しく理解するのは難しいからだ。  
  
この原則に従うと、  
コマンド関数のエラーハンドリングでは、戻り値でエラーコードを返却するよりも例外を送出する方が好ましい。  
  
### try/catchの分離  
try/catchブロックはそれ自体が不恰好であり、コードの構造を混乱させる。  
tryブロック、catchブロックの中身をそれぞれ一つの関数として外出しした方が良い。  
  
またtry/catch、すなわちエラー処理も一つの処理である。  
関数は一つのことを行うべきなので、try/catchが関数にあるならばその関数はtryで始まり、catch/finallyブロックで終わっていなければならない。  
  
### Error.java依存性磁石  
エラーコードを返すということは、どこかにエラーコードを定義したenumが存在することになる。  
こうしたクラスは依存性磁石と呼ばれる。様々なクラスがこのクラスをインポートして使用することからである。  
  
プログラマはエラーコードクラスの修正をしたがらなくなる。どこに影響があるかわからないからだ。  
  
エラーコードの代わりに例外クラスを利用することでオープン・クローズド原則に従うこと。  
  
### DRY（Don't Repeate Yourself）原則  
インポートを利用し、コードの重複を排除すること。  
  
### ドメイン特化言語（DSL）  
プログラマはベースとなる言語を使ってドメイン特化言語（DSL）を設計し、これを用いてシステムを設計する。  
関数はDSL内の動詞を、クラスは名詞を表す。  
DSLをうまく設計することでシステムをプログラムで書くのではなく、話して聞かせるストーリーとして捉えることができるようになる。  
  

# コメント  
```  
ダメなコードをコメントで取り繕ってはいけない。書き直すのだ。  
               ブライアンW.カーニハン、P.J.プラウガ  
```  
  
プログラミング言語の表現力が十分だったり、その言語を使って我々の意図をうまく表現できる才能があれば、コメントは全く必要ないものである。  
適切なコメントの使用方法は、コードでうまく表現することに失敗したときに、それを補うことに使うことだ。つまりコメントとは常に失敗である。  
  
コメントは嘘である。常にそうではないし、わざとでもないがほとんどの場合そうである。  
それはコメントがコードの進化から置き去りにされてしまうからだ。  
  
コメントの手入れに努力をするのではなく、コードを明確にし表現力豊かにすることでコメントを不要にする努力をするべきだ。  
ソースコードこそが真に正確な情報（ソース）である。  
場合によってはコメントが必要なこともあるが、それを最小限にすることに多大な努力をすべきだ。  
  
### コメントで、ダメなコードを取り繕うことはできない  
構造がわかりにくく、雑然としたコードがあったとき  
「コメントを入れて改善しよう」と思ってはいけない。コードを綺麗にするのだ。  
  
### よい（必要悪の）コメント  
コメントは良いものではなく、せいぜい必要悪だ。書かずに済ますよりも優れたコメントはない。  
以下は必要悪のコメントの例である。  
```  
・ソースファイルの先頭に著作権、著作者（契約情報を詳細に書きすぎないこと、標準ライセンスや外部ドキュメントへの参照にとどめること）  
・TODOコメント（なるべき早く潰すこと）  
・情報を与えるコメント  
・意図の説明  
・明確化  
・警告  
・強調  
・公開APIにおけるJavadoc  
```  
基本的には全てコードで表現することを目標とすること。  
  
### よくないコメント  
```  
・自分自身へのメッセージ  
・コード以上の情報がない  
・誤解を招くコメント  
・Javadoc  
・日誌コメント  
・コメントアウト  
・非局所的なコメント（コメントは対象となるコードの近くに書くこと、システム全体に及ぶ情報を局所的なコメントに載せないこと）  
・不明確なつながり（コメントとコードを読んだ人が、コメントの内容を全て把握できないようなコメントは載せないこと）  
・関数のヘッダコメント（短く一つのことをする関数には不要）  
・非公開コードのJavadoc  
```  

# コードの書式化  
コードの書式化とは情報伝達を意味し、情報伝達はプロの開発者の仕事を進める上で最も重要なことである。  
我々はソースコードを誰かに見せたとき、その簡潔さ・整合性・細部へのこだわりに気づき感動することを期待する。  
スクロールするにつれ驚きの表情になり、プロの仕事だとその人が認めることを期待するのだ。  
  
きちんと書式化されたコードは情報伝達に優れ、将来何度も行われるかもしれない変更に多大な影響を与える。  
  
## 縦方向の書式化  
### 新聞に例える  
新聞には最初に見出しがあり、最初の段落を読めば詳細を伏せたまま概要の大まかなところがわかる。さらに下に進むと詳細度が増していく。  
コードも新聞のようにすべきだ。パッケージ・クラス・関数の名前は単純でありながら説明的で、自分が見たいものなのか判断できなければならない。  
そして読み始めには上位レベルの概念とアルゴリズムがあり、読み進めるにつれて詳細度が増していかなければならない。  
  
また新聞は多くの小さな記事で構成されている。少なくとも1ページに渡るような記事はない。これは読み易さに大きく影響している。  
コードも新聞のように小さな単位で構成されるべきだ。1つのソースファイルは小さくすること。1000行を超える場合は設計がおかしい事を疑う。  
  
### 垂直概念分離性  
垂直概念分離性を正しく適用したコードを書くこと。  
これは空行に「概念を区切る」意味を持たせ、必要な部分に適用することを指す。  
  
### 垂直密度  
垂直密度を正しく反映したコードを書くこと。  
ソースの各行が強く関連している場合コメントや空行で引き裂いてしまわないこと。  
  
### 垂直距離  
密接に関連した概念は垂直方向に（同一ファイルに）、かつ近い位置にいなければならない。  
複数ファイルにまたがった概念は捉えにくい。実際、protectedな変数を避けるべき理由でもある。  
同一ファイルの中で複数の概念がある場合、垂直距離は同一概念において短くなるべきだ。  
  
### 変数宣言  
基本的に一時変数は宣言しない方が良いが（著書：リファクタリングを参照）、宣言する場合は変数が使用される場所となるべく近くで行うこと。  
  
### インスタンス変数宣言  
インスタンス変数はクラスの頭で宣言するべきである。これは垂直距離を広げることにはならない。  
なぜなら上手く設計されたクラスでは、インスタンス変数は全てではないにしろ多くの関数から使用されるからだ。  
インスタンス変数がクラス内の特定のグループの関数からしか使用されない場合、それらをクラスとして抽出すべきだ。  
  
  
## 横方向の書式化  
1行の長さは、右へのスクロールが起きない長さにすること。  
  
### 水平概念分離性と密度  
ホワイトスペースを使って概念を分離すること。  
逆に違い概念の間にはスペースを開けないこと。  
  
### 水平方向への位置合わせ  
変数宣言や代入時に、右辺値の開始列を揃えることはしないこと。  
これは型や演算子を見逃してしまう。またオートフォーマットで失われてしまう。  
  
もしも位置合わせしたくなるようなコードがある場合、問題は位置が揃っていないことではなく、リストが長いことである。  
つまりクラスやメソッドを分割べきであることを物語っている。  
  
### インデント  
ソースファイルは階層的なスコープから構築される。  
スコープを目に見えるようにインデントを規則に則って適用する。重要なのはプログラマはこの方法に大きく依存しているということだ。  
そのため短いif文やwhile文のとき、インデント規則を違反したくなる衝動に駆られるが、破ってはいけない。  
  
# オブジェクトとデータ構造  
変数をprivateにするのには理由がある。それは他からの依存を避け、頻繁にリファクタリングを行うとき自由に変更できるようにしておく必要があるからだ。  
  
### データの抽象化  
データの抽象化とは、利用者に対してデータの実装を知らせることなしに、データの本質を操作させることだ。  
  
#### ・データの実装を知らせない  
public変数や、private変数とそれに対する一揃いのgetterとsetterを用意してはいけない。  
これは利用者にデータの実装を知らせている。  
```  
public class point {  
	public double x;  
	public double y;  
}  
```  
そうではなく、データの前にメソッドを用意してアクセス方法を強制すること。  
```  
public interface point {  
	double getX;  
	double getY;  
	void setPoint(double x, double y);  
}  
```  
このインターフェースの例では（内容は適当だが）xだけ、yだけを設定することはできない。そのように利用者に強制している。  
  
#### ・本質を操作させる  
これはデータの前に単なるメソッドの層を配置するだけではいけない。  
以下は乗り物の残りの燃料の量を知る実装の2つの例である。  
```  
public interface Vehicle {  
	double getFuelTankCapacityInGallons();  
	double getGallonsOfGasoline();  
}  
```  
こちらは燃料タンクの容量と残りのガソリンをガロン単位で取得している。利用者はこのクラスがこれらのデータを保持していることに気づくだろう。  
以下では本質だけを操作させている。  
```  
public interface Vehicle {  
	double getPercentFuelRemaining();  
}  
```  
これはデータを抽象化し、利用者に本質だけを提供するよい例である。  
  
### データ / オブジェクトの非対称性  
データ構造とオブジェクトの違いは、データを抽象化しているかどうかである。  
データ構造はデータを公開し、意味を持った機能は持たない。  
オブジェクトは裏にあるデータを隠して抽象化し、データを操作する機能を持つ。  
  
データ構造を使用するコードを手続き型を呼び、オブジェクトを使用するコードはオブジェクト指向と呼ぶ。  
これらは相反するものである。  

#### ・手続き型  
コード
```
public class Square {
	public double side;
}

public class Rectangle {
	public double hight;
	public double width;
}

public class Circle {
	public double radius;
}

public class Geometry {
	publicfinaldoublePI = 3.141592653589793;

	public double area(Objectshape) throws NoSuchShapeException {
		if (shape instanceof Square) {
			Square s = (Square) shape;
			return s.side * s.side;
		} else if (shape instanceof Rectangle) {
			Rectangle r = (Rectangle) shape;
			return r.height * r.width;
		} else if (shape instanceof Circle) { 
			Circle c = (Circle) shape;
			return PI * c.radius * c.radius;
		} 
		throw new NoSuchShapeException();
	}
}

Ｒｏｂｅｒｔ Ｃ．Ｍａｒｔｉｎ,花井 志生. Clean Code　アジャイルソフトウェア達人の技 (Japanese Edition) (Kindle の位置No.2584-2588). Kindle 版. 
```
メリット... 新たな関数を追加しやすい。既存のデータ構造に影響を与えずに追加することができる。  
デメリット... 新たなデータ構造を追加しにくい。既存のすべての関数に影響がある。  
  
  
#### ・オブジェクト指向  
コード
```
public class Squareimplements Shape {
	private PointtopLeft;
	private double side;
	
	public double area() {
		return side * side;
	}	
}

public class Rectangle implements Shape {
	private PointtopLeft;
	private doubleheight;
	private doublewidth;
	
	public double area() {
		return height * width;
	}
}

public class Circle implements Shape {
	private Pointcenter;
	private double radius;
	public finaldouble PI=3.141592653589793;
	
	public double area() {
		return PI * radius * radius;
	}
}

Ｒｏｂｅｒｔ Ｃ．Ｍａｒｔｉｎ,花井 志生. Clean Code　アジャイルソフトウェア達人の技 (Japanese Edition) (Kindle の位置No.2601-2605). Kindle 版. 
```
メリット... 新たなクラスを追加しやすい。既存の関数を変えることなく追加することができる。  
デメリット... 新たな関数を追加しにくい。既存のすべてのクラスに変更を加えなければならない。    
  
複雑なシステムでは新たな関数を追加するよりも、新たなクラスを追加することが多い（新たなデータが増えることが多い）ためオブジェクト指向の方がよく適合する。  
熟練したプログラマなら、オブジェクト指向が常に優れているという考えが神話であることを理解している。  
単純なデータ構造とそれらを操作する手続きの方が必要とされる場合もある。  
  
オブジェクト指向のデメリットを、ビジターパターンやデュアルディスパッチ（ダブルディスパッチ）で補う設計もあるが  
これはプログラムを手続き型へと回帰させる代償をともなう。  
  
### デメテルの法則  
デメテルの法則は、オブジェクトを使用する場合、そのオブジェクトの内部について知るべきではないという法則で、以下のように述べている。  
```  
クラスcのメソッドfは、次のオブジェクトのメソッドのみを呼び出すべき  
・cそのもの  
・fで生成されたオブジェクト  
・fの引数で渡されたオブジェクト  
・cのインスタンス変数に保持されたオブジェクト  
```  
fは、上記の許されたメソッドから返されたオブジェクトのメソッドを呼び出してはいけない。  
つまり友達とのみ会話し、知らない人とは会話してはいけないのだ。  
以下のコードはデメテルの法則に違反している。  
```  
final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();  
```  
ctxt.getOptions()から返されたオブジェクトのメソッドを呼び出しているからだ。  
またこのようなコードはあたかも連結された車両のように見えるので、電車の衝突と呼ばれることがある。  
少なくとも以下のように記載した方が良いだろう。  
```  
Options ops = ctxt.getOptions();  
File scratchDir = ops.getScratchDir();  
final String outputDir = scratchDir.getAbsolutePath();  
```  
このように書いたとしてもデメテルの法則には違反している。  
結局ctxtがoptionを持ち、opsionがscratchDirをもち、scratchDirがoutputDirを持つという、オブジェクトの内部について知りすぎているからだ。  
別の言い方をすれば、この関数が大量の異なるオブジェクトをたどっていく方法を知っていることになり、1つの関数が知るべき内容としては多すぎる。  
  
ちなみにctxt, options, scratchDirがオブジェクトではなくデータ構造であれば、適切にデータの実装を公開しているので問題ない。  
手続き型にデメテルの法則は適用されないからだ。  
これが多少の混乱を招く。getterやsetterを持ったオブジェクトをデータ構造と誤認しデメテルの法則を適用しないパターンが発生してしまうのだ。  
  
このような混乱から、オブジェクトとデータ構造が混ざった「混血児」が生成される。  
混血児はオブジェクトとして重要な処理を行う関数を持ちつつ、データを公開するデータ構造となる。  
結果としてオブジェクト指向と手続き型の双方のデメリットが持つ最悪なパターンになる。  
  
先述の例は結局どうすればよかったのか。デメテルの法則に従うためには隠蔽構造を用いる。  
アプローチとしてはチェーンの最後で取得したoutputDirで結局のところ何がしたかったのかを考える。  
今回の場合はそのディレクトリに一時ファイルを作成したかった。  
それなら、それをctxtにやらせよう。こうすることで本来は隠蔽されているべき内部構造をたどることでデメテルの法則に違反する必要もない。  
  
### DTOとアクティブレコード  
DTOはデータ転送オブジェクトのことで、関数を持たないpublic変数で構成された典型的なデータ構造である。  
アクティブレコードはDTOの特殊形態で、public変数を持ったデータ構造だが、saveやfindといったナビゲーション用の典型的な関数を持つ。  
  
こうしたデータ構造にビジネスロジックを持った関数を追加しようとする開発者がいるが、それは勧められない。  
なぜならデータ構造とオブジェクトの混血児を作ることに他ならないからだ。  
  
これらはシンプルにデータ構造として要所で用いて、うまくオブジェクトと融合させるべきだ。  
  

# エラー処理  
  
### リターンコードではなく、例外を使用すること  
エラーフラグをセットしたり、エラーコードを戻したりしないこと。  
呼び出し元が、呼び出した後にすぐに特殊なエラーをチェックしなければならず、それは忘れやすい。  
  
そのため例外を送出すること。  
  
### 非チェック例外を使用すること  
チェック例外（検査例外）は、呼び出し元でキャッチもしくは再スローしていなければコンパイルエラーになる。  
これにより例外の検査漏れを防ぐことができる。  
  
しかしデメリットが大きい。  
呼び出し階層の奥深くでチェック例外が送出され、それが数レベル上の呼び出し元でキャッチされると、  
そのキャッチとの間にあるメソッド全てのシグネチャに例外を追加しなければならない。  
これは下位レベルの変更が、上位レベルのシグネチャ変更を強制することになり、オープン・クローズドの原則に違反する。  
要はチェック例外に関する変更が永遠に呼び出し元に波及してしまい影響が大きくなりすぎるということだ。  
  
チェック例外は重要なライブラリを書く場合にはキャッチを強制できるため有用なこともあるが、  
一般的なアプリケーション開発においては利用すべきでない。  
  
### 例外で状況を伝えること  
例外からスタックトレースを得ることはできるが、それだけでは失敗した処理の意図まではわからない。  
十分な情報を持ったエラーメッセージを作成し、それを例外に含めること。  
アプリケーションにロギングの仕組みがあるのならば、catchした場所でロギングを行うのに十分な情報を渡すこと。  
※ロギングしてはならないものを含めないこと（個人情報等）  
  
### 呼び出し元が必要とする例外クラスを定義すること  
例外クラスを定義してエラーを分類すること。その例外がどのようにキャッチされるかが重要になる。  
様々な種類の例外が飛び交うアプリケーションでは例外がどのようにキャッチされるかが不明瞭になってしまう。  
特定の領域のコード（パッケージやレイヤ）では、1つの例外クラスを使用すること。その方法としてサードパーティAPIをラッピングすることもベストプラクティスの一つである。  
  
特定の領域において、ある例外はキャッチしたいけれど、別の例外はキャッチしたくないというケースがある場合に限って2つ目以降の例外クラスを作成すること。  
  
### 正常ケースのフローを定義すること  
例外によってビジネスロジックを分離してはいけない。  
「例外をcatchした場合は〜」というロジックは正常ケースなのか異常ケースなのかわからない。  
Null Objectパターン（スペシャルケースパターン）を使って、例外を送出するのではなくNullオブジェクトやスペシャルケースオブジェクトを返却することを検討すること。  
  
### nullを返さないこと  
nullを返してしまうと、呼び出し元でnullチェックをしなければNullPointerExceptionが送出されてしまう。  
これは忘れやすく、コードを複雑にする。  
  
メソッドからnullを返そうとするときには、例外を送出するか、Nullオブジェクト（スペシャルケースオブジェクト）を返却すること。  
  
### nullを渡さないこと  
nullを渡された側でnullチェックをしなければならない。  
これは忘れやすく、コードを複雑にする。  
  
契約による設計を用いて、nullを渡さないようにルールを決めること。assertionなどで表明することも検討できる。  

# 単体テスト  
### TDD三原則  
```  
第一則：失敗する単体テストのコードを書く前に、製品のコードを書いてはならない  
第二則：コンパイルが通り、適切に失敗する単体テストができるまでは、次の単体テストを書いてはならない。  
第三則：現在失敗している単体テストが通るまで、次の製品コードを書いてはならない  
```  
  
### テストをきれいに保つこと  
汚いテストを持つということはテストを持たないことと同値である。  
テストが汚いほど、製品コードの変更は困難になる。  
テストも製品コードと同じようにきれいに保つこと。  
  
### テストは、xxx性を可能とする  
  
