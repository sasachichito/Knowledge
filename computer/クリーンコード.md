### 神は細部に宿る  
建築家のルートヴィッヒ・ミース・ファン・デル・ローエの名言「神は細部に宿る。」は、現代のアジャイル界においてアーキテクチャが果たす役割に対する議論を思い起こさせる。  
彼は自分が設計した全ての家のドアノブを自分自身で選ぶ人だった。それは小さなことこそが重要だからである。  
  
### 5s  
5sの原則はリーンの基礎である。  
5s：整理・整頓・清掃・清潔・しつけ  
```  
・整理（Sort）  
どこに何があるか把握すること。識別子の名前付けは重要である。  
  
・整頓（Systemize / Set in Order）  
何物に相応の場所がある。コードがあるべき場所にないのならリファクタリングして移動すること。  
  
・清掃（Shine）  
作業場所が汚れていないか。コメントやコメントアウトで散らかしているのなら清掃すること。  
  
・清潔（Standardize）  
3s（整理・整頓・清掃）を標準化すること。  
  
・しつけ（Self-Discipline / Sustain）  
決めたことを守るように習慣づけること。  
```  
  
リーン原則をソフトウェアへ実践的に適用する。  
  
# クリーンコード  
### そこにコードありき  
未来では、ビジネス領域の人達が仕様を元にプログラムを生成できるようになるので、プログラマは必要なく、コードに関する原則・パターン・実践は古いと考える人がいるがそれは間違いである。  
  
要件を詳細に明示し、機械的に実行可能なものにすることがプログラミングであり、そうした仕様がコードである。  
今後コードは抽象化されていき、ドメイン特化言語（DSL）も増えていくだろうが、それによって書かれるコードがなくなることは絶対にない。  
  
あいまいに提示された要望を寸分違わず満たせる機械など生まれるはずがない。  
また、よく定義された要件はコードのテスト仕様にはなりえるが、コードではない。  
  
コードは究極的な要求表現である。より要求に則した言語を作ることもできるだろうし、要件をパースして構造化するツールもできるだろう。  
しかしそこには必要最低限の正確さが要求され、その正確さこそがコードである。  
  
### 粗悪なコード  
粗悪なコードは会社を廃業にすら追い込む。  
粗悪なコードによる障害は、ぬかるみを歩くことから「ウェーディング（wading）」と呼ばれる。  
  
とりあえず動くものを作り後できれいにしたらいいじゃないかという考えは間違っている。  
レブランの法則「後で、とはやらないに等しい」  
  
### 混乱のために支払う総コスト  
プログラマ経験が2〜3年あれば他人の書いたぐちゃぐちゃなコードのせいで仕事の進行がひどく妨げられたことがあるだろう。  
当初は速いペースで仕事をしていたプロジェクトチームが1〜2年後にはカタツムリのごとく遅くなってしまっていることに気づくだろう。  
途中で基礎設計からやり直すことになる場合もある。  
  
エンジニアは納期を守るためにコードに混乱を埋め込んでしまうプレッシャーに駆られるだろう。  
真のプロであれば、混乱を埋め込んで納期を守ることなどできないことに気づかなければならない。  
混乱を埋め込めば、たちまち生産性は低下し、結局納期など守れなくなる。  
納期を守れるようにするには、コードを、常に、きれいな状態に保つしかない。  
  
管理者の言う通りの納期に間に合わなければクビになってしまう？  
手術前の準備で、ばかげた手洗いを行うのをやめてほしいと訴える患者がいるとしよう。  
患者が上司か顧客だったとしても、医師はきっぱり断らなければならない。なぜなら医師は患者よりも感染症のリスクに詳しいからだ。  
プログラマも同じだ。  
  
### クリーンコードとは？  
プログラマの数だけ定義がある。有名なプログラマたちのクリーンコードの定義には以下のようなものがある。  
```  
エレガントで効率が良い  
単純で直接的である  
決して設計者の意図をないがしろにしない  
明快な抽象化とまっすぐな境界線に溢れている  
原作者以外にも読むことができ、拡張できる  
単体テストと受け入れテストがある  
コードが文芸的である  
常に誰かが気配りを持って書いているように見える  
重複がない  
クラス・メソッド・関数といったものが最低限である  
```  
  
### ボーイスカウトの規則  
アメリカのボーイスカウトには単純な規則がある。  
```  
キャンプ場を、自分が見つけたときよりもきれいにすること  
```  
コードをチェックアウトしたときよりもきれいにして、チェックインするようにすればコードが腐ってしまうことはないだろう。  
プロジェクトの中で、時間の経過とともにコードが良い方向に向かっていく。これがプロ意識の本質である。  
  
# 意味のある名前  
### 意図が明確な名前にすること  
コード上で何が行われているかを理解できるような名前をつけること。  
DDDにおける意図の明白なインターフェースにも関連する。  
  
### 偽情報を避けること  
コードの意味を曖昧にしてしまうような、間違った情報をコードに入れるのを避けること。  
よく使われる略語などと間違われるような変数名、  
順番を保持する必要がない複数形を扱うList、  
ごく一部のみが異なる名前、  
を避けること。  
  
### 意味のある対比を行うこと  
変数名・メソッド名・クラス名では意味のある対比を行うこと。  
意味のない対比には以下のようなものがある。  
```  
moneyAmountとmoney  
customerInfoとcutomer  
accountDataとaccount  
theMessageとmessage  
```  
読み手に違いがわかるように明確な名前をつけること。  
  
### 発音可能な名前を使用すること  
話し言葉を扱うために進化した脳の大部分を使わないのは勿体無い。  
また、発音できないコードについてのやりとりは混乱を招く。  
  
### エンコーディングを避けること  
型やスコープ情報を名前の中にエンコーディングしないこと。（組み込まないこと）  
インターフェースの接頭辞に「I（大文字アイ）」や、メンバー変数に「m_」をつけるなど。  
名前は読みづらくなり、またエンコーディングに関する知識が必要になる。  
  
### 解決領域と問題領域の用語の使用を区別すること  
コードの中にコンピューターサイエンスの用語、アルゴリズムの名前、パターンの名前が出てきて良いのは解決領域である。  
問題領域であるドメイン層ではビジネスの用語を使用すること。  
  
# 関数  
### 1つのことを行うこと  
関数の名前で抽象レベルと目的が決まる。  
関数の内部が、その抽象レベルにおけるいくつかのステップのみで表現されているのであれば、その関数は1つのことをしている。  
  
### 1つの関数に1つの抽象レベル  
1つの関数が複数の抽象レベルのことを行ってはならない。  
本質的な概念について述べているのか、実装詳細なのかわからず混乱を招く。  
  
### 関数の引数  
関数の引数は理想的には0（ニラディック、niladic）  
その次が1（モナディック、monadic）  
そして2（ダイアディック、dyadic）が続く。  
3（トライアディック、triadic）はできれば避けるべきで、  
4（ポリアディック、polyadic）とするのは、よほどの理由がなければやめるべきである。  
  
引数はやっかいである。  
読み手に解読させるし、別の抽象レベルが渡ってくることもある。  
またテストもしにくくなる。  
  
### 共通モナディック形式  
関数に一つの引数を渡す理由として、非常に一般的なものが2つある。  
引数で渡したものについて照会を行うケース、  
引数に対して操作して変換を行ってから返すケースの2つである。  
（イベントの発行などその他もある）  
  
この2つ違いが明確になるように名前を選ぶこと。（CQRS）  
また、もしも入力引数に対して何らかの変換を行うのであれば、それは戻り値として返すべきである。  
  
### フラグ引数は使わないこと  
フラグ引数は関数に2つのことをさせる。trueの時に1つ、falseの時に1つだ。  
それぞれ別のメソッドに分けること。  
  
### 2引数以上の関数  
ダイアディック（2つ）、トライアディック（3つ）、ポリアディック（4つ）は、モナディック（1つ）と比べて理解が難しくなる。  
2つの引数が概念的に正しい場合もあるが、2つの引数の間に概念的なつながりや順序がないのならばモナディックにする努力をしたほうが良い。  
方法としては引数のうち一つをプロパティとして持たせたり、クラスとして抽出したり、パラメータオブジェクトを利用する。  
  
### 動詞とキーワード  
1引数の場合、関数名と引数名は洗練された動詞/名詞の組み合わせになる。  
```  
write(name)  
```  
2引数以上では関数名にキーワードを入れることで、利用者がわかりやすいようにできる。  
assertEqualsは例えば  
```  
assertExpectedEqualsActual(expected, actual)  
```  
のようにすると、第一引数にactualを入れてしまうことがなくなる。  
  
### 出力引数を避けること  
関数が引数の状態を変更する場合に、その引数を出力引数と呼ぶ。  
関数の処理の出力先となる引数という意味。本来は関数の処理の入力である入力引数を渡すべきである。  
  
以下は出力引数を利用したappendFooter関数の利用例である。  
```  
public void main() {  
    this.appendFooter(s)  
}  
  
public void appendFooter(StringBuffer s) {  
    s.append(〜);  
}  
```  
このメソッドは利用者を混乱に招く。このメソッドを呼ぶことで引数の状態が変わってしまうことを見過ごすからだ。  
本来、この関数は存在する必要がない。以下のように  
```  
public void main() {  
    s.append(〜);  
}  
```  
とするべきだ。  
  
# エラー処理  
  
### リターンコードではなく、例外を使用すること  
エラーフラグをセットしたり、エラーコードを戻したりしないこと。  
呼び出し元が、呼び出した後にすぐに特殊なエラーをチェックしなければならず、それは忘れやすい。  
  
そのため例外を送出すること。  
  
### 非チェック例外を使用すること  
チェック例外（検査例外）は、呼び出し元でキャッチもしくは再スローしていなければコンパイルエラーになる。  
これにより例外の検査漏れを防ぐことができる。  
  
しかしデメリットが大きい。  
呼び出し階層の奥深くでチェック例外が送出され、それが数レベル上の呼び出し元でキャッチされると、  
そのキャッチとの間にあるメソッド全てのシグネチャに例外を追加しなければならない。  
これは下位レベルの変更が、上位レベルのシグネチャ変更を強制することになり、オープン・クローズドの原則に違反する。  
要はチェック例外に関する変更が永遠に呼び出し元に波及してしまい影響が大きくなりすぎるということだ。  
  
チェック例外は重要なライブラリを書く場合にはキャッチを強制できるため有用なこともあるが、  
一般的なアプリケーション開発においては利用すべきでない。  
  
### 例外で状況を伝えること  
例外からスタックトレースを得ることはできるが、それだけでは失敗した処理の意図まではわからない。  
十分な情報を持ったエラーメッセージを作成し、それを例外に含めること。  
アプリケーションにロギングの仕組みがあるのならば、catchした場所でロギングを行うのに十分な情報を渡すこと。  
※ロギングしてはならないものを含めないこと（個人情報等）  
  
### 呼び出し元が必要とする例外クラスを定義すること  
例外クラスを定義してエラーを分類すること。その例外がどのようにキャッチされるかが重要になる。  
様々な種類の例外が飛び交うアプリケーションでは例外がどのようにキャッチされるかが不明瞭になってしまう。  
特定の領域のコード（パッケージやレイヤ）では、1つの例外クラスを使用すること。その方法としてサードパーティAPIをラッピングすることもベストプラクティスの一つである。  
  
特定の領域において、ある例外はキャッチしたいけれど、別の例外はキャッチしたくないというケースがある場合に限って2つ目以降の例外クラスを作成すること。  
  
### 正常ケースのフローを定義すること  
例外によってビジネスロジックを分離してはいけない。  
「例外をcatchした場合は〜」というロジックは正常ケースなのか異常ケースなのかわからない。  
Null Objectパターン（スペシャルケースパターン）を使って、例外を送出するのではなくNullオブジェクトやスペシャルケースオブジェクトを返却することを検討すること。  
  
### nullを返さないこと  
nullを返してしまうと、呼び出し元でnullチェックをしなければNullPointerExceptionが送出されてしまう。  
これは忘れやすく、コードを複雑にする。  
  
メソッドからnullを返そうとするときには、例外を送出するか、Nullオブジェクト（スペシャルケースオブジェクト）を返却すること。  
  
### nullを渡さないこと  
nullを渡された側でnullチェックをしなければならない。  
これは忘れやすく、コードを複雑にする。  
  
契約による設計を用いて、nullを渡さないようにルールを決めること。assertionなどで表明することも検討できる。  

# 単体テスト  
### TDD三原則  
```  
第一則：失敗する単体テストのコードを書く前に、製品のコードを書いてはならない  
第二則：コンパイルが通り、適切に失敗する単体テストができるまでは、次の単体テストを書いてはならない。  
第三則：現在失敗している単体テストが通るまで、次の製品コードを書いてはならない  
```  
  
### テストをきれいに保つこと  
汚いテストを持つということはテストを持たないことと同値である。  
テストが汚いほど、製品コードの変更は困難になる。  
テストも製品コードと同じようにきれいに保つこと。  
  
### テストは、xxx性を可能とする  
  
