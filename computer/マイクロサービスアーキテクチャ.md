# マイクロサービスアーキテクチャ   
## マイクロサービスとは  
マイクロサービスは小さく、かつ一つの役割に専念する。  
ここにはオブジェクト指向の単一責任原則が当てはまる。  
どの程度を小さいとするかについてオーストラリア Jon Eavesは「2週間で書き直せるもの」と特徴付けた。  
  
マイクロサービス は銀の弾丸ではないし、金のハンマーでもない。  
銀の弾丸... 必ず効果のある手法  
金のハンマー... 気に入った方法が、あらゆるところで利用できると思い込むアンチパターン  
  
## マイクロサービスの統合  
### ・原則  
個々のマイクロサービスは高凝集性・疎結合であり、「破壊的変更」が起きない。  
「破壊的変更」... マイクロサービスを変更するとコンシューマ側も変更を余儀なくされること。  
  
### ・共有データベースを避ける  
マイクロサービス側がデータの持ち方を変えるだけでコンシューマ側も変更が必要になることを防ぐ。  
  
### ・APIを非技術依存にする  
RPCでは特定のプラットフォーム上でしか動かない。またJava RMIなどではサーバー側の変更でコンシューマ側のスタブを更新する必要があり破壊的変更を避けれれない。  
またRPCではコンシューマがリモート呼び出しを把握しにくく、ネットワーク障害に対する準備がおろそかになることがある。  
  
### ・オーケストレーションではなくコレオグラフィにする  
個々のマイクロサービスをまたがるビジネスプロセスの実装方式はコレオグラフィにすること。  
オーケストレーション... 起点となるマイクロサービスが、必要となる別サービスのAPI呼び出しを行う方式  
コレオグラフィ... 起点となるマイクロサービスが発行したイベントを、別サービスが検知する方式  
オーケストレーションシステムでは起点のマイクロサービス が「神」サービスとなり、貧血症の別サービスを呼び出す形になってしまう。  
コレオグラフィシステムではそれを避けるが、正しく処理が行われたか追跡する必要がある。それ専用の監視システムを構築すると良い。  
  
### ・ハイパーメディアコントロールを利用する  
ショッピングサイトがカート画面を刷新してURIが変更されたとしても、ユーザーが画面上からカートにアクセスできるように、  
コンシューマに対してハイパーメディア（他のコンテンツへのリンクを含むコンテンツ）を返却し、  
コンシューマは目的の処理をリンクにアクセスするだけで実行できる状態にすることで、破壊的変更を防ぐ。  
  
### ・状態マシン（状態と振る舞いを持つ）サービスにする  
保持するデータに関する判断、加工処理ロジックをサービスに閉じ込めること。  
そうすることで複数のコンシューマにロジックが流出することを防ぎ、強い凝集性を保てる。  
当然ながらロジックの変更も容易となる。  
  
### ・破壊的フェイルオーバー（Martin Fowler）  
MQを利用するシステムで、特定メッセージを処理するとワーカーかダウンする不具合があった。  
ダウンするとフェイルオーバーにより特定メッセージが再びMQに戻され、全ワーカーがダウンするまで続くことを破壊的フェイルオーバーという。  
適切にリトライ回数を定めること。またメッセージ病院を用意し、リトライでも失敗したメッセージを追跡できるようにすること。  
  
### ・耐性のあるリーダーパターン（Martin Fowler）  
サービスに問い合わせた結果をバインディングする技術を選ぶ時、コンシューマーが必要とするデータ以外の全てをバインドしようとするものを避けること。  
コンシューマー側は必要なカラム名を知っていて、XMLのXPathのように柔軟に取得できるようにしておくこと。  
そうすることでサービス側が返答するデータの内容や形式の変更が、破壊的変更になることを防ぐ。  
  
### ・セマンティックバージョニングにする  
バージョン番号をMAJOR.MINOR.PATCHとして定義し、破壊的変更を検知できるようにする。  
  
### ・異なるエンドポイントの共存  
破壊的変更を行うとき、変更後のエンドポイントと変更前のエンドポイントの両方を公開する方法。  
コンシューマーが変更前のエンドポイントを使用しなくなったらコードを削除する。  
別バージョンのマイクロサービスを共存させる方法もあるがアンチパターンである。なぜならミドルウェアが  
コンシューマを適切なマイクロサービスを利用させる知識を持たなければならず動作保証が難しくなる。  
  
### ・API合成（ユーザーインターフェース）  
クライアントサイドアプリケーション（JavaScript)が複数のマイクロサービスを呼び出して画面を構成する。  
欠点が2つあり、1つはデバイスの種類ごとにレスポンスを調整できないこと。（マイクロサービス側がわざわざレスポンスを加工するしかない）  
もう1つはクライアントサイドアプリケーションを構築する人がいないこと。（UIの作り手が複数のマイクロサービスとの調整しなければならない）  
  
### ・UI部品合成（ユーザーインターフェース）  
ユーザーインターフェースをマイクロサービスが提供する。  
欠点が2つあり、1つは個々のUIの見た目が違ってシームレスで無くなってしまう。  
もう1つはデバイスの種類ごとにレスポンスを調整できないこと。  
  
### ・BFF（ユーザーインターフェース）（API合成の進化系）  
API合成の欠点の1つ、デバイスの種類ごとにレスポンスを調整できないことを克服する。  
APIゲートウェイを用意すればデバイスの種類ごとにレスポンスを調整できるが、様々なマイクロサービスの変更を検知し修正する必要が出てしまう。  
そこでマイクロサービスごとにフロントエンド用のバックエンドを用意することで上記を避け、かつレスポンスを調整する。  
  
### ・ハイブリッド手法（ユーザーインターフェース）  
UI部品合成とBFFの両方を用いる方法。  
  
### ・ストラングラー（絞め殺し）パターン  
レガシーシステムからマイクロサービスに移行するとき、リクエストの一部を徐々にマイクロサービスに移行させることでビックバンリリースを防ぐ。  
  
### ・テスト  
```
テストは、どこで（環境）なにを（テストスコープ）どうするか（テスト種別）で一意に決まる。  
```  
  
<details>    
  <summary>環境/テストスコープ/テスト種別/デプロイパイプライン</summary>    
  
#### 環境  
```  
CIサーバー(VM)  
開発環境  
ステージング(部分/完全)  
カナリア  
本番  
```  
CIサーバー(VM)以外は、その環境へのデプロイが発生する。  
  
#### テストスコープ  
```  
単体... クラス、関数、モジュール  
統合/結合/サービス... サービス（1インスタンス or クラスタ）と依存関係スタブ/モック  
エンドツーエンド... サービス（1インスタンス or クラスタ）と依存関係  
```  
スコープの大きさは、  
`単体 < 統合/結合/サービス < エンドツーエンド`  
統合/結合/サービススコープは以降サービススコープと呼ぶ  
  
#### テスト種別  
```  
lintテスト... 単体スコープに対して実行して、構文とスタイルのエラーがないことを確認するテスト  
単体テスト... 単体スコープに対して実行して、さまざまな部品にバグがないことを確認するテスト  
スモークテスト/サニティテスト... サービススコープ以上に対して実行して、単純ながら重要な挙動を確認する一連のテスト  
キャパシティテスト... サービスorエンドツーエンドスコープ（1インスタンス）に対して実行して、安定的に処理可能な限界リクエスト数と最大メモリ消費を確認するテスト。  
ロードテスト... サービスorエンドツーエンドスコープ（クラスタ）に対して実行して、負荷ピーク時に実際に安定して稼働できるか確認するテスト。  
回帰テスト... サービスorエンドツーエンドスコープに対して実行して、保管しておいた厄介なバグが再発していないか確認するテスト  
コンシューマ駆動テスト... サービスorエンドツーエンドスコープに対して実行して、システムの挙動がコンシューマの期待通りか確認するテスト  
ストレステスト... サービスorエンドツーエンドスコープに対して実行して、システムのボトルネックを確認するテスト  
カオステスト... サービスorエンドツーエンドスコープに対して実行して、あらゆる障害シナリオに対するシステムの耐障害性を確認するテスト  
```  
キャパシティテスト/ロードテスト/ストレステストはパフォーマンステストの一種。  
各テスト種別には、相性の良い環境とテストスコープがある。  
例）  
```  
【単体テスト】  
環境：CIサーバー(VM)  
テストスコープ：単体  
説明：デプロイ不要のためCIサーバー(VM)で、依存関係もいらないため単体スコープで良い。

【回帰テスト】  
環境：ステージング  
テストスコープ：サービス  
説明：
  
【ストレステスト】  
環境：本番  
テストスコープ：エンドツーエンド  
説明：ボトルネックは本番環境でないと正確に得られない、必然的にエンドツーエンドになる。
```  
  
#### デプロイパイプライン  
デプロイまでの流れをステージに分解し、前のステージが成功するまで次のステージに進ませない方法。  
デプロイとリリースを分けて考えること。  
例）  
```  
# スタート  
lintテスト（環境：CIサーバー(VM)、テストスコープ：単体）  
コンパイル  
単体テスト（環境：CIサーバー(VM)、テストスコープ：単体）  
  
# ステージングフェーズ  
ステージングリリース  
スモークテスト（環境：ステージング、テストスコープ：サービス）  
回帰テスト（環境：ステージング、テストスコープ：サービス）  
パフォーマンステスト（環境：ステージング、テストスコープ：サービス）  
スモークテスト（環境：ステージング、テストスコープ：エンドツーエンド）  
  
# カナリアフェーズ  
カナリアデプロイ  
スモークテスト（テストスコープ：エンドツーエンド）  
回帰テスト（テストスコープ：エンドツーエンド）  
カナリアリリース  
  
# 本番フェーズ  
本番デプロイ  
スモークテスト（テストスコープ：エンドツーエンド）  
回帰テスト（テストスコープ：エンドツーエンド）  
本番リリース  
```  
  
</details>    
  
### ・データベースリファクタリング  
#### 共有静的データ  
複数の境界づけられたコンテキストが単一な静的データを参照している場合のリファクタリング。  
```  
（1）それぞれの境界づけられたコンテキストで静的データを管理する。  
（2）それぞれの境界づけられたコンテキストのソースコード上で静的データを管理する。  
（3）静的データを独立した境界づけられたコンテキストとして定義する。  
```  
  
#### 共有可変データ  
複数の境界づけられたコンテキストが単一な可変データを参照している場合のリファクタリング。  
```  
（1）可変データをモデル化して独立した境界づけられたコンテキストとして定義する。  
```  
  
#### 共有テーブル  
複数の境界づけられたコンテキストが汎用的なテーブルを参照している場合のリファクタリング。  
```  
（1）汎用テーブルを分割してそれぞれの境界づけられたコンテキストで管理する。  
```  
  
### ・トランザクション境界  
モノリスを分割しマイクロサービスを作成すると、トランザクション整合性が失われる。その対象法は3つある。  
#### 結果整合性（後でリトライ）  
2つのマイクロサービスに対する一貫した処理のうち、2つ目の処理に失敗した場合、その処理をキューやDBに保管しておき後でリトライする。  
```  
メリット：わかりやすい。スケーリングしやすい。コレオグラフィシステムにできる。  
デメリット：データが不整合を起こしている状態が発生する。  
```  
  
#### 補正トランザクション（操作全体の中止）  
結果整合性で設計できない場合、補正トランザクションで対応する。  
補正トランザクションでは、2つ目の処理に失敗した場合、1つ目の処理のやり直し処理を実行する。  
このとき関係者に対して補正トランザクションが実行されたことをUIなどで通知すること。  
```  
メリット：データが不整合を起こさない。  
デメリット：オーケストレーションシステムになる。補正トランザクション失敗時の対処が複雑になる。（ロジックの置き場所や、多数のトランザクション時のロジックそのもの）  
```  
失敗を管理するため、管理者がアクセスできる保守画面や自動化プロセスを作るべきである。  
  
#### 分散トランザクション  
  
  
#### どれにすべきか  
可能であれば結果整合性で設計すること。  
補正トランザクションを用いる場合は、トランザクションを表す概念モデルを捉えロジックの置き場所とすると良い。  
  
  
### ・レポート  
レポート機能を実現する5つの方法  
  
#### レポートデータベース  
#### サービス呼び出し  
#### データポンプ  
#### イベントデータポンプ  
#### バックアップデータポンプ  
  
  
### ・デプロイ  
#### 継続的インテグレーション（CI）  
```  
全てを、互いに、常に同期させること。実際には新たにチェックインされたコードが既存コードと適切に統合（インテグレーション）されるようにすること。  
そのためにCIサーバーはコミットを検出し、そのコードをチェックアウトし、コンパイルとテストを行う。  
このプロセスの一環でサービスをデプロイし追加の検証（スモークテストや回帰テスト）に使う成果物を作成する。  
この成果物は一度だけ作成され、テストをパスした状態であることを確認できるようにすべき。  
この機能を実現するためにCIツール自体や別システムが提供するリポジトリに成果物を配置する。  
```  
CIとは何かを本当に理解しているかを調べるためにJez Humbleが訪ねた3つの質問  
```  
・１日に一度はメインラインにチェックインしていますか。  
・変更を検証するテストスイートがありますか。  
・ビルドが壊れたときに、それを修正するのがチームの最優先事項でしょうか。  
```  
##### マイクロサービスとCIのマッピング  
・nマイクロサービス -1リポジトリ-nビルド構成  
```  
n個のマイクロサービスが一つのリポジトリで管理されていて、  
1つのマイクロサービスに修正があったとき、1つのリポジトリにコミットされ、CIサーバーでn個のビルドが走る構成。  
メリット：  
構築・開発が楽  
デメリット：  
関係のない残り2つのマイクロサービスでもビルドされて成果物ができてしまい非常に時間がかかる。  
3つのマイクロサービスが1のリポジトリにあるため、サービスを結合してしまう変更にも陥りやすい。  
```  
・nマイクロサービス -1リポジトリ-1ビルド構成  
```  
n個のマイクロサービスが一つのリポジトリで管理されていて、  
1つのマイクロサービスに修正があったとき、1つのリポジトリにコミットされ、CIサーバーで1つのビルドが走る構成。  
メリット：  
デメリット：  
3つのマイクロサービスが1のリポジトリにあるため、サービスを結合してしまう変更にも陥りやすい。  
```  
・nマイクロサービス -nリポジトリ-1ビルド構成  
```  
n個のマイクロサービスがn個のリポジトリで管理されていて、  
1つのマイクロサービスに修正があったとき、1つのリポジトリにコミットされ、CIサーバーで1つのビルドが走る構成。  
メリット：  
特定のマイクロサービス向けのテストコードを、プロダクトコードと一緒に管理できる。  
デメリット：  
```  
  
#### 継続的デリバリ  
```  
新たにチェックインするたびに本番環境への準備状況に関するフィードバックを常に得られ、各チェックインをリリース候補として扱うこと。  
  
継続的デリバリとはリリースのスケジュールをIT部門が握るのではなく、ビジネス部門が握るということだ。  
継続的デリバリを実装するということは、全体のライフサイクルを通じて常にソフトウェアが本番環境にリリース可能であるということを意味する。  
すなわちどのビルドもボタン一発で、完全に自動化されたリリースプロセスを通じて、秒とか分の時間で利用者にリリース可能である、ということだ。  
Jez Humble  
```  
デプロイパイプラインの概念を含む。  
  
#### マイクロサービスとホストのマッピング  
nマイクロサービス-1ホスト構成  
```  
メリット：  
インフラチームのホスト管理が楽  
デメリット：  
複数のサービスがリソースを共有しているためホスト・インフラストラクチャレベルの監視/分析が困難。  
ホスト障害の影響が全サービスに及ぶ。  
各サービスのデプロイで他のサービスへの影響を考慮する必要がある。  
独立したスケーリングができない。  
```  
nマイクロサービス-1アプリケーションコンテナ-1ホスト構成  
```  
```  
  
1マイクロサービス-1ホスト構成  
```  
メリット：  
デメリット：  
```  
  
この辺りの詳しいことは  
「継続的デリバリー 信頼できるソフトウェアリリースのためのビルド・テスト・デプロイメントの自動化」  
を読むこと。  
