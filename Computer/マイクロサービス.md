# マイクロサービスアーキテクチャ   
### マイクロサービスとは  
マイクロサービスは小さく、かつ一つの役割に専念する。  
ここにはオブジェクト指向の単一責任原則が当てはまる。  
どの程度を小さいとするかについてオーストラリア Jon Eavesは「2週間で書き直せるもの」と特徴付けた。  
  
マイクロサービス は銀の弾丸ではないし、金のハンマーでもない。  
銀の弾丸... 必ず効果のある手法  
金のハンマー... 気に入った方法が、あらゆるところで利用できると思い込むアンチパターン  
  
### マイクロサービスの統合  
##### ・原則  
個々のマイクロサービスは高凝集性・疎結合であり、「破壊的変更」が起きない。  
「破壊的変更」... マイクロサービスを変更するとコンシューマ側も変更を余儀なくされること。  
  
##### ・共有データベースを避ける  
マイクロサービス側がデータの持ち方を変えるだけでコンシューマ側も変更が必要になることを防ぐ。  
  
##### ・APIを非技術依存にする  
RPCでは特定のプラットフォーム上でしか動かない。またJava RMIなどではサーバー側の変更でコンシューマ側のスタブを更新する必要があり破壊的変更を避けれれない。  
またRPCではコンシューマがリモート呼び出しを把握しにくく、ネットワーク障害に対する準備がおろそかになることがある。  
  
##### ・オーケストレーションではなくコレオグラフィにする  
個々のマイクロサービスをまたがるビジネスプロセスの実装方式はコレオグラフィにすること。  
オーケストレーション... 起点となるマイクロサービスが、必要となる別サービスのAPI呼び出しを行う方式  
コレオグラフィ... 起点となるマイクロサービスが発行したイベントを、別サービスが検知する方式  
オーケストレーションシステムでは起点のマイクロサービス が「神」サービスとなり、貧血症の別サービスを呼び出す形になってしまう。  
コレオグラフィシステムではそれを避けるが、正しく処理が行われたか追跡する必要がある。それ専用の監視システムを構築すると良い。  
  
##### ・ハイパーメディアコントロールを利用する  
ショッピングサイトがカート画面を刷新してURIが変更されたとしても、ユーザーが画面上からカートにアクセスできるように、  
コンシューマに対してハイパーメディア（他のコンテンツへのリンクを含むコンテンツ）を返却し、  
コンシューマは目的の処理をリンクにアクセスするだけで実行できる状態にすることで、破壊的変更を防ぐ。  
  
##### ・状態マシン（状態と振る舞いを持つ）サービスにする  
保持するデータに関する判断、加工処理ロジックをサービスに閉じ込めること。  
そうすることで複数のコンシューマにロジックが流出することを防ぎ、強い凝集性を保てる。  
当然ながらロジックの変更も容易となる。  
  
##### ・破壊的フェイルオーバー（Martin Fowler）  
MQを利用するシステムで、特定メッセージを処理するとワーカーかダウンする不具合があった。  
ダウンするとフェイルオーバーにより特定メッセージが再びMQに戻され、全ワーカーがダウンするまで続くことを破壊的フェイルオーバーという。  
適切にリトライ回数を定めること。またメッセージ病院を用意し、リトライでも失敗したメッセージを追跡できるようにすること。  
  
##### ・耐性のあるリーダーパターン（Martin Fowler）  
サービスに問い合わせた結果をバインディングする技術を選ぶ時、コンシューマーが必要とするデータ以外の全てをバインドしようとするものを避けること。  
コンシューマー側は必要なカラム名を知っていて、XMLのXPathのように柔軟に取得できるようにしておくこと。  
そうすることでサービス側が返答するデータの内容や形式の変更が、破壊的変更になることを防ぐ。  
  
##### ・セマンティックバージョニングにする  
バージョン番号をMAJOR.MINOR.PATCHとして定義し、破壊的変更を検知できるようにする。  
  
##### ・異なるエンドポイントの共存  
破壊的変更を行うとき、変更後のエンドポイントと変更前のエンドポイントの両方を公開する方法。  
コンシューマーが変更前のエンドポイントを使用しなくなったらコードを削除する。  
別バージョンのマイクロサービスを共存させる方法もあるがアンチパターンである。なぜならミドルウェアが  
コンシューマを適切なマイクロサービスを利用させる知識を持たなければならず動作保証が難しくなる。  
  
##### ・API合成（ユーザーインターフェース）  
クライアントサイドアプリケーション（JavaScript)が複数のマイクロサービスを呼び出して画面を構成する。  
欠点が2つあり、1つはデバイスの種類ごとにレスポンスを調整できないこと。（マイクロサービス側がわざわざレスポンスを加工するしかない）  
もう1つはクライアントサイドアプリケーションを構築する人がいないこと。（UIの作り手が複数のマイクロサービスとの調整しなければならない）  
  
##### ・UI部品合成（ユーザーインターフェース）  
ユーザーインターフェースをマイクロサービスが提供する。  
欠点が2つあり、1つは個々のUIの見た目が違ってシームレスで無くなってしまう。  
もう1つはデバイスの種類ごとにレスポンスを調整できないこと。  
  
##### ・BFF（ユーザーインターフェース）（API合成の進化系）  
API合成の欠点の1つ、デバイスの種類ごとにレスポンスを調整できないことを克服する。  
APIゲートウェイを用意すればデバイスの種類ごとにレスポンスを調整できるが、様々なマイクロサービスの変更を検知し修正する必要が出てしまう。  
そこでマイクロサービスごとにフロントエンド用のバックエンドを用意することで上記を避け、かつレスポンスを調整する。  
  
##### ・ハイブリッド手法（ユーザーインターフェース）  
UI部品合成とBFFの両方を用いる方法。  
  
##### ・ストラングラー（絞め殺し）パターン  
レガシーシステムからマイクロサービスに移行するとき、リクエストの一部を徐々にマイクロサービスに移行させることでビックバンリリースを防ぐ。  
  
  
  
# プロダクションレディマイクロサービス  
### マイクロサービスエコシステム  
マイクロサービスが正しく稼働し続ける環境（エコシステム）は4つのレイヤで構成される  
```
レイヤ1：ハードウェアレイヤ  
レイヤ2：通信  
レイヤ3：マイクロサービスプラットフォーム  
レイヤ4：マイクロサービス   
```

```
レイヤ1：物理サーバ、データベース、OS、リソース分離（仮想化・抽象化レイヤ）、構成管理、ホストレベルの監視、ホストレベルのロギング  
レイヤ2：ネットワーク、DNS、RPC、エンドポイント、メッセージング、サービス検出、サービスレジストリ、負荷分散  
レイヤ3：セルフサービス内部ツール、開発環境、テスト/パッケージング/ビルド/リリース用ツール、デプロイパイプライン、マイクロサービスのロギング、マイクロサービスレベルの監視  
レイヤ4：マイクロサービス、マイクロサービス固有の構成情報  
```

上位のレイヤの仕事をするエンジニアが、自分よりも下のレイヤの何かを設定、構成、利用しなければならないときは、そのエンジニアが使えるセルフサービスツールを用意すること。  
そうしなければ他のレイヤについてのエキスパートになることを求められ、大抵ミスが多発する。  
エキスパートでなくても利用できるようなUIを提供すること。  
  
マイクロサービス固有の構成情報（chefの設定、サーバー台数、デプロイツールの指定）などはマイクロサービス側（ソースコードの一部）に持つこと。  
そうしなければ何百ものマイクロサービス 固有の設定を下位レイヤが保持しなければならなくなる。  
  
### マイクロサービスのメリット  
スケーラビリティ（スケールアウトのしやすさ）  
処理効率（必要な機能を必要なだけスケールアウト・アップできる）  
開発効率（独立したデプロイ、機能追加のしやすさ）  
新テクノロジーへの対応  
  
### マイクロサービスのデメリット  
逆コンウェイの法則によるチーム孤立化（システム全体像を把握できる人が少なくなる）  
技術的スプロール（個々のマイクロサービスエコシステムが乱立する、開発スピードの速さから技術的負債が増える）  
障害の種類の増加  
リソースの奪い合い  

### マイクロサービスの標準化  
マイクロサービスには、すべてのマイクロサービスに適用できるほど一般的でありながら、  
定量化でき、測定可能な結果を生み出せる程度には個別的な標準と要件を定義しなければならない。  
  
マイクロサービスが標準を満たすための原則は  
マイクロサービスのアーキテクチャをどのように決め、どのように構築、実行すべきかを指導してくれるものである。  
  
原則のない標準は無意味である。  
  
##### ・本番対応の標準  
マイクロサービスが満たすべき標準として「本番対応」というものがある。  
本番対応を満たすための原則が8つある。  
```  
1. 安定性  
2. 信頼性  
3. スケーラビリティ  
4. 耐障害性  
5. 大惨事対応  
6. パフォーマンス  
7. 監視  
8. ドキュメント  
```  
  
```  
1. 安定性  
マイクロサービスアーキテクチャの導入により、開発者には非常に高いベロシティでの開発、デプロイの自由が与えられる。  
しかしこれにより、バグのあるコードがデプロイされ機能停止する可能性も増える。  
これを安定性が下がるという。  
安定性の原則は、マイクロサービスへの変更が責任のある形で行われるようにすることを通じて、本番対応に近づけるようにしてくれる。  
  
2. 信頼性  
マイクロサービスはクライアントや依存関係先から信頼されるものでなくてはならない。  
  
3. スケーラビリティ  
マイクロサービスはトラフィックの増加に対応できるように作らなければならない。  
マイクロサービスをスケーラブルにするためには  
（1）質的な成長の判断基準... 何が増えたらスケーリングするのか？  
（2）量的な成長の判断基準... どこまで増えたらスケーリングするのか？  
の両方が必要である。  
  
4. 耐障害性  
マイクロサービスはシステム内外の障害に耐えられる（耐障害性がある）ものでなくてはならない。  
内部障害... マイクロサービスが自ら招く障害  
外部障害... 内部障害以外の障害  
  
5. 大惨事対応  
マイクロサービスは大惨事に対応できるものでなくてはならない。  
  
6. パフォーマンス  
マイクロサービスはリクエストを素早く処理し、タスクを効率よく処理して、リソースを適切に使う（パフォーマンスの高い）ものでなければならない。  
  
7. 監視  
マイクロサービスにおける監視は  
（1）可用性に影響を与える重要な全ての情報の適切なロギング  
（2）社内の全ての開発者が簡単に理解でき、サービスの健全性を正確に判断できるように作られたグラフィカル表示  
（3）効果的でアクション可能な主要メトリックに基づくアラート  
の3つの構成要素を持つ。  
  
8. ドキュメント  
マイクロサービスのデメリットである技術的負債を引き起こす混乱、意識の欠如、アーキテクチャの理解の欠如を取り除かなければならない。  
ドキュメントとそれに伴う理解はマイクロサービスの可用性に直接影響を与える。  
```

原則にはいくつか要件がある。  
それらの要件を満たすことで原則に従う。  

### 安定性と信頼性  
安定性・信頼性のあるマイクロサービスの特徴  
```  
・標準化された開発サイクルがある。  
・コードは、lintテスト、単体テスト、統合テスト、エンドツーエンドテストを通じて徹底的にテストされている。  
・テスト、パッケージング、ビルド、リリースプロセスが、完全に自動化されている。  
・ステージング、カナリア、本番のフェーズを備えた標準的なデプロイパイプラインがある。  
・クライアントがわかっている。  
・依存関係がわかっており、障害が起こったときのために、バックアップ、代替サービス、フォールバック、キャッシュが用意されている。  
・安定性、信頼性のあるルーティング、検出が備わっている。  
```  
  
##### ・開発サイクルに関する要件  
前提としてバージョン管理システムを用いること。  
以下の手順で開発すること。  
```  
（1）コードを変更し開発環境(localhost, 開発用サーバー)で単体テスト、統合テストを行い問題なければ中央リポジトリにコミットする。  
（2）新しいビルドがlintテスト、単体テスト、統合テスト（、エンドツーエンドテスト）に合格したら、レビューを行う。  
（3）中央リポジトリに変更をマージする。  
（4）新しいビルドをデプロイパイプラインに送る。  
（5）(1)に戻る。  
```  
  
##### ・デプロイパイプラインに関する要件  
デプロイプロセスを技術組織全体で標準化したデプロイパイプラインを導入し、ヒューマンエラーを取り除くこと。  
パイプラインは、ステージング→カナリア→本番の順にデプロイを強制すること。  
ステージング環境は、完全ステージングか部分ステージングのどちらかとする。  
```  
完全ステージング... 本番環境との接続を一切許さない。他のマイクロサービスのステージング環境によっては正しくテストできない可能性があるため、デプロイを調整、スケジューリングする必要がある。  
部分ステージング... 本番環境へのアクセスが可能。不具合のあるコードがステージングにデプロイされたとき本番環境に影響が及ぶ可能性があるため、自動ロールバック機能を必要性がある。  
```  
ステージングには本番トラフィックは流さない。  
  
カナリアは、本番トラフィックを実行する小さなサーバプール（本番の処理能力の5%〜10%）に新ビルドをデプロイする。  
カナリアホストは本番サーバプールからランダムに選ぶ必要がある。  
アラートやログは本番環境と区別できなければならない。  
  
##### ・依存関係に関する要件  
安定性、信頼性を備えたマイクロサービスを作るには、依存関係の障害の影響を緩和する必要がある。  
したがって  
マイクロサービスのSLAを損なう可能性のある依存関係を把握すること。  
その依存関係をアーキテクチャ図とドキュメントに含め（ドキュメントの原則）、  
サービスのダッシュボードに含めなければならない。（監視の原則）  
  
次に個々の依存関係の障害時の対応として  
```  
（1）バックアップ... リクエストした内容や取得結果のバックアップ  
（2）代替サービス... 代わりのサービスの呼び出し  
（3）フォールバック... 機能を制限して稼働  
（4）キャッシュ... 取得結果のキャッシュ  
```  
のどれかを設定すること。  
  
##### ・ルーティングと検出  
マイクロサービスエコシステムのレイヤ2（通信レイヤ）で安定性と信頼性が関係するのは、サービス検出、サービスレジストリ、負荷分散である。  
これらの機能で、マイクロサービスの健全性チェックを行うこと。  
定期的にヘルスチェックをリクエストしたり、多数の未処理例外を検知したら起動するサーキットブレーカーを配置すること。  
  
##### ・非推奨と廃止  
マイクロサービスのエンドポイントを廃止するときには、そのサービスの開発チームは全てのクライアントサービスに警告メッセージを送り、  
依存関係の廃止にどのように対応すべきかアドバイスすること。  
エンドポイントを非推奨にする場合も同様である。  
  
##### 安定性・信頼性の評価基準  
```  
【開発サイクル】  
・マイクロサービスは、全てのコードが格納される一元管理されたリポジトリを持っているか。  
・開発者は、本番環境の状態（例えば、現実の世界）を正確に反映している開発環境で作業をしているか。  
・マイクロサービス のための適切なlintテスト、単体テスト、結合テスト、エンドツーエンドテストは揃っているか。  
・コードレビューの手続きや方針を用意してあるか。  
・テスト、パッケージング、ビルド、リリースのプロセスは自動化されているか。  

【デプロイパイプライン】  
・マイクロサービスエコシステムは、標準化されたデプロイパイプラインを持っているか。  
・デプロイパイプラインに、完全ステージングか部分ステージングのステージングフェースが含まれているか。  
・ステージング環境は、本番サービスに対してどのようにアクセスをするか。  
・デプロイパイプラインにカナリアフェーズはあるか。  
・あらゆる障害を捕捉できるくらいの期間を使って、カナリアフェーズでデプロイを実行しているか。  
・カナリアフェーズは、本番トラフィックのランダムなサンプルを正確にホスティングしているか。  
・マイクロサービスのポートは、カナリアと本番で同じになっているか。  
・本番環境へのデプロイは一度にまとめて行なっているか、それとも漸進的に展開しているか。  
・緊急時にステージング、カナリアフェーズを省略するための手順は用意してあるか。  

【依存関係】  
・マイクロサービスの依存関係はどれか。  
・マイクロサービスのクライアントはどれか。  
・このマイクロサービスは、依存関係の障害の影響をどのようにして緩和しているのか。  
・個々のパスにバックアップ、代替サービス、フォールバック、防御的キャッシュは用意してあるか。  

【ルーティングと検出】  
・マイクロサービスの信頼性に対する健全性チェックは実行されているか。  
・健全性チェックは、マイクロサービスの健全性を正確に反映しているか。  
・健全性チェックは、通信レイヤ内で別チャネルを使って実行されているか。  
・不健全なマイクロサービスがリクエストを発行するのを防ぐサーキットブレーカーは配置されているか。  
・不健全なホストやマイクロサービスに本番トラフィックが送られるのを防ぐサーキットブレーカーは配置されているか。  

【非推奨と廃止】  
・マイクロサービスを廃止するための手続きは用意してあるか。  
・マイクロサービスのAPIエンドポイントを非推奨にするための手続きは用意してあるか。  
```  
