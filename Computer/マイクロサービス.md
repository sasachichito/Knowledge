# マイクロサービスアーキテクチャ   
### マイクロサービスとは  
マイクロサービスは小さく、かつ一つの役割に専念する。  
ここにはオブジェクト指向の単一責任原則が当てはまる。  
どの程度を小さいとするかについてオーストラリア Jon Eavesは「2週間で書き直せるもの」と特徴付けた。  
  
マイクロサービス は銀の弾丸ではないし、金のハンマーでもない。  
銀の弾丸... 必ず効果のある手法  
金のハンマー... 気に入った方法が、あらゆるところで利用できると思い込むアンチパターン  
  
### マイクロサービスの統合  
##### ・原則  
個々のマイクロサービスは高凝集性・疎結合であり、「破壊的変更」が起きない。  
「破壊的変更」... マイクロサービスを変更するとコンシューマ側も変更を余儀なくされること。  
  
##### ・共有データベースを避ける  
マイクロサービス側がデータの持ち方を変えるだけでコンシューマ側も変更が必要になることを防ぐ。  
  
##### ・APIを非技術依存にする  
RPCでは特定のプラットフォーム上でしか動かない。またJava RMIなどではサーバー側の変更でコンシューマ側のスタブを更新する必要があり破壊的変更を避けれれない。  
またRPCではコンシューマがリモート呼び出しを把握しにくく、ネットワーク障害に対する準備がおろそかになることがある。  
  
##### ・オーケストレーションではなくコレオグラフィにする  
個々のマイクロサービスをまたがるビジネスプロセスの実装方式はコレオグラフィにすること。  
オーケストレーション... 起点となるマイクロサービスが、必要となる別サービスのAPI呼び出しを行う方式  
コレオグラフィ... 起点となるマイクロサービスが発行したイベントを、別サービスが検知する方式  
オーケストレーションシステムでは起点のマイクロサービス が「神」サービスとなり、貧血症の別サービスを呼び出す形になってしまう。  
コレオグラフィシステムではそれを避けるが、正しく処理が行われたか追跡する必要がある。それ専用の監視システムを構築すると良い。  
  
##### ・ハイパーメディアコントロールを利用する  
ショッピングサイトがカート画面を刷新してURIが変更されたとしても、ユーザーが画面上からカートにアクセスできるように、  
コンシューマに対してハイパーメディア（他のコンテンツへのリンクを含むコンテンツ）を返却し、  
コンシューマは目的の処理をリンクにアクセスするだけで実行できる状態にすることで、破壊的変更を防ぐ。  
  
##### ・状態マシン（状態と振る舞いを持つ）サービスにする  
保持するデータに関する判断、加工処理ロジックをサービスに閉じ込めること。  
そうすることで複数のコンシューマにロジックが流出することを防ぎ、強い凝集性を保てる。  
当然ながらロジックの変更も容易となる。  
  
##### ・破壊的フェイルオーバー（Martin Fowler）  
MQを利用するシステムで、特定メッセージを処理するとワーカーかダウンする不具合があった。  
ダウンするとフェイルオーバーにより特定メッセージが再びMQに戻され、全ワーカーがダウンするまで続くことを破壊的フェイルオーバーという。  
適切にリトライ回数を定めること。またメッセージ病院を用意し、リトライでも失敗したメッセージを追跡できるようにすること。  
  
##### ・耐性のあるリーダーパターン（Martin Fowler）  
サービスに問い合わせた結果をバインディングする技術を選ぶ時、コンシューマーが必要とするデータ以外の全てをバインドしようとするものを避けること。  
コンシューマー側は必要なカラム名を知っていて、XMLのXPathのように柔軟に取得できるようにしておくこと。  
そうすることでサービス側が返答するデータの内容や形式の変更が、破壊的変更になることを防ぐ。  
  
##### ・セマンティックバージョニングにする  
バージョン番号をMAJOR.MINOR.PATCHとして定義し、破壊的変更を検知できるようにする。  
  
##### ・異なるエンドポイントの共存  
破壊的変更を行うとき、変更後のエンドポイントと変更前のエンドポイントの両方を公開する方法。  
コンシューマーが変更前のエンドポイントを使用しなくなったらコードを削除する。  
別バージョンのマイクロサービスを共存させる方法もあるがアンチパターンである。なぜならミドルウェアが  
コンシューマを適切なマイクロサービスを利用させる知識を持たなければならず動作保証が難しくなる。  
  
##### ・API合成（ユーザーインターフェース）  
クライアントサイドアプリケーション（JavaScript)が複数のマイクロサービスを呼び出して画面を構成する。  
欠点が2つあり、1つはデバイスの種類ごとにレスポンスを調整できないこと。（マイクロサービス側がわざわざレスポンスを加工するしかない）  
もう1つはクライアントサイドアプリケーションを構築する人がいないこと。（UIの作り手が複数のマイクロサービスとの調整しなければならない）  
  
##### ・UI部品合成（ユーザーインターフェース）  
ユーザーインターフェースをマイクロサービスが提供する。  
欠点が2つあり、1つは個々のUIの見た目が違ってシームレスで無くなってしまう。  
もう1つはデバイスの種類ごとにレスポンスを調整できないこと。  
  
##### ・BFF（ユーザーインターフェース）（API合成の進化系）  
API合成の欠点の1つ、デバイスの種類ごとにレスポンスを調整できないことを克服する。  
APIゲートウェイを用意すればデバイスの種類ごとにレスポンスを調整できるが、様々なマイクロサービスの変更を検知し修正する必要が出てしまう。  
そこでマイクロサービスごとにフロントエンド用のバックエンドを用意することで上記を避け、かつレスポンスを調整する。  
  
##### ・ハイブリッド手法（ユーザーインターフェース）  
UI部品合成とBFFの両方を用いる方法。  
  
##### ・ストラングラー（絞め殺し）パターン  
レガシーシステムからマイクロサービスに移行するとき、リクエストの一部を徐々にマイクロサービスに移行させることでビックバンリリースを防ぐ。  
  
  
  
# プロダクションレディマイクロサービス  
### マイクロサービスエコシステム  
マイクロサービスが正しく稼働し続ける環境（エコシステム）は4つのレイヤで構成される  
```
レイヤ1：ハードウェアレイヤ  
レイヤ2：通信  
レイヤ3：マイクロサービスプラットフォーム  
レイヤ4：マイクロサービス   
```

```
レイヤ1：物理サーバ、データベース、OS、リソース分離（仮想化・抽象化レイヤ）、構成管理、ホストレベルの監視、ホストレベルのロギング  
レイヤ2：ネットワーク、DNS、RPC、エンドポイント、メッセージング、サービス検出、サービスレジストリ、負荷分散  
レイヤ3：セルフサービス内部ツール、開発環境、テスト/パッケージング/ビルド/リリース用ツール、デプロイパイプライン、マイクロサービスのロギング、マイクロサービスレベルの監視  
レイヤ4：マイクロサービス、マイクロサービス固有の構成情報  
```

上位のレイヤの仕事をするエンジニアが、自分よりも下のレイヤの何かを設定、構成、利用しなければならないときは、そのエンジニアが使えるセルフサービスツールを用意すること。  
そうしなければ他のレイヤについてのエキスパートになることを求められ、大抵ミスが多発する。  
エキスパートでなくても利用できるようなUIを提供すること。  
  
マイクロサービス固有の構成情報（chefの設定、サーバー台数、デプロイツールの指定）などはマイクロサービス側（ソースコードの一部）に持つこと。  
そうしなければ何百ものマイクロサービス 固有の設定を下位レイヤが保持しなければならなくなる。  
  
### マイクロサービスのメリット  
スケーラビリティ（スケールアウトのしやすさ）  
処理効率（必要な機能を必要なだけスケールアウト・アップできる）  
開発効率（独立したデプロイ、機能追加のしやすさ）  
新テクノロジーへの対応  
  
### ・マイクロサービスのデメリット  
逆コンウェイの法則によるチーム孤立化（システム全体像を把握できる人が少なくなる）  
技術的スプロール（個々のマイクロサービスエコシステムが乱立する、開発スピードの速さから技術的負債が増える）  
障害の種類の増加  
リソースの奪い合い  
