
### ソフトウェアのドメインとは
ソフトウェアの動作に影響する事象

### モデルとは
知識を表現するもの

### ドキュメントの必要性
システムの進化に伴いメンテナンスが必要なドキュメントは不要である。  
ソースコードが仕様書となるべき。  

### ユビキタス言語
ビジネス側と開発側で統一された言語

### レイヤ化アーキテクチャ
ドメインをソフトウェアの事情から切り離し、ビジネスロジックに専念させるための考え方。  

# ドメインのモデルを作る
### モデル駆動設計とは
ドメインエキスパートがビジネス目線でドメインを分析し、ソフトウェアで果たす役割を考慮していない分析モデルが作成される。  
分析モデルには設計や実装をし始めてようやく発見できる重大な課題・問題は含まれない。  
そのため開発者は分析モデルとは別でシステムを設計する。  
この分析モデルと設計の2分法を捨て、分析・設計の両方に使える単一のモデルを探し出すことをモデル駆動設計という。  

### ブレインストーミングで知識を噛み砕き、クラス図に落とし込む
クラス図でなくても、ソースコードの仕様が決まるレベルにする。

### 根底のモデルは一つだけ
設計・実装・チームでのコミュニケーション等の根底にあるモデルは一つだけ。  
それぞれで説明用のモデルを用いることは正しい。  

### 関連を扱いやすくする
モデル（クラス図）の関連の実装方法は複数ある。  
関連オブジェクトをプロパティに持ったり、データベースアクセスをラップして動的に取得したりなど。  
これでは良いモデルではないので、以下を実施する。  
- 関連を辿る方向を強制する  
- 限定子を付加して多重度を減らす  
- 本質的でない関連を除去する  

### モジュール（パッケージ）を適切にする
クラスと同じように、モジュール構成のリファクタリングを続けることが大事。  
モジュール名はユビキタス言語からなる。  

## モデルを構成する3種類の要素(ドメインオブジェクト)
### ・エンティティ（別名：参照オブジェクト）
連続性（ライフサイクル）と同一性（一意性）持つオブジェクト
- 責務  
  - エンティティを識別する手段の提供  
  - 各ライフサイクルにおける振る舞いの提供  

### ・値オブジェクト（Value Object）
値を保持し、操作を提供するオブジェクト
- 責務  
  - 値の操作方法の提供  
  - 値の不変性の約束  

※値オブジェクトか？エンティティか？  
モデルの属性だけがドメインであれば値オブジェクトになる。  
モデルの存在（同モデルの他インスタンスとの関係）がドメインであればエンティティになる。  

※値オブジェクト同士で双方向の関連を持つことはない。  
そもそも双方向の関連は、関連オブジェクト同士でメッセージを交換しあえる意味がある。  
そのため相手が自分のポインタを持つ特定の状態のオブジェクトでなければならない場合に有効になる。  
特定の状態を持つオブジェクトは、エンティティとなる。  
値オブジェクトでは特定の状態を持たないので、メッセージを送りたければ動的に取得すれば良い。  
双方向の関連はモデル化の段階で除去すること。  

### ・サービス（Service)
ドメインにおける重要なプロセスや変換処理が、エンティティや値オブジェクトの自然な責務にならない場合に  
モデルに追加されるインターフェース。  
- 責務  
  - 操作に状態がない  
  - 操作名がユビキタス言語の一部になること  

※サービスを各レイヤに分割する  
細粒度のドメインオブジェクトを作り上げていくと、その振る舞いが組み合わさる場所がアプリケーション層になり、  
ドメイン層からアプリケーション層へ知識が流出してしまう。  
サービス（ドメインサービス）を慎重に導入し、それを防ぐことが必要。  
- アプリケーション層のサービス  
ユーザーインターフェースからの入力を受け付ける。  
ドメインサービスにメッセージを送信する。  
インフラストラクチャサービスにメッセージを送信する。  
- ドメインサービス  
エンティティや値オブジェクトをまとめ上げて処理を行う。  
- インフラストラクチャサービス  
記録や通知の仕組みを提供する。  
ビジネスロジックを一切含まない。  

## ドメインオブジェクトのライフサイクルの課題を解決する
- 課題  
  - 1.ライフサイクルを通じて整合性（不変条件）を維持すること  
  - 2.ライフサイクルの管理の複雑さからモデルを切り離すこと  

**※不変条件とは**  
モデルが責務を全うするために必要な正しい状態を保つための条件。  
複雑な関連を伴うモデルでは個々のモデルだけではなく関連するオブジェクトのグループに対して不変条件があり、  
これが適切でないとそのグループは整合性を保てない。  

これら2つの課題を3つのパターンを用いて解決する。  

### ・集約(Aggregates)
集約とは関連するオブジェクトの集まりのこと。  
不変条件を持つドメインオブジェクトグループに対する呼び方であり、実装方法が決まっている。  
課題１を解決する。  
##### 集約はルートと境界を持つ。
- ルート  
集約に含まれている特定の一つのエンティティ  
- 境界  
集約の中身の定義  

外部のオブジェクトが参照して良いのはルートだけ。  
境界内のルート以外のエンティティの同一性は集約内部だけで保たれれば良い。  
自動車の例）  
自動車を一意に識別する識別子がある。  
タイヤの走行距離と摩耗度の測定のため各タイヤに識別子を持たせる。  
特定の自動車をシステムに問い合わせ、装着しているタイヤを参照することはあるが、  
特定のタイヤをシステムに問い合わせ、それがどの自動車に装着されているか調べる人はいないし、  
タイヤが交換され自動車を離れた後、同種のタイヤの山の中で同一性を保つ必要はない。  
この場合、自動車エンティティがルートになり、境界は自動車エンティティとタイヤエンティティとなる。  

##### 集約の不変条件
不変条件を満たした状態を維持する集約の実装方法
```
・ 集約のルートエンティティは、グローバルな同一性を持ち、不変条件をチェックする最終的な責務を負う。
・ ルートエンティティはグローバルな同一性を持つ。境界内部のエンティティは、集約内でのみ一意となるローカルな同一性を持つ。
・ 集約の境界外にあるオブジェクトは、ルートエンティティを除き、境界内部への参照を保持することができない。ルートエンティティは内部のエンティティへの参照を他のオブジェクトに渡せるが
  受け取ったオブジェクトは参照を一時的に使用することができるだけで、その参照を保持してはならない。ルートは値オブジェクトのコピーを別のオブジェクトに渡すこともあるが、
  その場合はそのコピーがどうなってもよい。渡されるのは単なる値で、集約とは何の関連もなくなるからである。
・ 前述のルールの必然的結果として、データベースに問い合わせて直接取得できるのは、集約ルートだけとなる。それ以外のオブジェクトはすべて、関連を辿ることで取得しなければならない。
・ 集約内部のオブジェクトは、他の集約ルートへの参照を保持することができる。
・ 削除の操作は、集約境界の内部に存在するあらゆるものを一度に削除しなければならない
 （ガベージコレクションがあれば簡単である。ルート以外に対しては、外部から参照されていないので、ルートを削除した際に、他もすべてガベージコレクションすればよい）。
・ 集約境界の内部に存在するオブジェクトに対する変更がコミットされる時には、集約全体の不変条件がすべて満たされていなければならない。

Eric Evans. エリック・エヴァンスのドメイン駆動設計 (Kindle の位置No.3141-3143). 翔泳社. Kindle 版. 
```
一つの集約内のデータに変更があったとき不変条件は、トランザクションの完了時に満たされることを強制する。  
不変条件が複数の集約にまたがる場合は一時的に不変条件を満たさないタイミングがあるが、バッチ等で一定時間内に解消する。  

### ・ファクトリ（Factories）
3種類のドメインオブジェクトそれぞれが持つ責務の中に自身のオブジェクト作成は含まれない。  
そのためドメイン層にはドメインオブジェクトに加え、ドメインオブジェクト作成を担当する要素（ファクトリ）が追加される。  
課題2を解決する。  

##### ファクトリのデザインパターン  
ファクトリメソッド  
抽象ファクトリ  
ビルダ  

##### ファクトリの実現方法  
1. 集約のルートにファクトリメソッドを定義する  
2. 生成対象に渡すパラメータを持つ別境界のドメインオブジェクトにファクトリメソッドを定義する  
3. 専用のファクトリオブジェクトかサービスを新規に作成する  

※1→2→3の優先順  

##### 優れたファクトリの条件
- ファクトリが生成するドメインオブジェクトはその必ず不変条件を満たした状態で作成される。  
不変条件を満たせない場合は例外をスローしたりnullを返却するなどのコーディング規約に従った動作をする。　　
- ファクトリは生成される具象クラスに応じてではなく、要求される型に応じて抽象化されていること。？（洗練されたファクトリパターンが役立つらしい。集約ごとに用意されているということ？)   
- ファクトリは引数を単純に使うこと。引数を生成物に設定するだけが理想であり引数はオブジェクトでも良い。  

##### ファクトリが不要な場合
クラスコンストラクタでインスタンス生成する方が良い場合がある。  
1. 構造が簡単なドメインオブジェクト  
2. クラスが型（type)?(どういうこと？)  

※コンストラクタの中で他のクラスのコンストラクタを呼び出す場合は複雑となるため素直にファクトリを用意する。  

##### ファクトリは生成だけでなく再構成も担う  
ファクトリで担う再構成の責務は、与えられた引数からドメインオブジェクトを生成し返却することである。  

### ・リポジトリ（Repositories)  
ドメインオブジェクトのストレージへの移動、ストレージからの移動（再構成）を担うドメイン層の要素。  
クライアントに、すでに存在するドメインオブジェクトの参照を手に入れる手段を提供する。  
課題2を解決する。  

##### リポジトリの責務
- ストレージ（DB等）への問い合わせの技術をカプセル化する  
- 不変条件を満たしたドメインオブジェクトを再構成する  
- ストレージ上での集約のルート以外へのグローバルアクセスを防ぐ。















