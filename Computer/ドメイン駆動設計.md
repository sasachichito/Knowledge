
### ソフトウェアのドメインとは
ソフトウェアの動作に影響する事象

### モデルとは
知識を表現するもの

### ドキュメントの必要性
システムの進化に伴いメンテナンスが必要なドキュメントは不要である。  
ソースコードが仕様書となるべき。  

### ユビキタス言語
ビジネス側と開発側で統一された言語

### レイヤ化アーキテクチャ
ドメインをソフトウェアの事情から切り離し、ビジネスロジックに専念させるための考え方。  

# ドメインのモデルを作る
### モデル駆動設計とは
ドメインエキスパートがビジネス目線でドメインを分析し、ソフトウェアで果たす役割を考慮していない分析モデルが作成される。  
分析モデルには設計や実装をし始めてようやく発見できる重大な課題・問題は含まれない。  
そのため開発者は分析モデルとは別でシステムを設計する。  
この分析モデルと設計の2分法を捨て、分析・設計の両方に使える単一のモデルを探し出すことをモデル駆動設計という。  

### ブレインストーミングで知識を噛み砕き、クラス図に落とし込む
クラス図でなくても、ソースコードの仕様が決まるレベルにする。

### 根底のモデルは一つだけ
設計・実装・チームでのコミュニケーション等の根底にあるモデルは一つだけ。  
それぞれで説明用のモデルを用いることは正しい。  

### 関連を扱いやすくする
モデル（クラス図）の関連の実装方法は複数ある。  
関連オブジェクトをプロパティに持ったり、データベースアクセスをラップして動的に取得したりなど。  
これでは良いモデルではないので、以下を実施する。  
- 関連を辿る方向を強制する  
- 限定子を付加して多重度を減らす  
- 本質的でない関連を除去する  

### モジュール（パッケージ）を適切にする
クラスと同じように、モジュール構成のリファクタリングを続けることが大事。  
モジュール名はユビキタス言語からなる。  

## モデルを構成する3種類の要素(ドメインオブジェクト)
### エンティティ（別名：参照オブジェクト）
連続性（ライフサイクル）と同一性（一意性）持つオブジェクト
- 責務  
  - エンティティを識別する手段の提供  
  - 各ライフサイクルにおける振る舞いの提供  

### 値オブジェクト（Value Object）
値を保持し、操作を提供するオブジェクト
- 責務  
  - 値の操作方法の提供  
  - 値の不変性の約束  

※値オブジェクトか？エンティティか？  
モデルの属性だけがドメインであれば値オブジェクトになる。  
モデルの存在（同モデルの他インスタンスとの関係）がドメインであればエンティティになる。  

※値オブジェクト同士で双方向の関連を持つことはない。  
そもそも双方向の関連は、関連オブジェクト同士でメッセージを交換しあえる意味がある。  
そのため相手が自分のポインタを持つ特定の状態のオブジェクトでなければならない場合に有効になる。  
特定の状態を持つオブジェクトは、エンティティとなる。  
値オブジェクトでは特定の状態を持たないので、メッセージを送りたければ動的に取得すれば良い。  
双方向の関連はモデル化の段階で除去すること。  

### サービス（Service)
ドメインにおける重要なプロセスや変換処理が、エンティティや値オブジェクトの自然な責務にならない場合に  
モデルに追加されるインターフェース。  
- 責務  
  - 操作に状態がない  
  - 操作名がユビキタス言語の一部になること  

※サービスを各レイヤに分割する  
細粒度のドメインオブジェクトを作り上げていくと、その振る舞いが組み合わさる場所がアプリケーション層になり、  
ドメイン層からアプリケーション層へ知識が流出してしまう。  
サービス（ドメインサービス）を慎重に導入し、それを防ぐことが必要。  
- アプリケーション層のサービス  
ユーザーインターフェースからの入力を受け付ける。  
ドメインサービスにメッセージを送信する。  
インフラストラクチャサービスにメッセージを送信する。  
- ドメインサービス  
エンティティや値オブジェクトをまとめ上げて処理を行う。  
- インフラストラクチャサービス  
記録や通知の仕組みを提供する。  
ビジネスロジックを一切含まない。  

## ドメインオブジェクトのライフサイクルの課題を解決する
- 課題  
  - 1.ライフサイクルを通じて整合性（不変条件）を維持すること  
  - 2.ライフサイクルの管理の複雑さからモデルを切り離すこと  

##### ※不変条件とは  
モデルが責務を全うするために必要な正しい状態。  
複雑な関連を伴うモデルでは個々のモデルだけではなく関連するオブジェクトのグループに対して不変条件があり、  
これが適切でないとそのグループは整合性を保てない。  

これら2つの課題を3つのパターンを用いて解決する。  

### 集約(Aggregates)
集約とは関連するオブジェクトの集まりのこと。  
##### 集約はルートと境界を持つ。
- ルート  
集約に含まれている特定の一つのエンティティ  
- 境界  
集約の中身の定義  

外部のオブジェクトが参照して良いのはルートだけ。  
境界内のルート以外のエンティティの同一性は集約内部だけで保たれれば良い。  
自動車の例）  
自動車を一意に識別する識別子がある。  
タイヤの走行距離と摩耗度の測定のため各タイヤに識別子を持たせる。  
特定の自動車をシステムに問い合わせ、装着しているタイヤを参照することはあるが、  
特定のタイヤをシステムに問い合わせ、それがどの自動車に装着されているか調べる人はいないし、  
タイヤが交換され自動車を離れた後、同種のタイヤの山の中で同一性を保つ必要はない。  
この場合、自動車エンティティがルートになり、境界は自動車エンティティとタイヤエンティティとなる。  

##### 集約の不変条件
一つの集約内のデータに変更があったとき不変条件はトランザクションの完了時に強制する。  
不変条件が複数の集約にまたがる場合は一時的に不変条件を満たさないタイミングがあるが、バッチ等で一定時間内に解消する。  







