# エリック・エヴァンスのドメイン駆動設計  
  
### ソフトウェアのドメインとは  
ソフトウェア（システム）の動作に影響する事象  
ソフトウェア（システム）になるもの  
ソフトウェア（システム）を使った事業  
  
### モデルとは  
知識を表現するもの  
  
### ドキュメントの必要性  
システムの進化に伴いメンテナンスが必要なドキュメントは不要である。  
ソースコードが仕様書となるべき。  
  
### ユビキタス言語  
ビジネス側と開発側で統一された言語  
  
### レイヤ化アーキテクチャ  
ドメインをソフトウェアの事情から切り離し、ビジネスロジックに専念させるための考え方。  
  
# ドメインのモデルを作る  
### モデル駆動設計とは  
ドメインエキスパートがビジネス目線でドメインを分析し、ソフトウェアで果たす役割を考慮していない分析モデルが作成される。  
分析モデルには設計や実装をし始めてようやく発見できる重大な課題・問題は含まれない。  
そのため開発者は分析モデルとは別でシステムを設計する。    
この分析モデルと設計の2分法を捨て、分析・設計の両方に使える単一のモデルを探し出すことをモデル駆動設計という。  
  
### ブレインストーミングで知識を噛み砕き、クラス図に落とし込む  
クラス図でなくても、ソースコードの仕様が決まるレベルにする。  
  
### 根底のモデルは一つだけ  
設計・実装・チームでのコミュニケーション等の根底にあるモデルは一つだけ。  
それぞれで説明用のモデルを用いることは正しい。  
  
### 関連を扱いやすくする  
モデル（クラス図）の関連の実装方法は複数ある。  
関連オブジェクトをプロパティに持ったり、データベースアクセスをラップして動的に取得したりなど。  
これでは良いモデルではないので、以下を実施する。  
- 関連を辿る方向を強制する  
- 限定子を付加して多重度を減らす  
- 本質的でない関連を除去する  
  
### モジュール（パッケージ）を適切にする  
クラスと同じように、モジュール構成のリファクタリングを続けることが大事。  
モジュール名はユビキタス言語からなる。  
  
# モデルを構成する3種類の要素(ドメインオブジェクト)  
## ・エンティティ（別名：参照オブジェクト）  
連続性（ライフサイクル）と同一性（一意性）持つオブジェクト  
- 責務  
  - エンティティを識別する手段の提供  
  - 各ライフサイクルにおける振る舞いの提供  
  
## ・値オブジェクト（Value Object）  
値を保持し、操作を提供するオブジェクト  
- 責務  
  - 値の操作方法の提供  
  - 値の不変性の約束  
  
※値オブジェクトか？エンティティか？  
モデルの属性だけがドメインであれば値オブジェクトになる。  
モデルの存在（同モデルの他インスタンスとの関係）がドメインであればエンティティになる。  
  
※値オブジェクト同士で双方向の関連を持つことはない。  
そもそも双方向の関連は、関連オブジェクト同士でメッセージを交換しあえる意味がある。  
そのため相手が自分のポインタを持つ特定の状態のオブジェクトでなければならない場合に有効になる。  
特定の状態を持つオブジェクトは、エンティティとなる。  
値オブジェクトでは特定の状態を持たないので、メッセージを送りたければ動的に取得すれば良い。  
双方向の関連はモデル化の段階で除去すること。  
  
## ・サービス（Service)  
ドメインにおける重要なプロセスや変換処理が、エンティティや値オブジェクトの自然な責務にならない場合に  
モデルに追加されるインターフェース。  
- 責務  
  - 操作に状態がない  
  - 操作名がユビキタス言語の一部になること  
  
※サービスを各レイヤに分割する  
細粒度のドメインオブジェクトを作り上げていくと、その振る舞いが組み合わさる場所がアプリケーション層になり、  
ドメイン層からアプリケーション層へ知識が流出してしまう。  
サービス（ドメインサービス）を慎重に導入し、それを防ぐことが必要。  
- アプリケーション層のサービス  
ユーザーインターフェースからの入力を受け付ける。  
ドメインサービスにメッセージを送信する。  
インフラストラクチャサービスにメッセージを送信する。  
- ドメインサービス  
エンティティや値オブジェクトをまとめ上げて処理を行う。  
- インフラストラクチャサービス  
記録や通知の仕組みを提供する。  
ビジネスロジックを一切含まない。  
  
# ドメインオブジェクトのライフサイクルの課題を解決する  
- 課題  
  - 1.ライフサイクルを通じて整合性（不変条件）を維持すること  
  - 2.ライフサイクルの管理の複雑さからモデルを切り離すこと  
  
**※不変条件とは**  
モデルが責務を全うするために必要な正しい状態を保つための条件。  
複雑な関連を伴うモデルでは個々のモデルだけではなく関連するオブジェクトのグループに対して不変条件があり、    
これが適切でないとそのグループは整合性を保てない。    
  
これら2つの課題を3つのパターンを用いて解決する。  
  
## ・集約(Aggregates)  
集約とは関連するオブジェクトの集まりのこと。  
不変条件を持つドメインオブジェクトグループに対する呼び方であり、実装方法が決まっている。  
課題１を解決する。  
##### 集約はルートと境界を持つ。  
- ルート    
集約に含まれている特定の一つのエンティティ    
- 境界    
集約の中身の定義  
  
外部のオブジェクトが参照して良いのはルートだけ。  
境界内のルート以外のエンティティの同一性は集約内部だけで保たれれば良い。  
自動車の例）  
自動車を一意に識別する識別子がある。  
タイヤの走行距離と摩耗度の測定のため各タイヤに識別子を持たせる。  
特定の自動車をシステムに問い合わせ、装着しているタイヤを参照することはあるが、  
特定のタイヤをシステムに問い合わせ、それがどの自動車に装着されているか調べる人はいないし、  
タイヤが交換され自動車を離れた後、同種のタイヤの山の中で同一性を保つ必要はない。  
この場合、自動車エンティティがルートになり、境界は自動車エンティティとタイヤエンティティとなる。  
  
##### 集約の不変条件  
不変条件を満たした状態を維持する集約の実装方法  
```  
・ 集約のルートエンティティは、グローバルな同一性を持ち、不変条件をチェックする最終的な責務を負う。  
・ ルートエンティティはグローバルな同一性を持つ。境界内部のエンティティは、集約内でのみ一意となるローカルな同一性を持つ。  
・ 集約の境界外にあるオブジェクトは、ルートエンティティを除き、境界内部への参照を保持することができない。ルートエンティティは内部のエンティティへの参照を他のオブジェクトに渡せるが  
  受け取ったオブジェクトは参照を一時的に使用することができるだけで、その参照を保持してはならない。ルートは値オブジェクトのコピーを別のオブジェクトに渡すこともあるが、  
  その場合はそのコピーがどうなってもよい。渡されるのは単なる値で、集約とは何の関連もなくなるからである。  
・ 前述のルールの必然的結果として、データベースに問い合わせて直接取得できるのは、集約ルートだけとなる。それ以外のオブジェクトはすべて、関連を辿ることで取得しなければならない。  
・ 集約内部のオブジェクトは、他の集約ルートへの参照を保持することができる。  
・ 削除の操作は、集約境界の内部に存在するあらゆるものを一度に削除しなければならない  
 （ガベージコレクションがあれば簡単である。ルート以外に対しては、外部から参照されていないので、ルートを削除した際に、他もすべてガベージコレクションすればよい）。  
・ 集約境界の内部に存在するオブジェクトに対する変更がコミットされる時には、集約全体の不変条件がすべて満たされていなければならない。  
  
Eric Evans. エリック・エヴァンスのドメイン駆動設計 (Kindle の位置No.3141-3143). 翔泳社. Kindle 版.   
```  
一つの集約内のデータに変更があったとき不変条件は、トランザクションの完了時に満たされることを強制する。  
不変条件が複数の集約にまたがる場合は一時的に不変条件を満たさないタイミングがあるが、バッチ等で一定時間内に解消する。  
  
## ・ファクトリ（Factories）  
3種類のドメインオブジェクトそれぞれが持つ責務の中に自身のオブジェクト作成は含まれない。  
そのためドメイン層にはドメインオブジェクトに加え、ドメインオブジェクト作成を担当する要素（ファクトリ）が追加される。    
課題2を解決する。  
  
##### ファクトリのデザインパターン  
ファクトリメソッド  
抽象ファクトリ  
ビルダ  
  
##### ファクトリの実現方法  
1. 集約のルートにファクトリメソッドを定義する  
2. 生成対象に渡すパラメータを持つ別境界のドメインオブジェクトにファクトリメソッドを定義する  
3. 専用のファクトリオブジェクトかサービスを新規に作成する  
  
※1→2→3の優先順  
  
##### 優れたファクトリの条件  
- ファクトリが生成するドメインオブジェクトはその必ず不変条件を満たした状態で作成される。  
不変条件を満たせない場合は例外をスローしたりnullを返却するなどのコーディング規約に従った動作をする。　　  
- 集約のルートの抽象クラスやインターフェースに対して１つのファクトリを用意する(?)  
- ファクトリは引数を単純に使うこと。引数を生成物に設定するだけが理想であり引数はオブジェクトでも良い。  
  
##### ファクトリが不要な場合  
クラスコンストラクタでインスタンス生成する方が良い場合がある。  
1. 構造が簡単なドメインオブジェクト  
2. 抽象化されていないクラス(?)  
  
※コンストラクタの中で他のクラスのコンストラクタを呼び出す場合は複雑となるため素直にファクトリを用意する。  
  
##### ファクトリは新規作成だけでなく再構成も担う  
ファクトリで担う再構成の責務は、与えられた引数からドメインオブジェクトを生成し返却することである。  
  
## ・リポジトリ（Repositories)    
ドメインオブジェクトのストレージへの移動、ストレージからの移動（再構成）を担うドメイン層の要素。  
クライアントに、すでに存在するドメインオブジェクトの参照を手に入れる手段を提供する。    
課題2を解決する。  
  
##### リポジトリの責務  
- 全ての集約のルートオブジェクトで構成されるコレクションがメモリ上にあると錯覚させること  
- ストレージ（DB等）への問い合わせの技術をカプセル化する(リポジトリとはユビキタス言語でやり取りする)  
- インスタンス化されたドメインオブジェクトか、ドメインオブジェクトのコレクションを返却するメソッドを提供する  
- ストレージ上での集約のルート以外へのグローバルアクセスを防ぐ  
  
##### リポジトリの利点  
- 永続化技術からドメインの設計を切り離せる  
- テスト用にダミー実装と切り替えることが容易になる  
  
##### リポジトリの内部動作  
- SQLを実行し結果セットをファクトリで再構成してクライアントに返却する  
- ORマッパーを使ってオブジェクトを取得して返却する  
  
##### リポジトリ実装時と注意点    
- 型を抽象化すること(?)  
集約のルートの抽象クラスやインターフェースに対して１つのリポジトリを用意する  
- カプセル化の利点を活かすこと    
SQLをDB実装に合わせて最適化したり、結果をキャッシュすることができることを意識しておく。  
- トランザクション制御はしない  
作業単位を知っているのはアプリケーション層かドメイン層なので、そちらに任せる。    
  

# メモ
```
第3部 より深い洞察へ向かうリファクタリング
【序章】
リファクタリングはコードの良し悪しが動機となることが多いが、ドメインについての洞察に基づくリファクタリングは重要になる。
・深いモデル
深いモデルは、ドメインエキスパートの主要な関心事と、それに最も深く関連した知識に関する明快な表現を提供する。
・発見のプロセス
抱えている問題に本当に合った設計を作り出すためには
まずはドメインと最も関連の深い、中心となる概念を捉えるモデルを発見する必要がある。これを第9章「暗黙的な概念を明示的にする」で扱う。
コードのリファクタリングが難しいとモデリングのプロセスが止まってしまう。
ソフトウェア開発者のためにソフトウェアを作成する方法が必要だ。これを第10章「しなやかな設計」で扱う。
見つけだした概念をモデルにする上で適切な方法を見つける必要がある。そこですでに使えるパターンがあるかもしれない。
これを第11章「アナリシスパターン」、第12章「デザインパターン」で扱う。
・ブレイクスルー
ドメイン駆動設計を行っていると、ソフトウェアを予想以上に表現力豊かで用途が多いものへと変える機会が訪れる。
これをブレイクスルーと呼ぶ。ブレイクスルーは前もって計画しておくことができないものだ。
第8章「ブレイクスルー」でその一例を紹介する。


【第8章 ブレイクスルー】
狙って起こるものではないから焦らずにコツコツのリファクタリングを行うこと。


【第9章 暗黙的な概念を明示的にする】
ドメインエキスパートの言葉をよく聞こう。
それほど明白ではない概念をモデル化する方法を学ぼう。これにより設計が鋭くなる。これには3つのカテゴリがある。
1 明示的な制約
ドメインオブジェクトの操作一つ一つに明示的な制約（ルール）があることはよくある。
操作メソッドの中にルールを記載すると、ルールが複雑になっていくと、ドメインオブジェクトの操作をルールが圧倒してしまう。
その制約を該当ドメインオブジェクトのプライベートなメソッドに適切な名前をつけて切り出すことで、わかりやすく、変更もしやすくなる。

2 ドメインオブジェクトとしてのプロセス
複雑なアルゴリズムを伴う手続きをプロセスと呼んでいる。
基本的にオブジェクトは手続きをカプセル化してくれるものである。
ドメインの中に登場するプロセスは、ドメインモデルとして設計しなければならない。（例えば輸送アプリケーションの経路選択プロセス）
そういう場合は、ドメインモデルの中に「〜サービス」クラスを用意することで、そういったプロセスがあることを言葉で明示的に表現しつつ、カプセル化できる。
また、プロセスの実行方法が複数あるときは、アルゴリズムをストラテジーパターンで実装する手段も考えられる。
プロセスの実装がドメインモデルに含まれるべきか、インフラストラクチャ層にあるべきかを判断するのは簡単で、
そのプロセスについてドメインエキスパートが話題にあげるかどうかである。

3 仕様
これはいわゆる仕様パターンである。
仕様が複数ある場合は、それぞれを仕様オブジェクトにするようだ。


【第10章 しなやかな設計】
オーバーエンジニアリング（必要以上の設計）だとクライアントが操作しきれない。
モデル駆動設計では、適度に厳密な設計スタイルが必要である。
開発者には2つの役割がある。1つがクライアント開発者である。クライアント開発者は設計の持つ能力を活用しながら、ドメインオブジェクトをアプリケーションコード
や他のドメインオブジェクトに織り込んでいく。
クライアント開発者は、疎結合した概念を最低限集めたものを柔軟に使用して、ドメインにおける幅広いシナリオを表現できる。
もう一方のモデル開発者にとっても、モデルは変更に強く、わかりやすいものでなくてはならない。
そういったしなやかな設計に貢献するパターンを紹介していく。

・意図の明白なインターフェース
ある開発者があるコンポーネント（オブジェクト）を使用するために、その実装についてじっくり考えなければならないのであれば、カプセル化の価値は失われる。
たまたま開発者の要求を満たしているからという理由で、コンポーネントが意図しない目的で利用されてしまうかもしれない。
さしあたりコードは動くかもしれないが、後ほど修正したときに不具合が発生することは明白である。
それゆえ：
　クラスと操作には、その効果と目的を記述する名前をつけ、その手段には言及しないこと。こうすることでクライアント開発者はインターフェースの内部を理解しなくて良くなる。
こうした名前にはユビキタス言語を用いること。

・副作用のない関数
操作はクエリとコマンドに分けられる。コマンドは更新処理であり、副作用を持つ。
更新処理が副作用を持つのは、メソッド呼び出しの深いネストにより意図しない更新処理が起こることがよくあるためである。
コマンドを使わないシステムはないが、副作用を防ぐために2つの手段がある。

・表明
契約による設計を使う。不変条件・事前条件・事後条件をユニットテストで表現しておく。
モデル図とソースコードコメントにその表記を加えること。

・概念の輪郭
機能を細かく切り刻んでメソッドにすれば、クライアントがそれを組み合わせることになる。
機能を大きくまとめてメソッドにすれば、クライアントの要求に合わず、機能が重複する。
概念的に意味のある機能の単位を見つけ出すこと。

・独立したクラス
独立したクラスとは、低結合を極限まで進めたものだ。

・閉じた操作
・宣言的な設計
・設計の宣言的スタイル

これらのパターンはモデルに適用していくものだが、モデルは巨大なため、簡単に適用できるものではない。まずは対象を決めなければならない。
より大きな設計を引き受けるに当たってのアプローチを2つ紹介する。どのようにパターンを適合させ、利用するかを説明する。

・サブドメインを切り取る
どのようにサブドメインを選択するかは第15章で議論する。

・可能な場合には、確立された形式主義を利用する

【第11章 アナリシスパターンを適用する】

【第12章 デザインパターンをモデルに関係づける】
・ストラテジーパターン
ストラテジーパターンを使うと、クライアントがどのストラテジーを使うのか知らなければならないが、
ユーザーが画面上などからストラテジーを選択しているのであれば区分オブジェクトにストラテジーの実装を埋め込んでおけば
アプリケーションコードでif文は必要ない。
クライアントが様々なストラテジークラスの存在（クラス名）を自然と理解できるようなモデルであればこのパターンを使う価値がある。
つまりストラテジーを使うクラスのクラス名やメソッド名に加えて、意味のレイヤをもう一つ追加しなければならない。

・コンポジットパターン

【第13章 より深い洞察へ向かうリファクタリング】

第4部
```

```
ドメイン＝論理モデルの集合

一つの論理モデル＝アプリケーションの用途の一つを実現する仕組み

コンテキスト＝論理モデルに統一性を与える条件の集合（コードの一部、チームでの作業、会話、資料）

論理モデルに統一性がある＝論理モデルを構成するユビキタス言語に一貫性がある状態

オブジェクトモデル（モデルオブジェクト）＝論理モデルをコードで表したもの

サブドメイン＝一つの論理モデル（アプリケーションの用途の一つ）

コアドメイン＝サブドメインの中で最も重要なもの。

汎用サブドメイン＝サブドメイン中のコアドメイン以外のもの。

複数の論理モデルに起因する問題（複数の論理モデルに基づくコードが組み合わされる問題）
→顧客への請求（論理）モデルと、ベンダーへの支払い（論理）モデルが一つの料金オブジェクトを使う。
発生する問題：「料金」というユビキタス言語に一貫性がない（請求するものなのか、支払うものなのか分からない）
原因1:もともと複数の論理モデルであるということを認識できていない
原因2:本来一つの論理モデルがチームが違う、コードベースが違う、データベースが違うことが原因で複数のコンテキストに適用され、複数の論理モデルとして認識される

境界づけられたコンテキスト＝複数の論理モデルに起因する問題を解決するための手法。サブドメイン（一つの論理モデル）に対して明示的に一つのコンテキストがあることを宣言することで、一つのチーム、一つのコード、一つのデータベースを割り当てて、論理モデルの統一性を保つことができる。
```
  
  
# 実践ドメイン駆動設計  
  
### ドメインエキスパート   
ドメインに関する深い業務知識を持つ人  
  
### 軽量DDD  
サブドメイン、境界づけられたコンテキスト、コンテキストマップ、ユビキタス言語を見つけていく戦略的設計を行わず、  
```ドメインオブジェクト ＋ 集約の概念 ＋ ファクトリ ＋ リポジトリ```  
を利用する戦術的アプローチのこと。良くない。  
  
### 境界づけられたコンテキスト  
ドメインモデル上の概念的な区切り。一つあるいは複数のサブドメインを含む。  
名前は「モデル名＋コンテキスト」になる。  
  
### コンテキストマップ  
境界づけられたコンテキストどうしの関連  
  
### ヘキサゴナルアーキテクチャ  
ドメインモデルにおける境界づけられたコンテキストの表現方法。  
サービス指向やマイクロサービスなどの様々なアーキテクチャに対応できる書き方。  
  
### ドメインモデル貧血症  
大半がpublicなゲッターセッターで、単に属性と値を保持するだけのオブジェクト  
  
### 貧血誘発性記憶喪失  
ドメインモデル貧血症によりコードから意図が読み取れない状態  
  
### 実装  
ユビキタス言語を用いたテスト駆動で開発し、ドメインエキスパートにレビューをもらう  
  
### ドメインとサブドメイン  
##### そもそもドメインとは？  
ドメイン（広義）=  組織が行う事業や、それを取り巻く世界。  
事業が市場（顧客）の定義し、プロダクトやサービスを販売する。  
様々な業務により事業は成り立つ。業務にはノウハウと物事の進め方がある。  
「どこかの組織のためのソフトウェアを作る = その組織のドメイン（事業を取り巻く世界）で作業する」  
  
##### サブドメインとは？  
ドメイン（組織が行う事業）を成り立たせる、一つの業務を指す。  
業務は「〇〇を〜〜する」と表現でき、〇〇がサブドメインとして取り上げられる。  
  
・なんで戦略的設計が大事？  
サブドメインがハッキリすることで、システムが大きな泥団子にならない。  
コアドメインなのか、他のサブドメインから利用される汎用ドメインとなるかハッキリさせることができる。  
  
サブドメインの種類  
  - コアドメイン...ドメインのコア  
  - 支援ドメイン...業務に不可欠だがコアドメインほどではない  
  - 汎用ドメイン...業務上で特別なことはしていないがドメインを支援している  
  
### ドメインは問題空間と解決空間を持つ  
- 問題空間  
解決すべきビジネス戦略上の課題。  
「問題空間を評価する」とは、その課題を浮き彫りにすること。  
評価した結果はドメインモデル上でサブドメインとして表現される。  
  
- 解決空間  
問題空間のソリューション。  
「解決空間を評価する」とは、問題空間をソフトウェアでどのように解決するかに注目すること。  
評価した結果はドメインモデル上で境界づけられたコンテキストとコンテキストマップして表現される。  
  
サブドメインと境界づけられたコンテキストを一対一で対応させることが望ましい。  
  
  
# メモ  
```  
・システム間連携パターンは4種類（書籍「Enterprise Integration Patterns」）  
データベース共有（Shared Database）  
ファイル転送（File Transfer）  
リモートメソッド呼び出し（Remote Method Invocation）  
メッセージング（Messaging）  
  
・腐敗防止層とは？  
下流の「境界づけられたコンテキスト」が、上流の「境界づけられたコンテキスト」からオブジェクトを受け取るときに用いる。  
上流では集約だったものも、下流で受け取るときは値オブジェクトにするべき。  
そうすることで下流に責務が流れ込まず、管理するオブジェクトの数も減るので扱いが楽になる。  
腐敗防止層の技術的な実装は、専用のアダプターと変換サービスの組み合わせになることが一般的。  
  
・自己カプセル化  
クラス内部からのアクセスもアクセサメソッド経由で行うこと  
アクセサメソッドにバリデーションチェック処理（ガード）を設定しておくことで、  
「契約による設計」における事前条件を満たしていることを確認している。（不正な値でればExceptionをスロー）  
エンティティでは「属性単位」「オブジェクト全体」「複数オブジェクト時」という3つの粒度に分けてバリデーションを管理する。  
「属性単位」はエンティティ生成時に自己カプセル化のガードで実装。  
「オブジェクト全体」は専用のバリデータクラスを生成し、「遅延バリデーション（可能な限り先送り）」を行う。  
「複数オブジェクト時」は集約のルートのEntityに対して、「遅延バリデーション（可能な限り先送り）」を行う。  
ドメインサービスで制御する場合は、エンティティがチェック可能なタイミングになったら、オブジェクト側からバリデーション可能な旨のイベントを  
サービス（クライアント）側へ通知して、チェックを実行。  
  
・ドメインサービスとは？  
ドメインオブジェクトの自然な責務にならない処理を持つ、ステートレスなオブジェクト。  
ドメインサービスの主な役割として、様々なエンティティや値オブジェクト、集約を利用して計算するビジネスルールが挙げられる。  
本来ドメインオブジェクトが持つべき責務がドメインサービスに染み出さないように注意すること。  
また、ドメインサービスの処理をアプリケーション層のサービスには書いてはいけない。  
アプリケーション層のサービスは、トランザクションやセキュリティといった、ドメインの外側の関心ごとの実装を受け持つ。  
集約の境界が他の集約のリポジトリを持つべきではないから、ドメインサービスに持たせる。  
アプリケーションサービスが、ユースケースを実現するために、複数あるいは別種類の集約どうしの連携を担当してはいけない。  
それはもはや業務ロジックであり、ドメインサービスが担当すべきだ。  
ドメインサービスは、複数の集約をリポジトリから取得でき、比較・計算・判断・加工処理を行える。  
アプリケーションサービスがプロパティの絞り込みで集約のコレクションをもらってデータとして出力したい場合は、業務ロジックを含まないし  
更新処理でもないのでコマンドモデルである集約を取得するのではなく、クエリーモデルを使うべきだ。  
クエリーモデルを取得する際に、SQL文で別種類の集約分のデータをJOINしてWHERE句でロジックを実現してはいけない。それはもはや業務ロジックである。  
このような場合は、ドメインサービスが各種類の集約のリポジトリを使って集約のコレクションを取得し、モデルのメソッドを使って判断・加工していく。  
そして結果を値オブジェクトで返却してもらう。  
クエリーモデルを使うのは、単一集約分のデータをプロパティで絞り込んで取得し、そのまま利用するだけ。  
ファクトリとしてのドメインサービスが存在するが、わかりやすくするために〜Factoryクラスを作った方が良い。  
  
・標準型・タイプコード・区分オブジェクト  
区分や種類を表すオブジェクトを指す。  
１グループの区分や種類に対して、〜タイプという値オブジェクトを一つ作成しても良いが  
シンプルさを求めてenumを使うことが推奨される  
  
・セパレートインターフェースとは？  
実装クラスとは別のパッケージでインターフェースを定義すること。  
依存関係逆転の原則で用いられる。  
ヘキサゴナルアーキテクチャのport&adapter層にあるリポジトリ実装の  
インターフェースをドメイン層に持たせているのもセパレートインターフェースである。  
実装の選択にはDIコンテナを使うと良い。  
  
・ドメインイベントとは？  
ドメインエキスパートが注目する出来事にフォーカスする。  
「〜する時に」「〜した場合に知らせて」などをイベントとして定義する。  
イベントの発行を「パブリッシャー」で行い、イベントの受信を「サブスクライバ」で行う。  
ドメインイベントクラスは不変クラスになる。  
パブリッシャーとサブスクライバが一つの境界づけられたコンテキスト内にある場合で、同期処理の場合オブザーバーパターンで実装する。  
別の境界づけられたコンテキストに別れている場合や、非同期処理の場合は、サブスクライバは自コンテキスト内のイベントストアにイベントを格納する。  
別コンテキストのイベント検知用クライアントが、イベントストアをポーリング(RESTfullAPI)して、イベントを受信する。  
非同期の場合、イベント発行側のコンテキストが「自立型のサービス」となるため、外部システムの影響を受けない良い設計となる。  
同じイベントを何度も受診しても問題ないように設計する。  
  
・認証アクセスコンテキストの「ユーザー」「ロール」からコラボレーションコンテキストの「コラボレーター」にはどう変換された？  
認証アクセスコンテキストにRESTfullAPIでデータを取得し、腐敗防止層を経て、ファクトリとしてのドメインサービスのメソッドから取得する。  
クライアント  
↓  
ここからドメイン層  
ドメインサービス(抽象)  
↓  
ここからport&adaptor層  
ドメインサービス(実装)  
↓  
アダプター(抽象)  
↓  
アダプター(実装)  
↓REST  
認証アクセスコンテキスト（公開ホスト）  
  
・ファクトリの場所、種類  
DDDでは集約を作成するファクトリを用意する。ファクトリの場所は  
1.集約ルートのコンストラクタ  
2.別の集約上のメソッド  
3.ドメインサービスクラス  
に作られる。ファクトリを使えば、処理中の通常のインスタンス化も、別の境界づけれたコンテキスト(公開ホスト)からのドメインモデル連携  
も同じように扱える。  
2.別の集約上のメソッド（いわゆるファクトリーメソッド）ではガードを入れることができる。  
ファクトリの種類はファクトリー、ファクトリーメソッド、アブストラクトファクトリー、ビルダーパターンが挙げられる。  
アブストラクトファクトリーパターンを用いるのは、クラス階層ができた場合である。どういう風に使うのか？  
値オブジェクトの生成にもファクトリが利用される。リポジトリと違ってファクトリの利用場所にシビアになる必要はない。  
それはインスタンスの生成自体に問題はなく、結局のところ集約が保存されるときに不変条件さえ満たしていればシステムは壊れないから。  
ファクトリは複雑なインスタンス生成処理をラップする目的であれば抽象化する必要はないが、  
別コンテキストや永続化層からデータを取得してインスタンス化する場合はインターフェースを定義し、port&adaper層に実装をおくべき。  
  
・リポジトリの実装  
・コレクション指向のリポジトリ  
すでにリポジトリに登録されている集約を変更しても保存し直す必要がない。  
そのためには裏側にある永続化メカニズムに、自身が管理する永続オブジェクトについて、その変更の履歴を  
暗黙のうちに追跡できる仕組みがなければならない。  
・永続指向のリポジトリ  
集約を変更した時にsave()のように明示的にコミットする必要がある。  
リポジトリのインターフェースは、その実装が永続指向になる前提で定義しておくべき。  
なぜなら永続指向→コレクション指向の差し替えは簡単だが、その逆はコレクション指向がトランザクション管理が前提にされていなかったせいで  
永続指向に切り替えたタイミングでトランザクション管理のための修正が必要になるからである。  
ドメインモデルの中で抽象化し、クラス階層ができると  
・何がダメになるのか？  
クライアントが実装クラスを知り、選択しなければならなくなる。  
・どうすれば良いのか？  
抽象化を行わず、標準型（区分オブジェクト）を使って、モデルのタイプによりif文で処理を分ける。  
ifがややこしくなってきたら、区分オブジェクトに振る舞いを持たせる。参考 https://www.slideshare.net/masuda220/ss-57352072  
標準型が合わない場合、ロールベースのインターフェースを使うこともできる。（実践ドメイン駆動設計を参照）  
ロールごとにインターフェースを用意し、その全てを実装したエンティティを、リポジトリから特定ロールを指定して取得し、そのロール型に格納する。  
あとはロールインターフェースのメソッドを実行する。  
リポジトリはアプリケーションサービスかドメインサービスにしか持たないこと。  
ある集約が別の集約のリポジトリを持ったりすると、どこで集約が取り出し、保存されたかわからなくなる。  
集約上のメソッドが別の集約のファクトリメソッドになっている場合、作成された別集約を保存するためにはその集約を一度呼び出し元に返却して、  
リポジトリに保存する。  
  
・実際にファクトリにはどのパターンが使われている？  
Collaboratorの場合、抽象クラスであるCollaboratorクラスに対して  
CollaboratorService(ドメインサービス、抽象クラス)を用意し各Collaborator実装クラスを生成しているので、ファクトリーパターンである。  
  
・CQRSとは？  
https://qiita.com/ledmonster/items/22b00c65208dffeff7e4  
メリットは、実装がわかりやすいこと。  
参照のために集約を構成する必要がなく。パフォーマンスが良いこと。  
コマンドモデルストアと、クエリモデルストアを必ず分ける必要はないと考える。  
単純にアプリケーション層のサービスクラスを参照系と更新系で分けるだけでも効果はある。  
  
・RabbitMQとは？   
https://qiita.com/gambaray/items/3cc02b419c860a96bc94  
AMQPについて http://labs.gree.jp/blog/2010/06/262/  
ExchangeListener  
ExchangePublisher  
  
  
・イベント駆動アーキテクチャとは？  
ドメインイベントを用いたアーキテクチャを指す。  
  
・イベントソージングとは？   
https://www.slideshare.net/shuheifujita90/ss-14294169  
  
・ドメイン駆動設計において、Batch、WebAPI、UIアプリはどういったパッケージ構成になるのか、commonの概念はどうなるのか  
特に決まりはない。commonはDDDにおいては共有カーネルと呼ばれる。  
  
・ファブリックとは？  
イベント駆動アーキテクチャで利用出来る、イベントストアの一種。  
マルチノードキャッシュとレプリケーション機能を提供するインメモリデータベースのことを指す。  
インメモリデータグリッドとも呼ばれ、分散同期処理をサポートする。  
製品としてはGemFireが挙げられる。  
キャッシュレベルおよびエントリレベルでのイベントの発生を自動的に通知する仕組み  
  
・CQRSの実装はどうなってる？  
更新系メソッドの戻り値はvoidとし、参照系メソッドを用意する。  
それぞれコマンド、クエリと呼ばれる。  
集約にはコマンドメソッドしかない。  
CQRSにおけるリポジトリにはいくつかのコマンドメソッドと、一つのクエリメソッド（集約の識別子から該当集約を取得）がある。  
CQRSにおけるリポジトリはクエリメソッド以外（別のプロパティによる絞り込みなど）で集約を取得してはいけない。  
このパターンの登場人物と流れは、  
・更新系の場合  
クライアント  
↓更新  
コマンドプロセッサ（アプリケーションサービス）  
↓呼び出し  
コマンドモデル（集約）  
↓更新・保存、クエリモデル（ドメインイベントとして）発行  
コマンドモデルストア  
↓  
イベントサブスクライバ  
↓クエリモデル保存  
クエリモデルストア（ビュー）  
・参照系の場合  
クライアント  
↓参照  
クエリプロセッサ（アプリケーションサービス）  
↓参照  
クエリモデルストア（ビュー）  
となる。  
クエリモデルストアのビューは、ユーザーインターフェースの表示形式毎に用意し、全行・全カラムを読み込んで利用する。  
あまりにもビューが増えすぎる場合はある程度まとめたビューにして、クエリのWHERE句で調整する。  
コマンドプロセッサは可能であれば1コマンド1クラス（専用方式）にすべき。  
対して1コマンドを1メソッドと捉え、1クラスにまとめる方式（分類方式）もある。  
専用方式コマンドプロセッサをイベントストアに格納しておき、非同期で検知クライアントシステム側で実行する方式（メッセージング方式）もある。  
コマンドモデルとクエリモデルの格納は同じトランザクションで行うこと。ストアが異なる場合でもグローバルトランザクションを利用すること。  
  
・エンティティ、値オブジェクトにインターフェースは必要か？  
エンティティ同士の比較がエンティティの識別子で行われるようにequalsとhashcodeをオーバーライドするため必要があり、  
識別子の取得やクローン取得処理なども実装されるべきなのでインターフェースを用意すべき。  
値オブジェクトについても、equalsは全プロパティが同じならtrueを返すようにしないといけないが、そこはLombokのアノテーションの方がシンプルで良い。  
  
・CQRS的に、リポジトリの実装は更新系と参照系の両方のメソッドを持って良い？  
リポジトリの存在意義はドメインモデルをメモリ上にあるかのように見せることなので、ここにCQRSは適用しないほうが混乱しない。  
  
・port&adapter層のパッケージの切り方  
明確な答えはなさそう。まずは目的で切って後は任意とする。/目的/{目的}/…/方法/詳細が良いと考える。  
目的…web(http)の実装、モデルの永続化と取り出し、メッセージングのやりとり、通知、イベント通知、腐敗防止層(ドメインサービスの実装)  
方法…VIEW、API、DB、ファイル、メモリ、MQ、KVS  
詳細…LevelDB、RabbitMQ、Redis  
詳細は、方法(DB・MQ・KVS等)の実装の種類ごとにクラスが必要な場合（専用パッケージが必要だったりドライバーを共有できないなど）に用いる。  
例）  
web/view  
web/api  
persistence/db  
persistence/file  
persistence/eventsourcing/db  
persistence/eventsourcing/db  
messaging/mq  
notification/mq  
event/db  
event/kvs  
domainservice/  
eventとeventsourcingの違いは、eventは永続化目的でないこと。だからpersistence配下のパッケージではない。  
  
・リポジトリ実装の選択タイミングは？  
アプリケーション初期化時。  
springの機能で、config等でDI対象の実装を選択する。  
  
・実装したいところ  
別コンテキストとのREST連携  
CQRSの実装(アプリケーションサービスクラスの分け）  
CQRSの実装(イベント駆動によるクエリーモデルの作成）  
イベント駆動(パブリッシャー・サブスクライバ連携)によるイベントストア格納  
別コンテキストのイベントストア検知クライアント  
腐敗防止層の実装  
区分オブジェクトによるポリモーフィズムの実現  
施策の優先度の実装  
コンフィグファイルによる複数実装のDI切り替え  
自前のではなくSpringBootのバリデーション機能を使う  
  
・実装してみた所感  
CQRSはアプリケーション層の中でcommandとqueryでパッケージを分けた。  
commandの方は専用コマンド方式でクラスを作って、queryは分類方式とするとわかりやすかった。  
クエリーモデルをドメイン層に配置する実装もネットにあったが、IDDD書籍ではクエリーモデルはデータモデルと断言しており  
ドメインモデルではないのでやめた。  
アプリケーション層のqueryパッケージには〜Serviceという抽象クラスを追加して、その実装はport&adapter層においた。  
こうすることでヘキサゴナルアーキテクチャにおいてcommandと比較すると、単純にdomain層をスキップした形になってスッキリする。  
  
  
  
・そもそも腐敗防止層の目的って？  
上流モジュールと下流モジュールの関係が顧客/提供者の場合、下流モジュールは上流モジュールのインターフェース(提供してくるデータ)でモデルに変換する変換層を持つ。  
上流モジュールが、下流モジュールの言うことを全く聞いてくれない場合（関係が順応者）に、  
下流モジュール側は変換層が必要とするインターフェースを用意し、上流モジュールのインターフェース(提供してくるデータ)をそれに合わせる腐敗防止層を持つ。  
  
・spring bootでドメイン駆動設計を実現する  
  
  
・イベントストアフラッシュのタイミングは？  
  
  
・サービス指向って具体的にどんな実装？  
  
  
・なぜエンティティを使う？  
データに着目したCRUDシステム  
  
  
・エンティティの識別子の生成タイミング  
早期生成…エンティティ生成時に識別子を割り当てる  
遅延生成…エンティティ永続化時に識別子を割り当てる  
早期生成ではUUIDや、oracleのシーケンス機能が使える（MySQLならそれを模した物を作る）  
遅延生成はAutoIncrementが使える  
  
・境界づけられたコンテキスト間の結合方法にデータベースを介する場合はあるのか？  
共有データベースがあっても良いが、それだけでコンテキスト間の結合度が高まってしまう。  
そのため共有DBがダウンしたり運用ミスがあったりすると両方のコンテキストが使えなくなる。  
また概念的にも、同じレコードが両コンテキストで別々のモデルになるので、混乱を招く。  
少なくともDBのインスタンスを分けるべきだし、コストが厳しければスキーマを分ける。  
正しい形は、片方のコンテキストが公開ホストになりRESTfullなAPIでアクセスしてデータをもらうか、  
メッセージングを使うの2択。  
  
・コンテキスト間の結合の基本  
情報のやり取りの仕方は2種類  
・プログラミング言語のシリアライズ  
これは関係するシステムが同じシリアライズ機能に対応していることが前提。  
結合するコンテキスト間で同じクラス・インターフェース定義を保持する必要があるため二重管理となり変更に弱い。  
・標準化された中間フォーマットの利用  
JSONやXMLを利用してデータを共有する。通信するデータ量が増え、オブジェクトに変換するコストが高い。  
また強い型付けによる安全性を優先して、結局のところ結合するコンテキスト間で同じクラス・インターフェースを保持する場合もある。  
共有カーネルを用いてコンテキスト間でソースコードを共有することで二重管理を避けることもできるが、変更管理が複雑になる。  
結局どの方法が良いか？  
標準化された中間フォーマットで、型を共有しない方法が最良。  
コンテキスト間でドメインモデルを共有するという考え方は間違っている。各コンテキストで最良のドメインモデルがあるべき。  
そのため中間フォーマットでやり取りするのはデータだけで、別コンテキストのモデルの振る舞いを使おうとするべきではない。  
何よりデータのみのやり取りの方が疎結合である。  
データからモデルへの変換はport&adapter層で行う。  
  
・RESTfullなAPIはどのように設計する？  
クライアント側は可能な限り自立できるように、APIサーバー側にアクセスできなくても障害とならないように設計する。  
  
・メッセージングはどのように設計する？  
通知するイベントに発生時刻を持たせて、順番を維持すること。  
  
・RESTfullAPIとメッセージングはどっちが良い？  
RESTは多数のコンシューマーが単一のプロデューサーの発行するイベントに関心がある（Observerパターン）時に利用し、  
その逆の場合で、コンシューマー側が複数のプロデューサーから所定の手順でリソースを取得しないとタスクを実行できない場合は、メッセージングを利用する。  
RESTはコンシューマーのことを考慮しないので、RESTが返却するデータはプロデューサー側の都合で変わっていく。  
そのためコンシューマーが必要とするデータが取得できない可能性がある。  
コンシューマー側がデータの消失を恐れ、処理手順を大事にしているならば、そのコンシューマー向けにデータを用意しメッセージングを利用すべきだ。  
逆にRESTは多数のコンシューマー向けの汎用的なデータを提供する。  
  
・なぜメッセージングはイベントストアをポーリングする？イベントストアを介さずにメッセージキューにパブリッシュしても良い？  
イベントストアがない場合、キューイングに失敗した時にイベントが消失してしまうためコンテキストの自立性が低下してしまう。  
  
・連携のデータ量が多い場合はどうする？  
共有DBでデータを共有する？でも共有DBが落ちた時、連携している二つのコンテキストでリカバリ作業が必要になる。  
キューでデータを連携する？でもキューのサイズに限度がある。  
ファイル連携？  
  
・別コンテキストに毎回RESTでアクセスすると時間がかかるが、どうすれば良い？  
非同期でコンテキスト内にデータを持ってくる。重複管理となるがトレードOFF。  
  
・識別子以外のプロパティで検索する場合、リポジトリを使わないならどうするのか？  
クエリモデルから直接SQLでデータを取得し、集約(コマンドモデル)を作る  
  
・長期プロセスとは？  
イベント駆動で分散システムで並列処理を行うパターン。サーガとも呼ばれる。  
イベントを発行すると、複数の別コンテキストのイベント検知クライアントが並行に処理し、その結果をイベント発行元のコンテキストに返却する。  
イベント発行元コンテキストは並行処理の結果を突き合わせて、結果を保存する。  
  
・集約について  
集約の目的…不変条件を満たすこと。  
不変条件は「トランザクション整合性」か「結果整合性」の2種類。  
「トランザクション整合性」… 一つのトランザクションで保持される不変条件。  
「結果整合性」… 遅延するが保持される不変条件。  
基本的に一つのトランザクションでは、一つの集約しか変更できない。（※目標にすべきルール）  
ここで守られる不変条件はトランザクション整合性のことである。またこれを満たすために一つの大きな集約が作られがちである。  
しかし大きな集約はパフォーマンスに影響が出るため、ドメインイベントを用いた結果整合性で「小さな集約」にすることを検討すべき。  
小さな集約を設計していくと複数の集約の依存関係を解決する必要が出てくる。  
集約の依存関係の解決方法は2つある。  
「切り離されたドメインモデル」… 集約が内部でリポジトリやドメインサービスを利用して全ての依存関係を解決するテクニック  
「アプリケーションサービスによる解決」… アプリケーションサービスが集約のメソッドを実行する前に依存オブジェクトを検索し、引数に渡して解決するテクニック。  
「切り離されたドメインモデル」では集約の振る舞いに自由度が増して複雑になりやすく、意図せず複数の集約を変更してしまう。  
「アプリケーションサービスによる解決」では上記を予防できるが、依存関係の解決が複雑でドメインに特化している場合がある。  
その時は集約のメソッド引数にドメインサービスを渡し、ダブルディスパッチする。  
  
・ドメインサービスの役目は？  
集約のメソッドを実行するための依存関係の解決が複雑な場合にその責務を負う。（ダブルディスパッチ）  
複数種類の集約を連携させた結果を知りたいときに、そのメソッドがどの集約にも持たせるべきではない場合にその責務を負う。  
ある集約の複数形の処理がアプリケーション層で管理するには複雑な場合で、その処理メソッドを該当集約に持たせるべきではない場合にその責務を負う。  
ドメインオブジェクトをインフラストラクチャ層を経由して生成する責務を負う。  
※基本的に一つの処理で更新される集約は一つなので、ドメインサービスで集約の永続化は行わず、永続化は最終的な結果を受け取ったアプリケーションサービスで行う。  
  
・そもそもドメインとは？  
ドメイン（広義）=  組織が行う事業や、それを取り巻く世界。  
事業が市場（顧客）の定義し、プロダクトやサービスを販売する。  
様々な業務により事業は成り立つ。業務にはノウハウと物事の進め方がある。  
「どこかの組織のためのソフトウェアを作る = その組織のドメイン（事業を取り巻く世界）で作業する」  
  
・サブドメインとは？  
ドメイン（組織が行う事業）を成り立たせる、一つの業務を指す。  
業務は「〇〇を〜〜する」と表現でき、〇〇がサブドメインとして取り上げられる。  
  
・なんで戦略的設計が大事？  
サブドメインがハッキリすることで、システムが大きな泥団子にならない。  
コアドメインなのか、他のサブドメインから利用される汎用ドメインとなるかハッキリさせることができる。  
  
・ドメインモデリング  
アナリシスパターン  
「知識レベル」と「操作レベル」に分ける  

ドメインモデル内のバリデーションは  
・個別の属性/プロパティ  
・オブジェクト全体(集約)  
・オブジェクト(集約)同士の合成  
の3つの視点がある。  
  
属性やプロパティ(値オブジェクト)のバリデーション方法  
→自己カプセル化  
  
オブジェクト全体(集約)のバリデーション方法  
→仕様クラス  
  
オブジェクト(集約)同士の合成  
→ドメインサービスで複数の集約のバリデーション結果を取りまとめる。  
バリデーション方法は仕様クラスを用いる。  
  
  
値オブジェクト...   
ドメイン内の何かを計測したり定量化したり、あるいは説明したりする。  
例）年齢はその人が生まれてから何年経ったかを計測して定量化したもの。  
例）名前はその人がなんと呼ばれているのか説明したもの。  
値オブジェクトは一つあるいは複数の属性を保持している。それらが関連することで値について説明している。  
他と切り離した属性単体では意味のある内容が得られない。  
  
属性とプロパティの違い...   
親オブジェクトからの値オブジェクトへの参照は単なる属性などではない。  
これは親オブジェクトのプロパティでありモデル内のあるモノへの参照を保持しているものだ。  
  
仕様クラス...   
集約のルートにはドメインの振る舞いを扱う責務があるため、  
いくら集約の境界を参照できるとはいえバリデーションの責務を持たせると責務が増えすぎてしまう。  
そのため集約が仕様を満たしているかチェックする仕様クラスを用意し、集約のルートにvalidate()メソッドでそれを利用しチェックさせる。  
これを仕様パターンという。  


# オブジェクト生成の約束
・コンストラクタの中で別のコンストラクタを呼んではいけない（コンストラクタは単純でなければならない）
理由：クライアントが予期しないオブジェクト生成が含まれ、混乱やバグを招く。

・オブジェクトの生成は単純であればコンストラクタ、複雑ならば別オブジェクトで行う。
理由：集約の責務はビジネスロジックを実行することであり、オブジェクト生成はそこに含まれない。

# まずはコンストラクタで生成して良いか考える。
抽象クラスを継承/実装したクラスではなく（レイヤスーパータイプは除く）、
オブジェクトの持つ属性を全てクライアントが取得できる（コンストラクタ内でオブジェクト生成が行われる心配がない）

# ファクトリメソッドで生成できないか考える。
・既存の集約に要素を新たに追加する場合は、集約ルートにその要素のファクトリメソッドを用意しても良い。
理由：要素追加時に集約の整合性を保証する責務を集約ルートに閉じることができる。

・他のオブジェクトの生成に密接に関わるオブジェクト(別集約ルート)にファクトリメソッドを用意しても良い。
理由：あるオブジェクトの持つデータやルールが、別のオブジェクトを生成する上で非常に支配的である場合に有効である。
注意：そのオブジェクトが生成物を所有するわけではない。

# ファクトリやサービスを作る。
ここまでくると、生成が複雑であるにも関わらずファクトリメソッドの自然な置き場所がないことになる。
そこで専用のファクトリクラスかドメインサービスクラスを作成する。

・専用のファクトリで集約全体を作成する。（エンティティファクトリ）
専用のファクトリは集約全体を生成してルートへの参照を渡し、生成された集約の不変条件が必ず強制されることを保証する。
不変条件によって求められないのであれば、生成時は本質的な属性だけを受け取り、詳細は後から追加しても良い。

・専用のファクトリで集約の内部にあるオブジェクトを生成する。（値オブジェクトファクトリ）
あくまで集約の内部のオブジェクトであるので、集約外部のオブジェクトから利用は一時的なもの（集約のプロパティにセットしたりしない）に留めること。

おまけ
# ファクトリで再構成を行う場合の注意点
ファクトリは新規生成だけでなく再構成も行う。
・追跡IDは絶対に新規採番ではないのでパラメーターで受け取ること。
・新規作成とは違い、不変条件を満たさないときに単に例外を投げるだけではうまくいかないことが多く柔軟な対応が必要。
```  

# サンプルコードを実行する
### Docker環境を準備  
省略  
  
### java7をインストール  
古いバージョンなので以下からインストーラーをダウンロード  
http://www.oracle.com/technetwork/java/archive-139210.html  
  
環境変数JAVA_HOMEを切り替え  
export JAVA_HOME='/Library/Java/JavaVirtualMachines/jdk1.7.0_80.jdk/Contents/Home/'  
  
### 環境構築  
```  
[localhost private_projects]$ git clone https://github.com/VaughnVernon/IDDD_Samples.git  
[localhost private_projects]$ cd IDDD_Samples/  
[localhost IDDD_Samples]$ ./startContainers.sh start  
Starting MySQL Server container...  
Error: No such container: iddd-mysql  
d7d9359aecdc0c9acabe00905da8d0c9bdffaf6d72bda2f04e3f8fda3f498017  
Waiting for MySQL Server to be up and running...  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_common/src/main/mysql/test_common.sql]  
mysql: [Warning] Using a password on the command line interface can be insecure.  
ERROR 2013 (HY000): Lost connection to MySQL server at 'reading initial communication packet', system error: 0  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_common/src/main/mysql/common.sql]  
mysql: [Warning] Using a password on the command line interface can be insecure.  
ERROR 2013 (HY000): Lost connection to MySQL server at 'reading initial communication packet', system error: 0  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_identityaccess/src/main/mysql/iam.sql]  
mysql: [Warning] Using a password on the command line interface can be insecure.  
ERROR 2013 (HY000): Lost connection to MySQL server at 'reading initial communication packet', system error: 0  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_collaboration/src/main/mysql/collaboration.sql]  
mysql: [Warning] Using a password on the command line interface can be insecure.  
ERROR 2013 (HY000): Lost connection to MySQL server at 'reading initial communication packet', system error: 0  
Starting RabbitMQ container...  
Error: No such container: iddd-rabbitmq  
Unable to find image 'rabbitmq:3-management' locally  
3-management: Pulling from library/rabbitmq  
be8881be8156: Already exists   
ab96a756674d: Pull complete   
1afa3c8b1ac8: Pull complete   
8d6ac301ca22: Pull complete   
665d14f5b3ec: Pull complete   
c8c7fea479bc: Pull complete   
1f57b98898fc: Pull complete   
c57de6ff1fda: Pull complete   
eb20b6079db3: Pull complete   
bfcd2c7011de: Pull complete   
71a3874699ee: Pull complete   
5b914bcc4a84: Pull complete   
f63e1b988a2d: Pull complete   
e39cb8f0eaed: Pull complete   
Digest: sha256:0b36ea1a8df9e53228aaeee277680de2cc97c7d675bc2d5dbe1cc9e3836a9d9f  
Status: Downloaded newer image for rabbitmq:3-management  
0e8e82e05a1e5e0f4ccf900f4a622b7995d488539b8740601e0e7ece7a0560ff  
Waiting for RabbitMQ to be up and running...  
  
RabbitMQ Management available at [http://localhost:8080]  
(Login with user/pass of [guest/guest])  
[localhost IDDD_Samples]$ docker ps  
CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS              PORTS                                                                                       NAMES  
0e8e82e05a1e        rabbitmq:3-management   "docker-entrypoint.s…"   22 seconds ago      Up 21 seconds       4369/tcp, 5671/tcp, 15671/tcp, 25672/tcp, 0.0.0.0:5672->5672/tcp, 0.0.0.0:8080->15672/tcp   iddd-rabbitmq  
d7d9359aecdc        mysql                   "docker-entrypoint.s…"   46 seconds ago      Up 45 seconds       0.0.0.0:3306->3306/tcp                                                                      iddd-mysql  
[localhost IDDD_Samples]$   
```  
コンテナは立ち上がっているけど、mysqlの初期化に失敗した模様。mysqlサーバーの起動に時間がかかったか？  
手動で初期化する。  
```  
[localhost IDDD_Samples]$ testSqlFiles="$(find $(pwd) -name *.sql | grep -i "test")"  
[localhost IDDD_Samples]$ sqlFiles="$(find $(pwd) -name *.sql | grep -vi "test")"  
[localhost IDDD_Samples]$  for sql in ${testSqlFiles}; do  
echo "Importing [${sql}]"  
MYSQL_PWD="root" mysql --host="0.0.0.0"  --port=3306 --protocol=TCP --user="root" < ${sql}  
done  
  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_common/src/main/mysql/test_common.sql]  
[localhost IDDD_Samples]$ for sql in ${sqlFiles}; do  
echo "Importing [${sql}]"  
MYSQL_PWD="root" mysql --host="0.0.0.0"  --port=3306 --protocol=TCP --user="root" < ${sql}  
done  
  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_common/src/main/mysql/common.sql]  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_identityaccess/src/main/mysql/iam.sql]  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_collaboration/src/main/mysql/collaboration.sql]  
ERROR 1074 (42000) at line 11: Column length too big for column 'event_body' (max = 16383); use BLOB or TEXT instead  
[localhost IDDD_Samples]$   
```  
collaboration.sqlの実行でエラーになった。定義するカラムサイズが大きすぎたので変更。  
```  
[localhost IDDD_Samples]$ git diff iddd_collaboration/src/main/mysql/collaboration.sql  
diff --git a/iddd_collaboration/src/main/mysql/collaboration.sql b/iddd_collaboration/src/main/mysql/collaboration.sql  
index d996321..9f87b00 100644  
--- a/iddd_collaboration/src/main/mysql/collaboration.sql  
+++ b/iddd_collaboration/src/main/mysql/collaboration.sql  
@@ -10,7 +10,7 @@ CREATE TABLE `tbl_dispatcher_last_event` (  
   
 CREATE TABLE `tbl_es_event_store` (  
     `event_id` bigint(20) NOT NULL auto_increment,  
-    `event_body` varchar(65000) NOT NULL,  
+    `event_body` varchar(6500) NOT NULL,  
     `event_type` varchar(250) NOT NULL,  
     `stream_name` varchar(250) NOT NULL,  
     `stream_version` int(11) NOT NULL,  
@@ -123,7 +123,7 @@ CREATE TABLE `tbl_vw_post` (  
     `author_email_address` varchar(100) NOT NULL,  
     `author_identity` varchar(50) NOT NULL,  
     `author_name` varchar(200) NOT NULL,  
-    `body_text` varchar(64000) NOT NULL,  
+    `body_text` varchar(6400) NOT NULL,  
     `changed_on` datetime NOT NULL,  
     `created_on` datetime NOT NULL,  
     `discussion_id` varchar(36) NOT NULL,  
[localhost IDDD_Samples]$   
```  
再実行。  
```  
[localhost IDDD_Samples]$ for sql in ${sqlFiles}; do  
echo "Importing [${sql}]"  
MYSQL_PWD="root" mysql --host="0.0.0.0"  --port=3306 --protocol=TCP --user="root" < ${sql}  
done  
  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_common/src/main/mysql/common.sql]  
ERROR 1050 (42S01) at line 12: Table 'tbl_es_event_store' already exists  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_identityaccess/src/main/mysql/iam.sql]  
Importing [/Users/sacnakag/private_projects/IDDD_Samples/iddd_collaboration/src/main/mysql/collaboration.sql]  
[localhost IDDD_Samples]$   
```  
テーブルが既に存在するエラーが出てるが無視。これで初期化完了。  
  
### ソフトウェアをビルド  
`./gradlew build`実行。テストでエラーになった。  
```  
省略...  
  
com.saasovation.collaboration.domain.model.collaborator.CollaboratorServiceTest > testCollaboratorTranslator FAILED  
    org.springframework.beans.factory.BeanCreationException at CollaboratorServiceTest.java:99  
        Caused by: org.springframework.beans.BeanInstantiationException at CollaboratorServiceTest.java:99  
            Caused by: java.lang.IllegalStateException at CollaboratorServiceTest.java:99  
                Caused by: java.lang.IllegalStateException at CollaboratorServiceTest.java:99  
                    Caused by: org.apache.commons.dbcp.SQLNestedException at CollaboratorServiceTest.java:99  
                        Caused by: com.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException at CollaboratorServiceTest.java:99  
  
70 tests completed, 70 failed  
:iddd_collaboration:test FAILED  
  
FAILURE: Build failed with an exception.  
  
* What went wrong:  
Execution failed for task ':iddd_collaboration:test'.  
> There were failing tests. See the report at: file:///Users/sacnakag/private_projects/IDDD_Samples/iddd_collaboration/build/reports/tests/index.html  
  
* Try:  
Run with --stacktrace option to get the stack trace. Run with --info or --debug option to get more log output.  
  
BUILD FAILED  
  
Total time: 1 mins 31.028 secs  
```  
mysql関連のエラーのようなので、ログを確認する。  
詳細ログを出力するため設定ファイルを用意し、コンテナ起動スクリプトを以下のように変更。  
```  
[localhost IDDD_Samples]$ cat /tmp/mymysql/custom.cnf   
[mysqld]  
general_log=1  
[localhost IDDD_Samples]$   
[localhost IDDD_Samples]$ git diff startContainers.sh  
diff --git a/startContainers.sh b/startContainers.sh  
index c2bcc34..c707c69 100755  
--- a/startContainers.sh  
+++ b/startContainers.sh  
@@ -17,7 +17,7 @@ containers[1]="${rabbitmqContainerName}"  
 function start() {  
     echo "Starting MySQL Server container..."  
     docker rm -f "${mysqlContainerName}"  
-    docker run --name "${mysqlContainerName}" -p "${mysqlPort}":3306 -e MYSQL_ROOT_PASSWORD="${mysqlPassword}" -d mysql  
+    docker run -v /tmp/mymysql/:/etc/mysql/conf.d --name "${mysqlContainerName}" -p "${mysqlPort}":3306 -e MYSQL_ROOT_PASSWORD="${mysqlPassword}" -d mysql  
   
     echo "Waiting for MySQL Server to be up and running..."  
     waitForContainer "${mysqlContainerName}" "mysqld: ready for connections."  
[localhost IDDD_Samples]$   
```  
再度環境構築するためコンテナとイメージを全て削除。  
```  
[localhost IDDD_Samples]$ docker stop $(docker ps -aq)  
[localhost IDDD_Samples]$ docker rm $(docker ps -aq)  
[localhost IDDD_Samples]$ docker rmi $(docker images -aq)  
```  
環境構築手順を実施して、ビルド実行。  
mysqlコンテナにログインし、詳細ログを確認してみるとテストエラー時に以下が出力された。  
```  
root@26fbfc2915de:/# tail -f /var/lib/mysql/26fbfc2915de.log  
...省略...   
  
2018-08-26T13:15:27.302624Z	   12 Connect	Client does not support authentication protocol requested by server; consider upgrading MySQL client  
2018-08-26T13:15:27.302687Z	   12 Connect	root@172.17.0.1 on iddd_collaboration using TCP/IP  
  
...省略...  
```  
どうやら以下の問題のよう。  
https://dev.mysql.com/doc/refman/5.6/ja/old-client.html  
試しにmysqlサーバーのバージョンを5.7に指定した。（バージョンを下げた）  
```  
[localhost IDDD_Samples]$ git diff startContainers.sh  
diff --git a/startContainers.sh b/startContainers.sh  
index c2bcc34..f1a3a5a 100755  
--- a/startContainers.sh  
+++ b/startContainers.sh  
@@ -17,7 +17,7 @@ containers[1]="${rabbitmqContainerName}"  
 function start() {  
     echo "Starting MySQL Server container..."  
     docker rm -f "${mysqlContainerName}"  
-    docker run --name "${mysqlContainerName}" -p "${mysqlPort}":3306 -e MYSQL_ROOT_PASSWORD="${mysqlPassword}" -d mysql  
+    docker run -v /tmp/mymysql/:/etc/mysql/conf.d --name "${mysqlContainerName}" -p "${mysqlPort}":3306 -e MYSQL_ROOT_PASSWORD="${mysqlPassword}" -d mysql:5.7  
   
     echo "Waiting for MySQL Server to be up and running..."  
     waitForContainer "${mysqlContainerName}" "mysqld: ready for connections."  
[localhost IDDD_Samples]$   
```  
再度環境構築を行うとビルドが成功した。  
```  
[localhost IDDD_Samples]$ ./gradlew build  
:compileJava UP-TO-DATE  
:processResources UP-TO-DATE  
:classes UP-TO-DATE  
:jar UP-TO-DATE  
:assemble UP-TO-DATE  
:compileTestJava UP-TO-DATE  
:processTestResources UP-TO-DATE  
:testClasses UP-TO-DATE  
:test UP-TO-DATE  
:check UP-TO-DATE  
:build UP-TO-DATE  
:iddd_common:compileJava UP-TO-DATE  
:iddd_common:processResources UP-TO-DATE  
:iddd_common:classes UP-TO-DATE  
:iddd_common:jar UP-TO-DATE  
:iddd_agilepm:compileJava UP-TO-DATE  
:iddd_agilepm:processResources UP-TO-DATE  
:iddd_agilepm:classes UP-TO-DATE  
:iddd_agilepm:jar UP-TO-DATE  
:iddd_agilepm:assemble UP-TO-DATE  
:iddd_common:compileTestJava  
:iddd_common:processTestResources UP-TO-DATE  
:iddd_common:testClasses  
:iddd_agilepm:compileTestJava UP-TO-DATE  
:iddd_agilepm:processTestResources UP-TO-DATE  
:iddd_agilepm:testClasses UP-TO-DATE  
:iddd_agilepm:test  
:iddd_agilepm:check  
:iddd_agilepm:build  
:iddd_collaboration:compileJava UP-TO-DATE  
:iddd_collaboration:processResources UP-TO-DATE  
:iddd_collaboration:classes UP-TO-DATE  
:iddd_collaboration:jar UP-TO-DATE  
:iddd_collaboration:assemble UP-TO-DATE  
:iddd_collaboration:compileTestJava  
:iddd_collaboration:processTestResources UP-TO-DATE  
:iddd_collaboration:testClasses  
:iddd_collaboration:test  
:iddd_collaboration:check  
:iddd_collaboration:build  
:iddd_common:assemble UP-TO-DATE  
:iddd_common:test  
:iddd_common:check  
:iddd_common:build  
:iddd_identityaccess:compileJava  
:iddd_identityaccess:processResources  
:iddd_identityaccess:classes  
:iddd_identityaccess:jar  
:iddd_identityaccess:assemble  
:iddd_identityaccess:compileTestJava  
:iddd_identityaccess:processTestResources  
:iddd_identityaccess:testClasses  
:iddd_identityaccess:test  
:iddd_identityaccess:check  
:iddd_identityaccess:build  
  
BUILD SUCCESSFUL  
  
Total time: 2 mins 51.353 secs  
[localhost IDDD_Samples]$   
```  
ここまで色々と確認している間にコネクション数が上限に達して接続できなくなったので、そうならないように以下を設定しておく。  
```  
MYSQL_PWD="root" mysql --host="0.0.0.0"  --port=3306 --protocol=TCP --user="root" -e "SET GLOBAL max_connect_errors=99999;"  
```  
  
# サンプルを動かす  
サンプルはJava EEのWebサービス仕様であるJAX-RSを利用している。  
JAX-RSは、RESTに準拠したWebサービスを作るためのJava EEの仕様。  
その実装として Jersey（リファレンス実装）や Apache CXF 、RESTEasy などがある。サンプルではRESTEasyが利用されている。  
【RESTEasy】https://access.redhat.com/documentation/ja-jp/jboss_enterprise_application_platform/5/html-single/resteasy_reference_guide/index  
  
WEBコンテナに乗せるのは面倒、かつ（多分）サンプルの操作インターフェースが揃っていないので、アプリケーション層に対するテストを記述して動かしていく。  
以下のように動かしたいコンテキストのプロジェクトルートに移動し、テストクラスを指定してtestTaskを実行していく。  
```  
[localhost IDDD_Samples]$ cd iddd_collaboration/  
[localhost iddd_collaboration]$ ../gradlew -Dtest.single=**/CalendarEntryApplicationServiceTest test  
:iddd_common:compileJava UP-TO-DATE  
:iddd_common:processResources UP-TO-DATE  
:iddd_common:classes UP-TO-DATE  
:iddd_common:jar UP-TO-DATE  
:iddd_collaboration:compileJava UP-TO-DATE  
:iddd_collaboration:processResources UP-TO-DATE  
:iddd_collaboration:classes UP-TO-DATE  
:iddd_common:compileTestJava UP-TO-DATE  
:iddd_common:processTestResources UP-TO-DATE  
:iddd_common:testClasses UP-TO-DATE  
:iddd_collaboration:compileTestJava UP-TO-DATE  
:iddd_collaboration:processTestResources UP-TO-DATE  
:iddd_collaboration:testClasses UP-TO-DATE  
:iddd_collaboration:test  
  
BUILD SUCCESSFUL  
  
Total time: 7.188 secs  
[localhost iddd_collaboration]$   
```  
