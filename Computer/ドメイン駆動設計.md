# エリック・エヴァンスのドメイン駆動設計  
  
### ソフトウェアのドメインとは  
ソフトウェア（システム）の動作に影響する事象  
ソフトウェア（システム）になるもの  
ソフトウェア（システム）を使った事業  
  
### モデルとは  
知識を表現するもの  
  
### ドキュメントの必要性  
システムの進化に伴いメンテナンスが必要なドキュメントは不要である。  
ソースコードが仕様書となるべき。  
  
### ユビキタス言語  
ビジネス側と開発側で統一された言語  
  
### レイヤ化アーキテクチャ  
ドメインをソフトウェアの事情から切り離し、ビジネスロジックに専念させるための考え方。  
  
# ドメインのモデルを作る  
### モデル駆動設計とは  
ドメインエキスパートがビジネス目線でドメインを分析し、ソフトウェアで果たす役割を考慮していない分析モデルが作成される。  
分析モデルには設計や実装をし始めてようやく発見できる重大な課題・問題は含まれない。  
そのため開発者は分析モデルとは別でシステムを設計する。    
この分析モデルと設計の2分法を捨て、分析・設計の両方に使える単一のモデルを探し出すことをモデル駆動設計という。  
  
### ブレインストーミングで知識を噛み砕き、クラス図に落とし込む  
クラス図でなくても、ソースコードの仕様が決まるレベルにする。  
  
### 根底のモデルは一つだけ  
設計・実装・チームでのコミュニケーション等の根底にあるモデルは一つだけ。  
それぞれで説明用のモデルを用いることは正しい。  
  
### 関連を扱いやすくする  
モデル（クラス図）の関連の実装方法は複数ある。  
関連オブジェクトをプロパティに持ったり、データベースアクセスをラップして動的に取得したりなど。  
これでは良いモデルではないので、以下を実施する。  
- 関連を辿る方向を強制する  
- 限定子を付加して多重度を減らす  
- 本質的でない関連を除去する  
  
### モジュール（パッケージ）を適切にする  
クラスと同じように、モジュール構成のリファクタリングを続けることが大事。  
モジュール名はユビキタス言語からなる。  
  
# モデルを構成する3種類の要素(ドメインオブジェクト)  
## ・エンティティ（別名：参照オブジェクト）  
連続性（ライフサイクル）と同一性（一意性）持つオブジェクト  
- 責務  
  - エンティティを識別する手段の提供  
  - 各ライフサイクルにおける振る舞いの提供  
  
## ・値オブジェクト（Value Object）  
値を保持し、操作を提供するオブジェクト  
- 責務  
  - 値の操作方法の提供  
  - 値の不変性の約束  
  
※値オブジェクトか？エンティティか？  
モデルの属性だけがドメインであれば値オブジェクトになる。  
モデルの存在（同モデルの他インスタンスとの関係）がドメインであればエンティティになる。  
  
※値オブジェクト同士で双方向の関連を持つことはない。  
そもそも双方向の関連は、関連オブジェクト同士でメッセージを交換しあえる意味がある。  
そのため相手が自分のポインタを持つ特定の状態のオブジェクトでなければならない場合に有効になる。  
特定の状態を持つオブジェクトは、エンティティとなる。  
値オブジェクトでは特定の状態を持たないので、メッセージを送りたければ動的に取得すれば良い。  
双方向の関連はモデル化の段階で除去すること。  
  
## ・サービス（Service)  
ドメインにおける重要なプロセスや変換処理が、エンティティや値オブジェクトの自然な責務にならない場合に  
モデルに追加されるインターフェース。  
- 責務  
  - 操作に状態がない  
  - 操作名がユビキタス言語の一部になること  
  
※サービスを各レイヤに分割する  
細粒度のドメインオブジェクトを作り上げていくと、その振る舞いが組み合わさる場所がアプリケーション層になり、  
ドメイン層からアプリケーション層へ知識が流出してしまう。  
サービス（ドメインサービス）を慎重に導入し、それを防ぐことが必要。  
- アプリケーション層のサービス  
ユーザーインターフェースからの入力を受け付ける。  
ドメインサービスにメッセージを送信する。  
インフラストラクチャサービスにメッセージを送信する。  
- ドメインサービス  
エンティティや値オブジェクトをまとめ上げて処理を行う。  
- インフラストラクチャサービス  
記録や通知の仕組みを提供する。  
ビジネスロジックを一切含まない。  
  
# ドメインオブジェクトのライフサイクルの課題を解決する  
- 課題  
  - 1.ライフサイクルを通じて整合性（不変条件）を維持すること  
  - 2.ライフサイクルの管理の複雑さからモデルを切り離すこと  
  
**※不変条件とは**  
モデルが責務を全うするために必要な正しい状態を保つための条件。  
複雑な関連を伴うモデルでは個々のモデルだけではなく関連するオブジェクトのグループに対して不変条件があり、    
これが適切でないとそのグループは整合性を保てない。    
  
これら2つの課題を3つのパターンを用いて解決する。  
  
## ・集約(Aggregates)  
集約とは関連するオブジェクトの集まりのこと。  
不変条件を持つドメインオブジェクトグループに対する呼び方であり、実装方法が決まっている。  
課題１を解決する。  
##### 集約はルートと境界を持つ。  
- ルート    
集約に含まれている特定の一つのエンティティ    
- 境界    
集約の中身の定義  
  
外部のオブジェクトが参照して良いのはルートだけ。  
境界内のルート以外のエンティティの同一性は集約内部だけで保たれれば良い。  
自動車の例）  
自動車を一意に識別する識別子がある。  
タイヤの走行距離と摩耗度の測定のため各タイヤに識別子を持たせる。  
特定の自動車をシステムに問い合わせ、装着しているタイヤを参照することはあるが、  
特定のタイヤをシステムに問い合わせ、それがどの自動車に装着されているか調べる人はいないし、  
タイヤが交換され自動車を離れた後、同種のタイヤの山の中で同一性を保つ必要はない。  
この場合、自動車エンティティがルートになり、境界は自動車エンティティとタイヤエンティティとなる。  
  
##### 集約の不変条件  
不変条件を満たした状態を維持する集約の実装方法  
```  
・ 集約のルートエンティティは、グローバルな同一性を持ち、不変条件をチェックする最終的な責務を負う。  
・ ルートエンティティはグローバルな同一性を持つ。境界内部のエンティティは、集約内でのみ一意となるローカルな同一性を持つ。  
・ 集約の境界外にあるオブジェクトは、ルートエンティティを除き、境界内部への参照を保持することができない。ルートエンティティは内部のエンティティへの参照を他のオブジェクトに渡せるが  
  受け取ったオブジェクトは参照を一時的に使用することができるだけで、その参照を保持してはならない。ルートは値オブジェクトのコピーを別のオブジェクトに渡すこともあるが、  
  その場合はそのコピーがどうなってもよい。渡されるのは単なる値で、集約とは何の関連もなくなるからである。  
・ 前述のルールの必然的結果として、データベースに問い合わせて直接取得できるのは、集約ルートだけとなる。それ以外のオブジェクトはすべて、関連を辿ることで取得しなければならない。  
・ 集約内部のオブジェクトは、他の集約ルートへの参照を保持することができる。  
・ 削除の操作は、集約境界の内部に存在するあらゆるものを一度に削除しなければならない  
 （ガベージコレクションがあれば簡単である。ルート以外に対しては、外部から参照されていないので、ルートを削除した際に、他もすべてガベージコレクションすればよい）。  
・ 集約境界の内部に存在するオブジェクトに対する変更がコミットされる時には、集約全体の不変条件がすべて満たされていなければならない。  
  
Eric Evans. エリック・エヴァンスのドメイン駆動設計 (Kindle の位置No.3141-3143). 翔泳社. Kindle 版.   
```  
一つの集約内のデータに変更があったとき不変条件は、トランザクションの完了時に満たされることを強制する。  
不変条件が複数の集約にまたがる場合は一時的に不変条件を満たさないタイミングがあるが、バッチ等で一定時間内に解消する。  
  
## ・ファクトリ（Factories）  
3種類のドメインオブジェクトそれぞれが持つ責務の中に自身のオブジェクト作成は含まれない。  
そのためドメイン層にはドメインオブジェクトに加え、ドメインオブジェクト作成を担当する要素（ファクトリ）が追加される。    
課題2を解決する。  
  
##### ファクトリのデザインパターン  
ファクトリメソッド  
抽象ファクトリ  
ビルダ  
  
##### ファクトリの実現方法  
1. 集約のルートにファクトリメソッドを定義する  
2. 生成対象に渡すパラメータを持つ別境界のドメインオブジェクトにファクトリメソッドを定義する  
3. 専用のファクトリオブジェクトかサービスを新規に作成する  
  
※1→2→3の優先順  
  
##### 優れたファクトリの条件  
- ファクトリが生成するドメインオブジェクトはその必ず不変条件を満たした状態で作成される。  
不変条件を満たせない場合は例外をスローしたりnullを返却するなどのコーディング規約に従った動作をする。　　  
- 集約のルートの抽象クラスやインターフェースに対して１つのファクトリを用意する(?)  
- ファクトリは引数を単純に使うこと。引数を生成物に設定するだけが理想であり引数はオブジェクトでも良い。  
  
##### ファクトリが不要な場合  
クラスコンストラクタでインスタンス生成する方が良い場合がある。  
1. 構造が簡単なドメインオブジェクト  
2. 抽象化されていないクラス(?)  
  
※コンストラクタの中で他のクラスのコンストラクタを呼び出す場合は複雑となるため素直にファクトリを用意する。  
  
##### ファクトリは新規作成だけでなく再構成も担う  
ファクトリで担う再構成の責務は、与えられた引数からドメインオブジェクトを生成し返却することである。  
  
## ・リポジトリ（Repositories)    
ドメインオブジェクトのストレージへの移動、ストレージからの移動（再構成）を担うドメイン層の要素。  
クライアントに、すでに存在するドメインオブジェクトの参照を手に入れる手段を提供する。    
課題2を解決する。  
  
##### リポジトリの責務  
- 全ての集約のルートオブジェクトで構成されるコレクションがメモリ上にあると錯覚させること  
- ストレージ（DB等）への問い合わせの技術をカプセル化する(リポジトリとはユビキタス言語でやり取りする)  
- インスタンス化されたドメインオブジェクトか、ドメインオブジェクトのコレクションを返却するメソッドを提供する  
- ストレージ上での集約のルート以外へのグローバルアクセスを防ぐ  
  
##### リポジトリの利点  
- 永続化技術からドメインの設計を切り離せる  
- テスト用にダミー実装と切り替えることが容易になる  
  
##### リポジトリの内部動作  
- SQLを実行し結果セットをファクトリで再構成してクライアントに返却する  
- ORマッパーを使ってオブジェクトを取得して返却する  
  
##### リポジトリ実装時と注意点    
- 型を抽象化すること(?)  
集約のルートの抽象クラスやインターフェースに対して１つのリポジトリを用意する  
- カプセル化の利点を活かすこと    
SQLをDB実装に合わせて最適化したり、結果をキャッシュすることができることを意識しておく。  
- トランザクション制御はしない  
作業単位を知っているのはアプリケーション層かドメイン層なので、そちらに任せる。    
  
  
# 実践ドメイン駆動設計  
  
### ドメインエキスパート   
ドメインに関する深い業務知識を持つ人  
  
### 軽量DDD  
サブドメイン、境界づけられたコンテキスト、コンテキストマップ、ユビキタス言語を見つけていく戦略的設計を行わず、  
```ドメインオブジェクト ＋ 集約の概念 ＋ ファクトリ ＋ リポジトリ```  
を利用する戦術的アプローチのこと。良くない。  
  
### 境界づけられたコンテキスト  
ドメインモデル上の概念的な区切り。一つあるいは複数のサブドメインを含む。  
名前は「モデル名＋コンテキスト」になる。  
  
### コンテキストマップ  
境界づけられたコンテキストどうしの関連  
  
### ヘキサゴナルアーキテクチャ  
ドメインモデルにおける境界づけられたコンテキストの表現方法。  
サービス指向やマイクロサービスなどの様々なアーキテクチャに対応できる書き方。  
  
### ドメインモデル貧血症  
大半がpublicなゲッターセッターで、単に属性と値を保持するだけのオブジェクト  
  
### 貧血誘発性記憶喪失  
ドメインモデル貧血症によりコードから意図が読み取れない状態  
  
### 実装  
ユビキタス言語を用いたテスト駆動で開発し、ドメインエキスパートにレビューをもらう  
  
### ドメインとサブドメイン  
##### そもそもドメインとは？  
ドメイン（広義）=  組織が行う事業や、それを取り巻く世界。  
事業が市場（顧客）の定義し、プロダクトやサービスを販売する。  
様々な業務により事業は成り立つ。業務にはノウハウと物事の進め方がある。  
「どこかの組織のためのソフトウェアを作る = その組織のドメイン（事業を取り巻く世界）で作業する」  
  
##### サブドメインとは？  
ドメイン（組織が行う事業）を成り立たせる、一つの業務を指す。  
業務は「〇〇を〜〜する」と表現でき、〇〇がサブドメインとして取り上げられる。  
  
・なんで戦略的設計が大事？  
サブドメインがハッキリすることで、システムが大きな泥団子にならない。  
コアドメインなのか、他のサブドメインから利用される汎用ドメインとなるかハッキリさせることができる。  
  
サブドメインの種類  
  - コアドメイン...ドメインのコア  
  - 支援ドメイン...業務に不可欠だがコアドメインほどではない  
  - 汎用ドメイン...業務上で特別なことはしていないがドメインを支援している  
  
### ドメインは問題空間と解決空間を持つ  
- 問題空間  
解決すべきビジネス戦略上の課題。  
「問題空間を評価する」とは、その課題を浮き彫りにすること。  
評価した結果はドメインモデル上でサブドメインとして表現される。  
  
- 解決空間  
問題空間のソリューション。  
「解決空間を評価する」とは、問題空間をソフトウェアでどのように解決するかに注目すること。  
評価した結果はドメインモデル上で境界づけられたコンテキストとコンテキストマップして表現される。  
  
サブドメインと境界づけられたコンテキストを一対一で対応させることが望ましい。  
  
  
# メモ  
```  
・システム間連携パターンは4種類（書籍「Enterprise Integration Patterns」）  
データベース共有（Shared Database）  
ファイル転送（File Transfer）  
リモートメソッド呼び出し（Remote Method Invocation）  
メッセージング（Messaging）  
  
・腐敗防止層とは？  
下流の「境界づけられたコンテキスト」が、上流の「境界づけられたコンテキスト」からオブジェクトを受け取るときに用いる。  
上流では集約だったものも、下流で受け取るときは値オブジェクトにするべき。  
そうすることで下流に責務が流れ込まず、管理するオブジェクトの数も減るので扱いが楽になる。  
腐敗防止層の技術的な実装は、専用のアダプターと変換サービスの組み合わせになることが一般的。  
  
・自己カプセル化  
クラス内部からのアクセスもアクセサメソッド経由で行うこと  
アクセサメソッドにバリデーションチェック処理（ガード）を設定しておくことで、  
「契約による設計」における事前条件を満たしていることを確認している。（不正な値でればExceptionをスロー）  
エンティティでは「属性単位」「オブジェクト全体」「複数オブジェクト時」という3つの粒度に分けてバリデーションを管理する。  
「属性単位」はエンティティ生成時に自己カプセル化のガードで実装。  
「オブジェクト全体」は専用のバリデータクラスを生成し、「遅延バリデーション（可能な限り先送り）」を行う。  
「複数オブジェクト時」は集約のルートのEntityに対して、「遅延バリデーション（可能な限り先送り）」を行う。  
ドメインサービスで制御する場合は、エンティティがチェック可能なタイミングになったら、オブジェクト側からバリデーション可能な旨のイベントを  
サービス（クライアント）側へ通知して、チェックを実行。  
  
・ドメインサービスとは？  
ドメインオブジェクトの自然な責務にならない処理を持つ、ステートレスなオブジェクト。  
ドメインサービスの主な役割として、様々なエンティティや値オブジェクト、集約を利用して計算するビジネスルールが挙げられる。  
本来ドメインオブジェクトが持つべき責務がドメインサービスに染み出さないように注意すること。  
また、ドメインサービスの処理をアプリケーション層のサービスには書いてはいけない。  
アプリケーション層のサービスは、トランザクションやセキュリティといった、ドメインの外側の関心ごとの実装を受け持つ。  
集約の境界が他の集約のリポジトリを持つべきではないから、ドメインサービスに持たせる。  
アプリケーションサービスが、ユースケースを実現するために、複数あるいは別種類の集約どうしの連携を担当してはいけない。  
それはもはや業務ロジックであり、ドメインサービスが担当すべきだ。  
ドメインサービスは、複数の集約をリポジトリから取得でき、比較・計算・判断・加工処理を行える。  
アプリケーションサービスがプロパティの絞り込みで集約のコレクションをもらってデータとして出力したい場合は、業務ロジックを含まないし  
更新処理でもないのでコマンドモデルである集約を取得するのではなく、クエリーモデルを使うべきだ。  
クエリーモデルを取得する際に、SQL文で別種類の集約分のデータをJOINしてWHERE句でロジックを実現してはいけない。それはもはや業務ロジックである。  
このような場合は、ドメインサービスが各種類の集約のリポジトリを使って集約のコレクションを取得し、モデルのメソッドを使って判断・加工していく。  
そして結果を値オブジェクトで返却してもらう。  
クエリーモデルを使うのは、単一集約分のデータをプロパティで絞り込んで取得し、そのまま利用するだけ。  
ファクトリとしてのドメインサービスが存在するが、わかりやすくするために〜Factoryクラスを作った方が良い。  
  
・標準型・タイプコード・区分オブジェクト  
区分や種類を表すオブジェクトを指す。  
１グループの区分や種類に対して、〜タイプという値オブジェクトを一つ作成しても良いが  
シンプルさを求めてenumを使うことが推奨される  
  
・セパレートインターフェースとは？  
実装クラスとは別のパッケージでインターフェースを定義すること。  
依存関係逆転の原則で用いられる。  
ヘキサゴナルアーキテクチャのport&adapter層にあるリポジトリ実装の  
インターフェースをドメイン層に持たせているのもセパレートインターフェースである。  
実装の選択にはDIコンテナを使うと良い。  
  
・ドメインイベントとは？  
ドメインエキスパートが注目する出来事にフォーカスする。  
「〜する時に」「〜した場合に知らせて」などをイベントとして定義する。  
イベントの発行を「パブリッシャー」で行い、イベントの受信を「サブスクライバ」で行う。  
ドメインイベントクラスは不変クラスになる。  
パブリッシャーとサブスクライバが一つの境界づけられたコンテキスト内にある場合で、同期処理の場合オブザーバーパターンで実装する。  
別の境界づけられたコンテキストに別れている場合や、非同期処理の場合は、サブスクライバは自コンテキスト内のイベントストアにイベントを格納する。  
別コンテキストのイベント検知用クライアントが、イベントストアをポーリング(RESTfullAPI)して、イベントを受信する。  
非同期の場合、イベント発行側のコンテキストが「自立型のサービス」となるため、外部システムの影響を受けない良い設計となる。  
同じイベントを何度も受診しても問題ないように設計する。  
  
・認証アクセスコンテキストの「ユーザー」「ロール」からコラボレーションコンテキストの「コラボレーター」にはどう変換された？  
認証アクセスコンテキストにRESTfullAPIでデータを取得し、腐敗防止層を経て、ファクトリとしてのドメインサービスのメソッドから取得する。  
クライアント  
↓  
ここからドメイン層  
ドメインサービス(抽象)  
↓  
ここからport&adaptor層  
ドメインサービス(実装)  
↓  
アダプター(抽象)  
↓  
アダプター(実装)  
↓REST  
認証アクセスコンテキスト（公開ホスト）  
  
・ファクトリの場所、種類  
DDDでは集約を作成するファクトリを用意する。ファクトリの場所は  
1.集約ルートのコンストラクタ  
2.別の集約上のメソッド  
3.ドメインサービスクラス  
に作られる。ファクトリを使えば、処理中の通常のインスタンス化も、別の境界づけれたコンテキスト(公開ホスト)からのドメインモデル連携  
も同じように扱える。  
2.別の集約上のメソッド（いわゆるファクトリーメソッド）ではガードを入れることができる。  
ファクトリの種類はファクトリー、ファクトリーメソッド、アブストラクトファクトリー、ビルダーパターンが挙げられる。  
アブストラクトファクトリーパターンを用いるのは、クラス階層ができた場合である。どういう風に使うのか？  
値オブジェクトの生成にもファクトリが利用される。リポジトリと違ってファクトリの利用場所にシビアになる必要はない。  
それはインスタンスの生成自体に問題はなく、結局のところ集約が保存されるときに不変条件さえ満たしていればシステムは壊れないから。  
ファクトリは複雑なインスタンス生成処理をラップする目的であれば抽象化する必要はないが、  
別コンテキストや永続化層からデータを取得してインスタンス化する場合はインターフェースを定義し、port&adaper層に実装をおくべき。  
  
・リポジトリの実装  
・コレクション指向のリポジトリ  
すでにリポジトリに登録されている集約を変更しても保存し直す必要がない。  
そのためには裏側にある永続化メカニズムに、自身が管理する永続オブジェクトについて、その変更の履歴を  
暗黙のうちに追跡できる仕組みがなければならない。  
・永続指向のリポジトリ  
集約を変更した時にsave()のように明示的にコミットする必要がある。  
リポジトリのインターフェースは、その実装が永続指向になる前提で定義しておくべき。  
なぜなら永続指向→コレクション指向の差し替えは簡単だが、その逆はコレクション指向がトランザクション管理が前提にされていなかったせいで  
永続指向に切り替えたタイミングでトランザクション管理のための修正が必要になるからである。  
ドメインモデルの中で抽象化し、クラス階層ができると  
・何がダメになるのか？  
クライアントが実装クラスを知り、選択しなければならなくなる。  
・どうすれば良いのか？  
抽象化を行わず、標準型（区分オブジェクト）を使って、モデルのタイプによりif文で処理を分ける。  
ifがややこしくなってきたら、区分オブジェクトに振る舞いを持たせる。参考 https://www.slideshare.net/masuda220/ss-57352072  
標準型が合わない場合、ロールベースのインターフェースを使うこともできる。（実践ドメイン駆動設計を参照）  
ロールごとにインターフェースを用意し、その全てを実装したエンティティを、リポジトリから特定ロールを指定して取得し、そのロール型に格納する。  
あとはロールインターフェースのメソッドを実行する。  
リポジトリはアプリケーションサービスかドメインサービスにしか持たないこと。  
ある集約が別の集約のリポジトリを持ったりすると、どこで集約が取り出し、保存されたかわからなくなる。  
集約上のメソッドが別の集約のファクトリメソッドになっている場合、作成された別集約を保存するためにはその集約を一度呼び出し元に返却して、  
リポジトリに保存する。  
  
・実際にファクトリにはどのパターンが使われている？  
Collaboratorの場合、抽象クラスであるCollaboratorクラスに対して  
CollaboratorService(ドメインサービス、抽象クラス)を用意し各Collaborator実装クラスを生成しているので、ファクトリーパターンである。  
  
・CQRSとは？  
https://qiita.com/ledmonster/items/22b00c65208dffeff7e4  
メリットは、実装がわかりやすいこと。  
参照のために集約を構成する必要がなく。パフォーマンスが良いこと。  
コマンドモデルストアと、クエリモデルストアを必ず分ける必要はないと考える。  
単純にアプリケーション層のサービスクラスを参照系と更新系で分けるだけでも効果はある。  
  
・RabbitMQとは？   
https://qiita.com/gambaray/items/3cc02b419c860a96bc94  
AMQPについて http://labs.gree.jp/blog/2010/06/262/  
ExchangeListener  
ExchangePublisher  
  
  
・イベント駆動アーキテクチャとは？  
ドメインイベントを用いたアーキテクチャを指す。  
  
・イベントソージングとは？   
https://www.slideshare.net/shuheifujita90/ss-14294169  
  
・ドメイン駆動設計において、Batch、WebAPI、UIアプリはどういったパッケージ構成になるのか、commonの概念はどうなるのか  
特に決まりはない。commonはDDDにおいては共有カーネルと呼ばれる。  
  
・ファブリックとは？  
イベント駆動アーキテクチャで利用出来る、イベントストアの一種。  
マルチノードキャッシュとレプリケーション機能を提供するインメモリデータベースのことを指す。  
インメモリデータグリッドとも呼ばれ、分散同期処理をサポートする。  
製品としてはGemFireが挙げられる。  
キャッシュレベルおよびエントリレベルでのイベントの発生を自動的に通知する仕組み  
  
・CQRSの実装はどうなってる？  
更新系メソッドの戻り値はvoidとし、参照系メソッドを用意する。  
それぞれコマンド、クエリと呼ばれる。  
集約にはコマンドメソッドしかない。  
CQRSにおけるリポジトリにはいくつかのコマンドメソッドと、一つのクエリメソッド（集約の識別子から該当集約を取得）がある。  
CQRSにおけるリポジトリはクエリメソッド以外（別のプロパティによる絞り込みなど）で集約を取得してはいけない。  
このパターンの登場人物と流れは、  
・更新系の場合  
クライアント  
↓更新  
コマンドプロセッサ（アプリケーションサービス）  
↓呼び出し  
コマンドモデル（集約）  
↓更新・保存、クエリモデル（ドメインイベントとして）発行  
コマンドモデルストア  
↓  
イベントサブスクライバ  
↓クエリモデル保存  
クエリモデルストア（ビュー）  
・参照系の場合  
クライアント  
↓参照  
クエリプロセッサ（アプリケーションサービス）  
↓参照  
クエリモデルストア（ビュー）  
となる。  
クエリモデルストアのビューは、ユーザーインターフェースの表示形式毎に用意し、全行・全カラムを読み込んで利用する。  
あまりにもビューが増えすぎる場合はある程度まとめたビューにして、クエリのWHERE句で調整する。  
コマンドプロセッサは可能であれば1コマンド1クラス（専用方式）にすべき。  
対して1コマンドを1メソッドと捉え、1クラスにまとめる方式（分類方式）もある。  
専用方式コマンドプロセッサをイベントストアに格納しておき、非同期で検知クライアントシステム側で実行する方式（メッセージング方式）もある。  
コマンドモデルとクエリモデルの格納は同じトランザクションで行うこと。ストアが異なる場合でもグローバルトランザクションを利用すること。  
  
・エンティティ、値オブジェクトにインターフェースは必要か？  
エンティティ同士の比較がエンティティの識別子で行われるようにequalsとhashcodeをオーバーライドするため必要があり、  
識別子の取得やクローン取得処理なども実装されるべきなのでインターフェースを用意すべき。  
値オブジェクトについても、equalsは全プロパティが同じならtrueを返すようにしないといけないが、そこはLombokのアノテーションの方がシンプルで良い。  
  
・CQRS的に、リポジトリの実装は更新系と参照系の両方のメソッドを持って良い？  
リポジトリの存在意義はドメインモデルをメモリ上にあるかのように見せることなので、ここにCQRSは適用しないほうが混乱しない。  
  
・port&adapter層のパッケージの切り方  
明確な答えはなさそう。まずは目的で切って後は任意とする。/目的/{目的}/…/方法/詳細が良いと考える。  
目的…web(http)の実装、モデルの永続化と取り出し、メッセージングのやりとり、通知、イベント通知、腐敗防止層(ドメインサービスの実装)  
方法…VIEW、API、DB、ファイル、メモリ、MQ、KVS  
詳細…LevelDB、RabbitMQ、Redis  
詳細は、方法(DB・MQ・KVS等)の実装の種類ごとにクラスが必要な場合（専用パッケージが必要だったりドライバーを共有できないなど）に用いる。  
例）  
web/view  
web/api  
persistence/db  
persistence/file  
persistence/eventsourcing/db  
persistence/eventsourcing/db  
messaging/mq  
notification/mq  
event/db  
event/kvs  
domainservice/  
eventとeventsourcingの違いは、eventは永続化目的でないこと。だからpersistence配下のパッケージではない。  
  
・リポジトリ実装の選択タイミングは？  
アプリケーション初期化時。  
springの機能で、config等でDI対象の実装を選択する。  
  
・実装したいところ  
別コンテキストとのREST連携  
CQRSの実装(アプリケーションサービスクラスの分け）  
CQRSの実装(イベント駆動によるクエリーモデルの作成）  
イベント駆動(パブリッシャー・サブスクライバ連携)によるイベントストア格納  
別コンテキストのイベントストア検知クライアント  
腐敗防止層の実装  
区分オブジェクトによるポリモーフィズムの実現  
施策の優先度の実装  
コンフィグファイルによる複数実装のDI切り替え  
自前のではなくSpringBootのバリデーション機能を使う  
  
・実装してみた所感  
CQRSはアプリケーション層の中でcommandとqueryでパッケージを分けた。  
commandの方は専用コマンド方式でクラスを作って、queryは分類方式とするとわかりやすかった。  
クエリーモデルをドメイン層に配置する実装もネットにあったが、IDDD書籍ではクエリーモデルはデータモデルと断言しており  
ドメインモデルではないのでやめた。  
アプリケーション層のqueryパッケージには〜Serviceという抽象クラスを追加して、その実装はport&adapter層においた。  
こうすることでヘキサゴナルアーキテクチャにおいてcommandと比較すると、単純にdomain層をスキップした形になってスッキリする。  
  
  
  
・そもそも腐敗防止層の目的って？  
上流モジュールと下流モジュールの関係が顧客/提供者の場合、下流モジュールは上流モジュールのインターフェース(提供してくるデータ)でモデルに変換する変換層を持つ。  
上流モジュールが、下流モジュールの言うことを全く聞いてくれない場合（関係が順応者）に、  
下流モジュール側は変換層が必要とするインターフェースを用意し、上流モジュールのインターフェース(提供してくるデータ)をそれに合わせる腐敗防止層を持つ。  
  
・spring bootでドメイン駆動設計を実現する  
  
  
・イベントストアフラッシュのタイミングは？  
  
  
・サービス指向って具体的にどんな実装？  
  
  
・なぜエンティティを使う？  
データに着目したCRUDシステム  
  
  
・エンティティの識別子の生成タイミング  
早期生成…エンティティ生成時に識別子を割り当てる  
遅延生成…エンティティ永続化時に識別子を割り当てる  
早期生成ではUUIDや、oracleのシーケンス機能が使える（MySQLならそれを模した物を作る）  
遅延生成はAutoIncrementが使える  
  
・境界づけられたコンテキスト間の結合方法にデータベースを介する場合はあるのか？  
共有データベースがあっても良いが、それだけでコンテキスト間の結合度が高まってしまう。  
そのため共有DBがダウンしたり運用ミスがあったりすると両方のコンテキストが使えなくなる。  
また概念的にも、同じレコードが両コンテキストで別々のモデルになるので、混乱を招く。  
少なくともDBのインスタンスを分けるべきだし、コストが厳しければスキーマを分ける。  
正しい形は、片方のコンテキストが公開ホストになりRESTfullなAPIでアクセスしてデータをもらうか、  
メッセージングを使うの2択。  
  
・コンテキスト間の結合の基本  
情報のやり取りの仕方は2種類  
・プログラミング言語のシリアライズ  
これは関係するシステムが同じシリアライズ機能に対応していることが前提。  
結合するコンテキスト間で同じクラス・インターフェース定義を保持する必要があるため二重管理となり変更に弱い。  
・標準化された中間フォーマットの利用  
JSONやXMLを利用してデータを共有する。通信するデータ量が増え、オブジェクトに変換するコストが高い。  
また強い型付けによる安全性を優先して、結局のところ結合するコンテキスト間で同じクラス・インターフェースを保持する場合もある。  
共有カーネルを用いてコンテキスト間でソースコードを共有することで二重管理を避けることもできるが、変更管理が複雑になる。  
結局どの方法が良いか？  
標準化された中間フォーマットで、型を共有しない方法が最良。  
コンテキスト間でドメインモデルを共有するという考え方は間違っている。各コンテキストで最良のドメインモデルがあるべき。  
そのため中間フォーマットでやり取りするのはデータだけで、別コンテキストのモデルの振る舞いを使おうとするべきではない。  
何よりデータのみのやり取りの方が疎結合である。  
データからモデルへの変換はport&adapter層で行う。  
  
・RESTfullなAPIはどのように設計する？  
クライアント側は可能な限り自立できるように、APIサーバー側にアクセスできなくても障害とならないように設計する。  
  
・メッセージングはどのように設計する？  
通知するイベントに発生時刻を持たせて、順番を維持すること。  
  
・RESTfullAPIとメッセージングはどっちが良い？  
RESTは多数のコンシューマーが単一のプロデューサーの発行するイベントに関心がある（Observerパターン）時に利用し、  
その逆の場合で、コンシューマー側が複数のプロデューサーから所定の手順でリソースを取得しないとタスクを実行できない場合は、メッセージングを利用する。  
RESTはコンシューマーのことを考慮しないので、RESTが返却するデータはプロデューサー側の都合で変わっていく。  
そのためコンシューマーが必要とするデータが取得できない可能性がある。  
コンシューマー側がデータの消失を恐れ、処理手順を大事にしているならば、そのコンシューマー向けにデータを用意しメッセージングを利用すべきだ。  
逆にRESTは多数のコンシューマー向けの汎用的なデータを提供する。  
  
・なぜメッセージングはイベントストアをポーリングする？イベントストアを介さずにメッセージキューにパブリッシュしても良い？  
イベントストアがない場合、キューイングに失敗した時にイベントが消失してしまうためコンテキストの自立性が低下してしまう。  
  
・連携のデータ量が多い場合はどうする？  
共有DBでデータを共有する？でも共有DBが落ちた時、連携している二つのコンテキストでリカバリ作業が必要になる。  
キューでデータを連携する？でもキューのサイズに限度がある。  
ファイル連携？  
  
・別コンテキストに毎回RESTでアクセスすると時間がかかるが、どうすれば良い？  
非同期でコンテキスト内にデータを持ってくる。重複管理となるがトレードOFF。  
  
・識別子以外のプロパティで検索する場合、リポジトリを使わないならどうするのか？  
クエリモデルから直接SQLでデータを取得し、集約(コマンドモデル)を作る  
  
・長期プロセスとは？  
イベント駆動で分散システムで並列処理を行うパターン。サーガとも呼ばれる。  
イベントを発行すると、複数の別コンテキストのイベント検知クライアントが並行に処理し、その結果をイベント発行元のコンテキストに返却する。  
イベント発行元コンテキストは並行処理の結果を突き合わせて、結果を保存する。  
  
・集約について  
集約の目的…不変条件を満たすこと。  
不変条件は「トランザクション整合性」か「結果整合性」の2種類。  
「トランザクション整合性」… 一つのトランザクションで保持される不変条件。  
「結果整合性」… 遅延するが保持される不変条件。  
基本的に一つのトランザクションでは、一つの集約しか変更できない。（※目標にすべきルール）  
ここで守られる不変条件はトランザクション整合性のことである。またこれを満たすために一つの大きな集約が作られがちである。  
しかし大きな集約はパフォーマンスに影響が出るため、ドメインイベントを用いた結果整合性で「小さな集約」にすることを検討すべき。  
小さな集約を設計していくと複数の集約の依存関係を解決する必要が出てくる。  
集約の依存関係の解決方法は2つある。  
「切り離されたドメインモデル」… 集約が内部でリポジトリやドメインサービスを利用して全ての依存関係を解決するテクニック  
「アプリケーションサービスによる解決」… アプリケーションサービスが集約のメソッドを実行する前に依存オブジェクトを検索し、引数に渡して解決するテクニック。  
「切り離されたドメインモデル」では集約の振る舞いに自由度が増して複雑になりやすく、意図せず複数の集約を変更してしまう。  
「アプリケーションサービスによる解決」では上記を予防できるが、依存関係の解決が複雑でドメインに特化している場合がある。  
その時は集約のメソッド引数にドメインサービスを渡し、ダブルディスパッチする。  
  
・ドメインサービスの役目は？  
集約のメソッドを実行するための依存関係の解決が複雑な場合にその責務を負う。（ダブルディスパッチ）  
複数種類の集約を連携させた結果を知りたいときに、そのメソッドがどの集約にも持たせるべきではない場合にその責務を負う。  
ある集約の複数形の処理がアプリケーション層で管理するには複雑な場合で、その処理メソッドを該当集約に持たせるべきではない場合にその責務を負う。  
ドメインオブジェクトをインフラストラクチャ層を経由して生成する責務を負う。  
※基本的に一つの処理で更新される集約は一つなので、ドメインサービスで集約の永続化は行わず、永続化は最終的な結果を受け取ったアプリケーションサービスで行う。  
  
・そもそもドメインとは？  
ドメイン（広義）=  組織が行う事業や、それを取り巻く世界。  
事業が市場（顧客）の定義し、プロダクトやサービスを販売する。  
様々な業務により事業は成り立つ。業務にはノウハウと物事の進め方がある。  
「どこかの組織のためのソフトウェアを作る = その組織のドメイン（事業を取り巻く世界）で作業する」  
  
・サブドメインとは？  
ドメイン（組織が行う事業）を成り立たせる、一つの業務を指す。  
業務は「〇〇を〜〜する」と表現でき、〇〇がサブドメインとして取り上げられる。  
  
・なんで戦略的設計が大事？  
サブドメインがハッキリすることで、システムが大きな泥団子にならない。  
コアドメインなのか、他のサブドメインから利用される汎用ドメインとなるかハッキリさせることができる。  
  
・ドメインモデリング  
アナリシスパターン  
「知識レベル」と「操作レベル」に分ける  

ドメインモデル内のバリデーションは  
・個別の属性/プロパティ  
・オブジェクト全体(集約)  
・オブジェクト(集約)同士の合成  
の3つの視点がある。  
  
属性やプロパティ(値オブジェクト)のバリデーション方法  
→自己カプセル化  
  
オブジェクト全体(集約)のバリデーション方法  
→仕様クラス  
  
オブジェクト(集約)同士の合成  
→ドメインサービスで複数の集約のバリデーション結果を取りまとめる。  
バリデーション方法は仕様クラスを用いる。  
  
  
値オブジェクト...   
ドメイン内の何かを計測したり定量化したり、あるいは説明したりする。  
例）年齢はその人が生まれてから何年経ったかを計測して定量化したもの。  
例）名前はその人がなんと呼ばれているのか説明したもの。  
値オブジェクトは一つあるいは複数の属性を保持している。それらが関連することで値について説明している。  
他と切り離した属性単体では意味のある内容が得られない。  
  
属性とプロパティの違い...   
親オブジェクトからの値オブジェクトへの参照は単なる属性などではない。  
これは親オブジェクトのプロパティでありモデル内のあるモノへの参照を保持しているものだ。  
  
仕様クラス...   
集約のルートにはドメインの振る舞いを扱う責務があるため、  
いくら集約の境界を参照できるとはいえバリデーションの責務を持たせると責務が増えすぎてしまう。  
そのため集約が仕様を満たしているかチェックする仕様クラスを用意し、集約のルートにvalidate()メソッドでそれを利用しチェックさせる。  
これを仕様パターンという。  
```  
  
