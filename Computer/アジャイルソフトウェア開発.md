# アジャイルアライアンス  
実践法（プラクティス）を持たずにプロジェクトを開始すると大抵失敗する。  
アジャイルアライアンスと呼ばれる業界のエキスパートの集まりが、プロジェクトにおいて何を重視すべきか  
を発表した。それはアジャイルアライアンス宣言と呼ばれる。  
  
# アジャイルアライアンス宣言  
### プロセスやツールよりも、人と人同士の交流を重視する  
よくコミュニケーションをとり、無駄なツールは使わない。  
### 包括的なドキュメントよりも、動作するソフトウェアを重視する  
重要で差し迫った必要のあるドキュメント以外は作成しない。  
チームに新しいメンバーが加わったら、ハンズオンで教えてあげる。  
### 契約上の交渉よりも、顧客との協調を重視する  
顧客は開発チームに頻繁にフィードバックしなければならない。  
最良の契約書とは、開発チームと顧客が協調する方法を示したものである。  
### 計画に従うことよりも、変化に対応することを重視する  
ビジネスの状況や、顧客の要求は変わりやすい。  
詳細な予定は次の2週間分だけにし、大まかな計画を3ヶ月分だけ作り、その先は大雑把にしておく。  
  
アジャイルプラクティスとは以上の4つに従ったプラクティスのことを指す。  
いくつかのアジャイルプラクティスを採用したアジャイルプロセスでプロジェクトを進める。  
アジャイルプラクティスたる原則がある。  
  
# アジャイルの原則  
### 最優先事項は顧客を満足させることであり、価値あるソフトウェアを早い段階から継続的に届けることでこれを実現する。  
最初に納品される機能が少なくて乏しいほど、最後の納品での品質はより高いものになるという報告がある。  
早い段階から頻繁に納品すること。  
  
### 要求変更を歓迎し、たとえ開発過程の後半であってもそれを受け入れる。アジャイルプロセスは、変化に対応することで顧客の競争上の優位性を確保する。  
アジャイルプロセスでは要求変更を歓迎する。  
変更に強いソフトウェアにする必要があるため、オブジェクト指向を使った設計の原則とパターンを適用する。  
  
### 実動可能なソフトウェアの納品を頻繁に行う。できるだけ短い期間で納品することを旨とし、数週間から数ヶ月間隔で納品する。  
実動可能なソフトウェアを早い段階から（最初の数週間のうちに）かつ頻繁に（数週間間隔で）納品する。  
ドキュメントやプランの提示だけでは十分ではない。  
  
### 顧客と開発者はプロジェクト全般を通じて日々ともに働かなければならない。  
プロジェクトをアジャイルに保つためには、顧客と開発者と決定権を持つ出資者は全て、密接なやり取りを頻繁に行うべきである。  
納品した後も継続的に面倒を見ていかなければならない。  
  
### やる気がある開発者をプロジェクトの中心に据え、彼らが必要とする環境とサポートを与え、信頼して仕事の完遂を任せる。  
アジャイルプロジェクトでは成功の鍵は「人」である。  
  
### 開発チームで情報を伝達する最も効果的な方法は、直接話し合うことである。  
主要なコミュニケーションの手段は会話である。  
  
### 実動するソフトウェアこそが進歩状況の尺度である。  
30%完成しているということは、必要な機能の30%が稼働しているという意味でなければならない。  
  
### 持続できるペースで開発する。そうすれば開発者も顧客も出資者もずっと一定のペースを確保できる。  
ペースを守り無理をしないこと。明日できることを今日やってしまおうとしないこと。  
最高の品質水準を保てるペースで仕事を進めること。  
  
### 高度な技術と優れた設計への配慮は、アジャイル性を高める。  
開発スピードを保つ鍵は「品質」である。  
ソフトウェアを可能な限り無駄のないものにしておくこと。  
  
### シンプルさが肝心。やらなくていいことはしない。  
いきなりシステム全体を作り上げようとせず、目的に叶う最もシンプルな方法を段階的に導入していく。  
明日発生するかもしれない問題を予測したり、それに前もって対処しようとしないこと。  
  
### 最高のアーキテクチャ、仕様要求、設計は自己管理能力のあるチームから生まれる。  
外部からの要求はチームの個人ではなく、チーム全体に伝えられ、チームは一丸となってその責務を果たす最善策を探し出す。  
各個人はチーム全体に対して意見することを許されている。  
個人がアーキテクチャ、仕様要求、テストに対して責任を負うことはない。  
  
### チームは定期的にプロジェクトを見直し、より効果的な方法を考え、対応方法の変更や調整を行う。  
アジャイルチームは組織や規則、慣例を常に見直すべきである。  
  
# エクストリームプログラミング（XP）  
アジャイルプロセスの一種。  
  
## XPを構成するアジャイルプラクティス  
### チームメンバーとしての顧客  
XPプロジェクトチームにとっての顧客とは、仕様の定義や優先順位の決定権を持つ個人またはグループである。  
物理的に近い場所で仕事することが望ましい。  
  
### ユーザーストーリー  
プロジェクトの計画を立てる段階では、仕様要求の詳細まで把握する必要はない。  
顧客との話し合いで同意した仕様要求（ユーザーストーリー）をインデックスカードやホワイトボードに書き留め保管する。  
そこで詳細を詰める必要はなく、大雑把な感覚に基づいた見積もりを一緒に記入するに留める。  
この情報はプランニングツールとなる。  
  
### 短期間のリリースサイクル  
XPプロジェクトでは、動くソフトウェアを2週間間隔でリリースする。この2週間をイテレーションと呼ぶ。  
- イテレーションプラン  
次回のイテレーション（2週間）で実装するユーザーストーリーを、開発者の見積もりをベースに顧客が選択したもの。  
開発者の見積もりとは、前回のイテレーションでこなした仕事量から算出した一つのイテレーションあたりの仕事量をさす。  
一旦イテレーションがスタートしたら、顧客は選択したストーリーや優先順位を変えてはならないことに同意している。  
開発者はストーリーをタスクレベルに分割して最も合理的な方法で実装していくことが許されている。  
実装された機能が最終製品に組み込まれるかどうかは決定していない。  
- リリースプラン  
次の6回分のイテレーションを一つにまとめたプランのこと。  
開発者の見積もりをベースに顧客が選択するが、顧客はいつでも内容を変更できる。  
もちろんスタートしているイテレーションプランの中身は変更できない。  
  
### 受け入れテスト  
XPにおける受け入れテストは、ユーザーストーリーの詳細を提示するものである。  
つまり受け入れテストはアプリが実際にデプロイされ、動作しなければならない。  
ツールを用いて自動的に繰り返し実行できるようにスクリプト言語で書かれ、そのストーリーの実装直前か実装と並行して作られる。  
※XPにはユニットテストと受け入れテストの2種類がある。  
  
### ペアプログラミング  
ペアプログラミングによりチーム内に知識を広める。  
ペアは少なくとも1日に1回組み替える。  
  
### テストファーストの開発  
テスト駆動開発により、コードの変更時に正常に動作するかどうかのチェックが簡単になるため気軽にリファクタリングができる。  
また当然ながらコードがテスト可能なものとなるため、自然と独立性（分離性）が高くなる。  
  
### 共同所有権  
共同作業をしているペアはどんなモジュールでもチェックし、かつ改善する権利がある。  
個人がモジュールや技術に責任を負うことはない。  
  
### 継続的なインテグレーション  
プログラマは競合を気にすることなくバージョン管理システムからチェックアウトし、修正しプッシュして良い。（早いもの勝ち）  
競合を発生させた人が、対象のプログラマと話し合いながらそれを解決する。  
プッシュの度にユニットテスト、受け入れテストが実行される。  
  
### 持続可能なペース  
節度を保った一定のペースで、活力と集中力を維持しなければならない。  
XPでは残業は許されない。ただしリリースの最後の週だけは例外で、全速力で走れば間に合う場合のみ、残業は許される。  
  
### オープンワークスペース  
チームはオープンな部屋で共に作業する。各ペアは他のペアの声が聞こえる程度の距離にいて、  
困った時に気づけるようにしておく。  
  
### 計画ゲーム（プランニング）  
ビジネス側と開発側の責任の切り分けを行う。  
ビジネス側（顧客）は各機能の重要度を決定する。  
開発側は、その機能を組み込むために必要なコストを見積もる。  
開発側は、直前のイテレーションやリリースの完了にかかった期間を参考に、1イテレーションあたりの作業量を見積もる。  
ビジネス側（顧客）はイテレーションやリリースの初めに、見積もりを越えないように組み込みたいストーリーを選択する。  
  
### シンプルな設計  
XPではできる限りシンプルかつ拡張性のある設計にする。  
以下の三つのスローガンが役に立つ。  
##### なんとか動くだけの最もシンプルなものを考えよう  
最初からミドルウェアを利用したりしない。  
##### 後で必要になんてならないよ  
XPチームは、そのインフラは必要ではないという仮定からスタートする。  
##### 同じことは2度しない  
コードの重複を許さない。SOLID原則とデザインパターンを用いて抽象化する。  
  
### リファクタリング  
リファクタリングは頻繁に行う。1日の終わりでも、イテレーションの最後でも、リリースの最後でも、プロジェクトの最後でもなく、  
1時間おきか30分おき程度で行うものである。  
少しでも変更を食え会えたらすぐにユニットテストを行って何も壊していないことを確認する。  
  
### メタファー  
プランニングにおいて、直前のイテレーションやリリースの完了にかかった期間を参考にして1イテレーションあたりの作業量を見積もったように、  
既存の知っていることとの類似を通して理解する考え方。  
  
# クラス設計の原則  
## 単一責任の原則（SRP : Single Responsibility Principle）  
クラスを変更する理由は1つ以上存在してはならない。  
  
クラスにはシステムの要求仕様に答える役割がある。  
システムの要求仕様には「将来的に変更される仕様」と「変更されない仕様」の2種類がある。  
  
この原則では「役割 ＝ 責任 ＝ 変更理由」と定義しているので  
単一責任とは、2つ以上の「将来的に変更される仕様」に答えてはならないという意味である。  
  
クラスを設計する際には、クラスが2つ以上の「将来的に変更される仕様」に答えていないか確認すること。  
  
## オープン・クローズドの原則（OCP : Open-Closed Principle）  
ソフトウェアの構成要素（クラス、モジュール、関数（メソッド））は拡張に対し開いて（オープン : Open）いて、  
修正に対し閉じて（クローズド : Closed）いなければならない。  
  
システムの要求仕様の変更が、新しいコードの追加だけで実現できる（オープン）  
つまり既存のコードに修正を加える必要がない（クローズド）  
  
これは「抽象」に依存することで実現できる。  
要求仕様の変更に対応する「抽象」の具象クラスを追加すれば良い。  
  
具象クラス同士に順番（順位）をつけたい場合、OCPに則るためには工夫が必要である。  
具象クラスは増え続ける（または減る）ものなので、それらの比較処理をメソッドに書いてしまうと原則に違反する。  
実現方法は2つあり、一つはテーブル駆動型アプローチと呼ばれるもので  
テーブル（実際には配列など）に具象クラスの順番を表現しておき、メソッドがそれを利用して判定する。  
このテーブルだけがクローズドになっていないので他のモジュール等に切り離す。  
もう一つの方法は「Acyclic Visitorパターン」を利用する。  
  
## リスコフの置換原則（LSP : Liskov Substitution Principle）  
派生クラスは基本クラスと置換可能でなければならない。  
  
この原則は何かが便利になるものではなく、オープン・クローズドの原則（OCP）でトラブルにならないために  
守るべき原則である。  
  
OCPではクライアントが「抽象（基本クラス）」に依存するため、依存対象は基本クラスの場合もあれば  
その派生クラスの場合もある。  
クライアントは基本クラス型の変数を扱うため、基本クラスでできることを前提に処理を進める。そのとき  
基本クラスでは出来るのに派生クラスでは「出来ない処理」があると、OCPに基づいていざ基本クラス型の変数に  
派生クラスが入った時に、クライアントは気づくことなく「出来ない処理」を呼んでしまい不具合となる。  
この場合この派生クラスは「リスコフの置換原則に違反している」と表現できる。  
※「出来ない処理」とはクライアントが意図しない動作をする処理のことを指す。  
  
これを防ぐためには「契約による設計」にルールを課す。  
#### 契約による設計  
契約による設計とは、クライアントと実装側の間に「契約」を締結させる設計手法である。  
この「契約」とは、お互いが義務を果たせば正当な権利を得られるというものである。  
  
| 当事者 | 果たす義務 | 得られる権利 |  
|:-----------|:-----------|:-----------|  
| クライアント | 事前条件を満たす | 目的の処理が成功する（事後条件が満たされる） |  
| 実装側 | 事後条件を満たす | 処理が適切に呼ばれる（事前条件が満たされる） |  
  
- 事前条件  
実装側の処理を呼ぶ前に成立しておかなければならない条件  
- 事後条件  
実装側の処理が終了したときに成立しておかなければならない条件  
  
事前条件・事後条件のどちらも実装側が定義するものであり、ここに以下のルールを課す。  
```  
派生クラスのメソッドは  
事前条件を基本クラスと等しいか、それより弱い条件に、  
事後条件を基本クラスと等しいか、それより強い条件にする  
```  
こうすることでクライアントが派生クラスを呼べない（事前条件を満たせない）ことがなくなり、  
目的を果たせなくなる（事後条件を満たせない）こともなくなる。  
  
リスコフの置換原則違反コードの解決法として、共通部分の「くくりだし」というテクニックがある。  
これは派生クラスと基本クラスの共通部分を新たな「抽象」としてくくりだし、両者をその「抽象」に対して  
派生させる。こうすることで基本クラス型の変数に派生クラスが混入することがなくなる。  
※これは実装初期で有効な方法で、すでに多くの場所で原則違反コードがある場合は難しいが可能な限り実施すべきである。  
  
## 依存関係逆転の原則（DIP : Dependency Inversion Principle）  
上位のモジュールが下位のモジュールに依存してはならず、どちらも「抽象」に依存すべきである。  
  
アプリケーションの方針を定めている上位モジュールで変更があれば、下位モジュールにも影響が伝達するのが通常である。  
しかし上位のモジュールが下位のモジュールのクラスに依存している（参照を持っている）と、  
下位モジュールで修正があり、そのクラスのシグネチャに変更があったとき上位モジュールを修正しなければならない。  
アプリケーションの方針は変わっていないのに上位モジュールに修正があることは間違っている。  
  
そのため処理の流れは上位モジュール→下位モジュールでも、依存関係は逆転していなければならない。  
上位モジュールは、その中でインターフェースや抽象クラス（まとめて「抽象」とする）を定め、それに依存する。  
下位モジュールは、上位モジュールの「抽象」を実装する。  
  
こうすることで下位モジュールの変更は「抽象」に吸収され、上位モジュールの変更は必要なくなる。  
結果として下位モジュールが上位モジュールの「抽象」に依存している。  
  
「抽象」につける名前は、下位モジュールで幅広く実装されることを想定していることはもちろん、  
上位モジュールでも様々なクラスから依存されることを想定したものにすること。  
  
## インターフェース分離の原則（ISP : The Interface Segregation Principle）  
クライアントに、クライアントが利用しないメソッドへの依存を強制してはならない。  
  
この原則はリスコフの置換原則（LSP）と同じくオープン・クローズドの原則（OCP）  
でトラブルにならないために守るべき原則である。  
  
派生クラス（A）の一部だけが利用するインターフェース（a）を基本クラスにまで実装させてしまうとトラブルになる。  
インターフェース（a）を利用しない別の派生クラス（B）では対象メソッドを退化させなければならずLSPに違反する。  
さらに派生クラス（B）では使わないインターフェース（a）の定義をインポートすることになる。  
  
さらに重大なトラブルは「クライアントは自分が利用するインターフェースに影響力を持つ」ということに起因する。  
これはクライアントの要求が変更されることは避けらず、それにより実装側のインターフェースに変更が加わることも  
避けられないという意味である。  
  
上記の例では派生クラス（A）のクライアントによるインターフェース（a）変更は、基本クラスや派生クラス（B）にまで加わる。  
したがって本来関係のない基本クラスや派生クラス（B）のクライアントまで影響を受けてしまう。  
  
それを防ぐためにインターフェースを分離する。その方法は2つある。  
- 委譲による分離  
インターフェース（a）の実装クラス（A'）を作り、処理は派生クラス（A）に委譲する  
実装クラス（A'）のファクトリは派生クラス（A）に持たせる  
- 多重継承による分離  
インターフェース（a）と基本クラスを継承した派生クラス（A）を作る  
  
委譲による分離は処理時間とメモリを浪費するので、可能であれば多重継承による分離を用いる。  
  
# パッケージ設計の原則  
パッケージは利用するユーザーの視点に立って構造化（何らかの基準・原則に沿って整理）されていなければならない。  
## 再利用・リリース等価の原則（REP : Reuse-Rlelease Equivalency Principle）  
再利用の単位（パッケージ）がリリース単位になる。  
  
大前提としてオブジェクト指向における再利用（新しいコードを書くときに既存のクラス・インターフェースを継承・委譲・実装すること）は  
パッケージ単位で行われる。（あるパッケージの中の一つのクラスだけを自分のプロジェクトに持ってきて再利用することはない）  
  
つまりクラスライブラリを作ることはパッケージを作るという意味になる。  
クラスライブラリ（パッケージ）の作者は保守することを期待され、新しいバージョンをリリースするときは  
オプションで古いバージョンを利用できるようにトラッキング（追跡管理）しておかなければならない。  
   
## 全再利用の原則（CRP : Common Reuse Principle）  
ユーザーがパッケージを利用する場合、そこに含まれる全てのクラスに依存しなければならない。  
  
あるパッケージの新バージョンがリリースされたとき、たとえパッケージ内の一部のクラスへの変更しかなくても、  
そのパッケージを利用しているパッケージは再評価・再リリースされる必要がある。それが、全く利用していない箇所への変更であっても。  
  
そのため、パッケージを採用する際は、そこに含まれる全てのクラスに依存していなければならないし、  
パッケージを作る際は、利用する側が全てのクラスに依存するように設計しなければならない。  
  
そうすることで必要以上の再評価・再リリースを抑制する。  
再利用されるソフトウェアを含むパッケージには、再利用されないソフトウェアは入れてはいけない、とも言える。  
  
##   閉鎖性共通の原則（CCP : Common Closure Principle）  
パッケージは変更する理由を複数持ってはいけない。  
パッケージの変更理由は、そこに含まれる全てクラスに影響するが他のパッケージには全く影響しない。  
  
「単一責任の原則」のパッケージ版であり、同じ理由で変更されるクラスを一つのパッケージにまとめる。  
そうすることで仕様変更時に影響を受けるパッケージ数を最小限に抑え、再評価・再リリースを抑制する。  
関係のないソフトウェアが一つのパッケージに含まれてはいけない、とも言える。  
  
## 非循環依存関係の原則（ADP : Acyclic Dependencies Principle）  
パッケージ依存グラフに循環があってはならない。  
  
ビルド（コンパイル→テスト→リンク）はボトムアップで行われるため、最初は「どこにも依存していないパッケージ」から始まる。  
やがて「依存先パッケージが揃ったパッケージ」が処理されていき、最後に「どこからも依存されていないパッケージ」を処理して完了になる。  
  
あるパッケージが循環依存していると、そのパッケージがいつまで経っても「依存先パッケージが揃ったパッケージ」にならないため、  
ボトムアップで処理できなくなる。  
そのパッケージのテストをする際も「依存先パッケージが揃ったパッケージ」にするために  
循環依存先の全パッケージをコンパイル・リンクしなければならない。  
  
循環を断つために「依存関係逆転の原則」を利用するか、新しいパッケージを作って依存クラスを配置させる。  
  
パッケージ依存グラフはアプリケーションの機能を表現するものではなく、ビルド方法を示すマップである。  
  
## 安定依存の原則（SDP : Stable Dependencies Priciple）  
パッケージは安定する方向に依存しなければならない。  
  
- 安定なパッケージの条件  
  - 責任を負う  
  多くの他パッケージから依存されるため、このパッケージの変更理由が増えて変更されにくい。つまり  
  全ての他パッケージに変更がある場合にのみこのパッケージが変更される。  
  ※他パッケージの一つに変更がある場合はその依存先として新パッケージを作ればよい。  
  - 独立している  
  他パッケージに依存していないため、他パッケージの変更の影響を受けず変更されにくい。  
- 不安定なパッケージの条件  
  - 責任を負わない  
  他パッケージから依存されていないため、変更理由が一つで変更されやすい。  
  - 独立していない（依存している）  
  他パッケージに依存しているため、他パッケージの変更の影響を受けやすく変更されやすい。  
  
安定なパッケージが不安定なパッケージに依存していると、不安定ゆえの変更が安定なパッケージの変更につながり、  
安定なパッケージに依存している多くのパッケージがまた変更を必要としてしまう。  
  
それを防ぐために、パッケージは自分より安定なパッケージに依存しなければならない。  
  
## 安定度・抽象度等価の原則（SAP : Stable Abstractions Principle）  
パッケージの安定度と抽象度は同程度でなければならない。  
  
システムをどのように設計するのかを決定しているパッケージは安定度は高くあって欲しい。  
しかし安定度が高いことにより、実装がやりにくくなってしまう。  
そのため、安定度の高いパッケージはその拡張性を失わないためにも抽象的でなければならない。  
  
抽象度は、パッケージ中の抽象クラスの数が多いほど高くなる。  
  
```  
抽象度が高いパッケージは多くから参照されても良い。  
詳細な実装を含むパッケージはできるだけ参照されてはならない。  
```  
後者のパッケージは良く変更されるため、変更がある度にこれを参照しているパッケージも再テスト再リリースが必要になってしまう。  
この原則を実現しているパッケージは、アプリケーションの主系列に沿っていると言う。  
  
## 経験則    
仕事で既存システムの追加改修があり、新しい「抽象」と実装を作って、新しいパッケージにその一部か全てを含めることにした。  
まずは全体のパッケージ依存グラフを書いて俯瞰し、そこに「非循環依存関係の原則（ADP）」に違反しないように  
新しいパッケージとクラスを配置してみると、いくつかの案に絞れた。  
次に「安定依存の原則（SDP）」と「閉鎖性共通の原則（CCP）」から、どの案が良いか考えたら答えが出た。  
  
# 給与システムのケーススタディ  
給与システムを構築する中で必要な知識と設計手法  
## Command パターンと Active Object パターン  
#### Command パターン  
「動作」を表現するクラスをOCPで運用する。  
  
本来オブジェクト指向における動作は、メソッドが与えられたパラメータとクラス・インスタンス変数を用いて実現するが、  
Commandパターンではそれを唯一のメソッドにカプセル化する。  
  
クライアントはOCPにより様々なCommandオブジェクトを単純（与えるパラメータを気にせず）に呼び出すことで処理が可能になる。  
  
#### Active Object パターン  
Commandパターンの利用方法の一つ。Commandオブジェクトをキューやスタックで管理し実行を管理する。  
  
## Templete Method パターンと Strategy パターン  
どちらも上位レベルの（土台となる）アルゴリズムを下位レベル（詳細）から切り離す。継承や委譲により実現できる。  
#### Templete Method パターン  
継承を利用する。  
抽象（abstract）クラスのメソッドにおいて、コアとなるビジネスロジックを派生クラスが実装する。  
抽象がabstractの場合、派生クラスが、抽象クラスのパラメータやクラス・インスタンス変数に依存してしまう場合がある。  
そうなると依存関係逆転の原則（DIP）の「抽象に依存すべき」に違反する。  
また、派生クラスの再利用が不可能である。  
  
#### Strategy パターン  
委譲を利用する。  
抽象クラスのメソッドにおいて、コアとなるビジネスロジックを「別の抽象」に依存する。  
抽象クラス→「別の抽象」の依存関係になり、  
「別の抽象」は派生クラスに実装されるので  
派生クラス→「別の抽象」の依存関係にもなる。（DIPに違反していない）  
  
Strategyパターンでは「別の抽象」の派生クラスを、抽象クラス以外の様々なクラスから利用できるメリットもある。  
委譲を利用しているので処理時間とメモリを浪費するが、可能であればTemplete MethodではなくStrategyパターンを利用すべきである。  
  
![Template MethodパターンとStrategyパターン](/Picture/アジャイルソフトウェア開発2.png "Template MethodパターンとStrategyパターン")  
  
## Facade パターンと Mediator パターン  
どちらもオブジェクトに方針（動作）を強制するときに利用する。  
#### Facade パターン  
Facadeクラスは別オブジェクト群の複雑な操作方法をラップする。  
Facadeクラスはユーザーが明示的に利用する。  
そのため「Facadeを使うこと」という約束をチームですることが前提となる。  
  
#### Mediator パターン  
Mediatorクラスは別オブジェクトの動作の中に仕込まれる。  
Mediatorクラスはユーザーから隠されているため、強制的に受け入れられる。  
  
※ObserverパターンとMediatorパターンについて  
Observerパターンは1つの監視対象オブジェクトの変更通知を受け取るためのパターンで、  
Mediatorパターンは複数の監視対象オブジェクト間の通信をカプセル化するためのパターンであるが、  
そのどちらも監視するクラスと、監視されるクラスを持つ。  
  
大きな違いを以下の図に示す。  
![ObserverパターンとMediatorパターン](/Picture/アジャイルソフトウェア開発.PNG "ObserverパターンとMediatorパターン")  
  
<details>  
  <summary>Observer パターン(PUSH型)の例</summary>  
  
```  
    /** PUSH型Observerパターン **/  
    interface PatientWatcher { // 患者を監視する者  
        void check(WatchedPatient watchedPatient);  
    }  
  
    class Doctor implements PatientWatcher { // 医者（一人の患者の専属の医者）  
        private String myPatient = "OK";  
  
        @Override  
        public void check(WatchedPatient watchedPatient) {  
            this.myPatient = watchedPatient.getCondition();  
        }  
    }  
  
    class Family implements PatientWatcher { // 家族  
        private String myFamily = "OK";  
  
        @Override  
        public void check(WatchedPatient watchedPatient) {  
            this.myFamily = watchedPatient.getCondition();  
        }  
    }  
  
    abstract class WatchedPatient { // 監視される患者  
        List<PatientWatcher> watcher = new ArrayList<>(); // 自分を監視する者を複数持つ  
  
        public void setWatcher(PatientWatcher patientWatcher) {  
            this.watcher.add(patientWatcher);  
        }  
  
        public void execute() { // TemplateMethodパターンを利用  
            this.watchedAction();  
            this.notifyWatchers();  
        }  
  
        private void notifyWatchers() {  
            for (PatientWatcher watcher : this.watcher) {  
                watcher.check(this);  
            }  
        }  
  
        abstract protected void watchedAction(); // 監視される行動  
        abstract protected String getCondition(); // 通知内容  
    }  
  
    class BadTooth extends WatchedPatient { // 虫歯の患者  
        private String myCondition = "OK";  
  
        @Override  
        protected void watchedAction() {  
            // ご飯を食べる、歯を磨く  
            this.myCondition = "OK";  
        }  
  
        @Override  
        protected String getCondition() {  
            return this.myCondition;  
        }  
    }  
  
    class Client {  
        public void main(){  
            WatchedPatient badTooth = new BadTooth();  
            PatientWatcher doctor = new Doctor();  
            PatientWatcher family = new Family();  
            badTooth.setWatcher(doctor);  
            badTooth.setWatcher(family);  
  
            badTooth.execute();  
        }  
    }  
```  
</details>  
  
<details>  
  <summary>Observer パターン(PULL型)の例</summary>  
  
```  
    /** PULL型Observerパターン **/  
    interface Watcher { // 監視する者  
        void check(); // PULL型は、何をチェックする自由に実装する  
        void setTarget(Watched target); // PULL型は、監視対象を設定する  
    }  
  
    class Doctor implements Watcher { // 医者（一人の患者の専属の医者）  
        private Patient patient;  
        private String myPatient = "OK";  
  
        @Override  
        public void check() {  
            this.myPatient = patient.isOk();  
        }  
  
        @Override  
        public void setTarget(Watched target) {  
            this.patient = (Patient) target;  
        }  
    }  
  
    abstract class Watched { // 監視される者  
        List<Watcher> watcher = new ArrayList<>(); // 自分を監視する者を複数持つ  
  
        public void setWatcher(Watcher watcher) {  
            this.watcher.add(watcher);  
            watcher.setTarget(this);  
        }  
  
        public void execute() { // TemplateMethodパターンを利用  
            this.watchedAction();  
            this.notifyWatchers();  
        }  
  
        private void notifyWatchers() {  
            for (Watcher watcher : this.watcher) {  
                watcher.check();  
            }  
        }  
  
        abstract protected void watchedAction(); // 監視される行動  
    }  
  
    class Patient extends Watched { // 患者  
        private String myCondition = "OK";  
  
        @Override  
        protected void watchedAction() {  
            // ご飯を食べる、歯を磨く  
            this.myCondition = "OK";  
        }  
  
        public String isOk() {  
            return this.myCondition;  
        }  
    }  
```  
</details>  
  
<details>  
  <summary>Mediator パターンの例</summary>  
  
```  
    interface Watcher { // 監視する者  
        boolean check(Watched watched);  
        void addTarget(Watched target); // 監視対象が複数  
    }  
  
    class Doctor implements Watcher { // 医者（複数の患者を担当する医者）  
        private List<Patient> patientList = new ArrayList<>();  
  
        @Override  
        public boolean check(Watched watched) {  
            for (Patient patient : this.patientList) {  
                // 担当する患者全員の予約時刻がcheck対象の予約とバッティングしている  
                return false;  
            }  
            return true;  
        }  
  
        @Override  
        public void addTarget(Watched target) {  
            this.patientList.add((Patient) target);  
        }  
    }  
  
    abstract class Watched { // 監視される者  
        Watcher watcher; // 自分を監視する者は一人だけ  
  
        public void setWatcher(Watcher watcher) {  
            this.watcher = watcher;  
        }  
  
        public void execute() { // TemplateMethodパターンを利用  
            if (watcher.check(this)) {  
                this.okAction();  
            }  
        }  
  
        abstract protected void okAction(); // 監視する者からOKが出た行動  
    }  
  
    class Patient extends Watched { // 患者  
        private String bookingTime;  
        private String hopeTime;  
  
        @Override  
        protected void okAction() {  
            // 予約する  
            this.bookingTime = this.hopeTime;  
        }  
  
        public String setHopeTime(String hopeTime) {  
            return this.hopeTime = hopeTime;  
        }  
    }  
  
    class Client {  
        public void main(){  
            Patient patient1 = new Patient();  
            patient1.setHopeTime("明日10時");  
  
            Patient patient2 = new Patient();  
            patient2.setHopeTime("明日2時");  
  
            Watcher doctor = new Doctor();  
            doctor.addTarget(patient1);  
            doctor.addTarget(patient2);  
  
            patient1.execute();  
        }  
    }  
```  
</details>  
  
## Singleton パターンとMonostate パターン  
どちらもオブジェクトの唯一性（特異性）を保証する。  
  
#### Singleton パターン  
Singletonオブジェクトは唯一のインスタンスである。  
インスタンス変数に状態を保存する。  
メソッドコールがシリアライズできる。  
処理時間とメモリを節約できる。  
  
Singletonオブジェクトの派生クラスには保存された状態は引き継がれない。（別インスタンスであるため）  
唯一インスタンスの保証（プライベートなコンストラクタ）も引き継がれない。  
※つまり派生クラスはSingletonオブジェクトではない。（再度Singletonにする必要がある）  
  
Singletonではないクラスの派生クラスをSingletonにすることは可能である。  
  
適切なミドルウェア（Java Remote Method Invocation：RMI）により別プラットフォームで共有可能。  
  
#### Monostate パターン  
Monostateオブジェクトは複数のインスタンスとなる。  
クラス変数に状態を保存する。  
  
Monostateオブジェクトの派生クラスには保存された状態は引き継がれる。  
加えてポリモーフィズムを実現できる。（オートマトンの実装が可能）  
※つまり派生クラスはMonostateオブジェクトである。  
  
Monostateではないクラスの派生クラスをMonostateにすることは不可能。  
  
別プラットフォームで共有不可能。  
<details>  
  <summary>Monostate パターンの例</summary>  
  
```  
public class Human {  
    protected final static Human HAPPY = new Happy();  
    protected final static Human SAD = new Sad();  
    protected static Human itsState = HAPPY;  
  
    public void walk() {  
        itsState.walk();  
    }  
  
    public void talk() {  
        itsState.talk();  
    }  
  
    public void work() {  
        itsState.work();  
    }  
}  
  
public class Happy extends Human {  
  
    public void walk() {  
        // るんるん;  
    }  
  
    public void talk() {  
        // ハキハキ；  
    }  
  
    public void work() {  
        // ミスをした  
        itsState = SAD;  
    }  
}  
  
public class Sad extends Human {  
  
    public void walk() {  
        // トボトボ  
    }  
  
    public void talk() {  
        // ボソボソ  
    }  
  
    public void work() {  
        // うまくいった  
        itsState = HAPPY;  
    }  
}  
```  
</details>  
  
## Null Object パターン  
#### Null Object パターン  
派生クラスの一つとして、何もしないオブジェクトを定義しておく。  
クライアント側のNullチェックが必要なくなる。  
  
抽象のstaticメンバとしてNullObjectを持たせるとよい。  
<details>  
  <summary>Null Object パターンの例</summary>  
  
```  
    interface Employee {  
        void pay();  
        public static final Employee NULL = new Employee() {  
            @Override  
            public void pay() {/* 何もしない */}  
        };  
    }  
```  
</details>  
  
## Factory パターン  
以下のように「new」がある場合、それだけで具象クラスに依存しているということなので  
「抽象に依存すべき」という原則に違反する。  
```  
Circle c = new Circle();  
```  
実際、生成したいインスタンスを差し替えることが不可能になるし、クラス名が変更されるだけで  
様々な箇所のソースコードを変更しなければならない。  
したがってFactoryを用意する。  
クランアントが依存するFactoryも当然「抽象」である。  
テストにFactoryを用いる「なりすまし（スプーフィング）」という技術もある。  
  
・ファクトリー系パターンの目的  
1. クラスから依存オブジェクト生成の責務を取り払うこと。  
2. オープン・クローズドの原則、依存関係逆転の原則で言及される「抽象に依存せよ」に則ること。  
  
### ファクトリーの軌跡  
#### 最初の状態  
![Factoryパターン1](/Picture/アジャイルソフトウェア開発3.png "最初の状態")  
<details>  
  <summary>最初の状態</summary>  
  
```  
public class Main {  
    public void main() {  
        A a = new A();  
        a.method1();  
        a.method2();  
    }  
}  
  
class A {  
    public void method1(){}  
    public void method2(){}  
}  
```  
</details>  
  
#### オブジェクト生成と振る舞いの分離(1)  
![Factoryパターン2](/Picture/アジャイルソフトウェア開発4.png "オブジェクト生成と振る舞いの分離")  
シンプルなファクトリーメソッドを用意。  
<details>  
  <summary>シンプルなファクトリーメソッド</summary>  
  
```  
public class Main {  
    public void main() {  
        A a = aFactoryMethod();  
        a.method1();  
        a.method2();  
    }  
  
    public A aFactoryMethod() {  
        return new A();  
    }  
}  
  
class A {  
    public void method1(){}  
    public void method2(){}  
}  
```  
</details>  
  
#### staticファクトリーメソッドパターン(1)  
![Factoryパターン3](/Picture/アジャイルソフトウェア開発5.png "staticファクトリーメソッドパターン")  
目的：  
依存オブジェクト生成と振る舞いを分離する(1)  
メリット：  
コンストラクタと異なり任意の名前をつけることができる。  
シングルトンの実装が可能。  
抽象クラスに定義し、メソッドの戻り値を任意のサブクラスにすることができる。  
必要なパラメータだけを引数に取れる。（複数のstaticファクトリーメソッドを用意できる）  
<details>  
  <summary>staticファクトリーメソッドパターン（具象クラスに定義）</summary>  
  
```  
public class Main {  
    public void main() {  
        A a = A.makeWithNoArg();  
        a.method1();  
        a.method2();  
    }  
}  
  
class A {  
	// コンストラクタ使用不可  
    private A(){}  
      
    public static A makeWithNoArg() {  
        return new A();  
    }  
  
    public void method1(){}  
    public void method2(){}  
}  
```  
</details>  
<details>  
  <summary>staticファクトリーメソッドパターン（抽象クラスに定義）</summary>  
  
```  
public class Main {  
    public void main() {  
        C c = C.makeCImpl1();  
        c.method1();  
        c.method2();  
    }  
}  
  
interface C {  
    public static C makeCImpl1() {  
        return new CImpl1();  
    }  
  
    public void method1();  
    public void method2();  
  
}  
  
class CImpl1 implements C {  
    public void method1(){}  
    public void method2(){}  
}  
```  
</details>  
  
#### 単一責任の原則の適用(1)  
![Factoryパターン4](/Picture/アジャイルソフトウェア開発6.png "単一責任の原則の適用")  
シンプルなファクトリークラスを用意。  
<details>  
  <summary>単一責任の原則の適用</summary>  
  
```  
public class Main {  
    public void main() {  
        AFactory aFactory = new AFactory();  
        A a = aFactory.makeAWithNoArg();  
        a.method1();  
        a.method2();  
    }  
}  
  
class A {  
    public void method1(){}  
    public void method2(){}  
}  
  
class AFactory {  
    public A makeAWithNoArg() {  
        return new A();      
    }  
}  
```  
</details>  
  
#### 「抽象に依存せよ」をファクトリークラスに適用する(1, 2)  
![Factoryパターン5](/Picture/アジャイルソフトウェア開発7.png "「抽象に依存せよ」をファクトリークラスに適用する")  
ファクトリークラスを  
Interfaceか、  
Abstract（Template Methodパターンを用いる場合など）  
として抽象化し、実装する。  
拡張が容易で、テスト用のモックファクトリーも利用できる。  
<details>  
  <summary>「抽象に依存せよ」をファクトリークラスに適用する（Interfaceに依存する）</summary>  
  
```  
public class Main {  
    public void main() {  
        AFactory aFactory = new AFactoryImpl();  
        A a = aFactory.makeAWithNoArg();  
        a.method1();  
        a.method2();  
    }  
}  
  
class A {  
    public void method1(){}  
    public void method2(){}  
}  
  
interface AFactory {  
    public A makeAWithNoArg();  
}  
  
class AFactoryImpl implements AFactory {  
    @Override  
    public A makeAWithNoArg() {  
        return new A();  
    }  
}  
  
class MockAFactory implements AFactory {  
    @Override  
    public A makeAWithNoArg() {  
        return new A(){  
            // テスト用の処理  
        };  
    }  
}  
```  
</details>  
<details>  
  <summary>「抽象に依存せよ」をファクトリークラスに適用する（Abstractに依存する）</summary>  
  
```  
public class Main {  
    public void main() {  
        AFactory aFactory = new AFactoryImpl();  
        A a = aFactory.create();  
        a.method1();  
        a.method2();  
    }  
}  
  
class A {  
    public void method1(){}  
    public void method2(){}  
}  
  
abstract class AFactory {  
    public final A create() {  
        A a = this.makeAWithNoArg();  
        this.register(a);  
        return a;  
    }  
      
    abstract A makeAWithNoArg();  
    abstract void register(A a);  
}  
  
class AFactoryImpl extends AFactory {  
    @Override  
    public A makeAWithNoArg() {  
        return new A();  
    }  
  
    @Override  
    void register(A a) {  
        // 永続化処理など  
    }  
}  
```  
</details>  
  
#### ファクトリーパターン(1, 2)  
![Factoryパターン6](/Picture/アジャイルソフトウェア開発8.png "ファクトリーパターン")  
「抽象に依存せよ」の拡張で、依存オブジェクトも抽象化する。  
一つの具象ファクトリークラスは全ての具象依存オブジェクトを生成する。  
具象依存オブジェクト毎にメソッドに分けるか、一つのメソッドにまとめてパラメータで管理する。  
<details>  
  <summary>ファクトリーパターン（具象依存オブジェクト毎にメソッドに分ける）</summary>  
  
```  
public class Main {  
    public void main() {  
        AFactory aFactory = new AFactoryImpl();  
        A a = aFactory.makeAaaWithNoArg();  
        a.method1();  
        a.method2();  
        a = aFactory.makeAbbWithNoArg();  
        a.method1();  
        a.method2();  
    }  
}  
  
interface A {  
    public void method1();  
    public void method2();  
}  
  
class Aaa implements A {  
    @Override  
    public void method1(){}  
    @Override  
    public void method2(){}  
}  
  
class Abb implements A {  
    @Override  
    public void method1(){}  
    @Override  
    public void method2(){}  
}  
  
  
interface AFactory {  
    Aaa makeAaaWithNoArg();  
    Abb makeAbbWithNoArg();  
}  
  
class AFactoryImpl implements AFactory {  
    @Override  
    public Aaa makeAaaWithNoArg() {  
        return new Aaa();  
    }  
  
    @Override  
    public Abb makeAbbWithNoArg() {  
        return new Abb();  
    }  
}  
```  
</details>  
<details>  
  <summary>ファクトリーパターン（一つのメソッドにまとめてパラメータで管理する）</summary>  
  
```  
public class Main {  
    public void main() {  
        AFactory aFactory = new AFactoryImpl();  
        A a = aFactory.make("Aaa");  
        a.method1();  
        a.method2();  
        a = aFactory.make("Abb");  
        a.method1();  
        a.method2();  
    }  
}  
  
interface A {  
    public void method1();  
    public void method2();  
}  
  
class Aaa implements A {  
    @Override  
    public void method1(){}  
    @Override  
    public void method2(){}  
}  
  
class Abb implements A {  
    @Override  
    public void method1(){}  
    @Override  
    public void method2(){}  
}  
  
  
interface AFactory {  
    A make(String param);  
}  
  
class AFactoryImpl implements AFactory {  
    @Override  
    public A make(String param) {  
        if (param.equals("Aaa")) {  
            return new Aaa();  
        }  
        if (param.equals("Abb")) {  
            return new Abb();  
        }  
        return null;  
    }  
}  
```  
</details>  
  
#### ファクトリーメソッドパターン(1, 2)  
![Factoryパターン7](/Picture/アジャイルソフトウェア開発9.png "ファクトリーメソッドパターン")  
「抽象に依存せよ」の拡張で、依存オブジェクトも抽象化する。  
Template Methodパターンの応用パターンという位置付け。  
Template Methodパターンを使っている前提のため具象依存オブジェクト毎に具象ファクトリークラスを用意する。  
ファクトリーパターンよりもクラス数が増えるが、拡張性が高まり区分オブジェクト(DDD)との相性も良い。  
<details>  
  <summary>ファクトリーメソッドパターン</summary>  
  
```  
public class Main {  
    public void main() {  
        AFactory aFactory = new AaaFactory();  
        A a = aFactory.create();  
        a.method1();  
        a.method2();  
    }  
}  
  
interface A {  
    public void method1();  
    public void method2();  
}  
  
class Aaa implements A {  
    @Override  
    public void method1(){}  
    @Override  
    public void method2(){}  
}  
  
class Abb implements A {  
    @Override  
    public void method1(){}  
    @Override  
    public void method2(){}  
}  
  
  
abstract class AFactory {  
    public final A create() {  
        A a = this.makeAWithNoArg();  
        this.register(a);  
        return a;  
    }  
  
    abstract A makeAWithNoArg();  
    abstract void register(A a);  
}  
  
class AaaFactory extends AFactory {  
    @Override  
    public A makeAWithNoArg() {  
        return new Aaa();  
    }  
  
    @Override  
    void register(A a) {  
        // Aaa用の永続化処理など  
    }  
}  
  
class AbbFactory extends AFactory {  
    @Override  
    A makeAWithNoArg() {  
        return new Abb();  
    }  
  
    @Override  
    void register(A a) {  
        // Abb用の永続化処理など  
    }  
}  
```  
</details>  
  
#### アブストラクトファクトリーパターン(1, 2)  
![Factoryパターン8](/Picture/アジャイルソフトウェア開発10.png "アブストラクトファクトリーパターン")  
依存オブジェクトが複数ある場合、それぞれの具象クラスの組み合わせをファクトリーで定義する。  
抽象の階層を持つオブジェクトのファクトリーに渡すパラメーターを解決する場合にも利用できる。  
抽象の階層を持つオブジェクトのファクトリーに、依存オブジェクトのファクトリー（ファクトリーメソッドパターン）を渡すことで  
アブストラクトファクトリーパターンを利用せずに済みそうだが、ファクトリーは複数のメソッドを持ち様々な状態の具象オブジェクトを作成するため、  
抽象の階層を持つオブジェクトのファクトリーは、ファクトリーを受け取ってもどのメソッドを使ってオブジェクトを取得すれば良いかわからない。  
そのためアブストラクトファクトリーパターンか、個別のファクトリー（ファクトリーパターンorファクトリーメソッドパターン）で依存を解決して、  
目的のオブジェクトのファクトリーにパラメーターとして渡す。  
<details>  
  <summary>アブストラクトファクトリーパターン（具象クラスの組み合わせをファクトリーで定義）</summary>  
  
```  
public class Main {  
    public void main() {  
        AlphabetFactory alphabetFactory = new AlphabetFactoryImple1();  
        A a = alphabetFactory.makeA();  
        B b = alphabetFactory.makeB();  
        a.method1();  
        a.method2();  
        b.method1();  
        b.method2();  
    }  
}  
  
interface A {  
    void method1();  
    void method2();  
}  
  
class Aaa implements A {  
    @Override  
    public void method1(){}  
    @Override  
    public void method2(){}  
}  
  
class Abb implements A {  
    @Override  
    public void method1(){}  
    @Override  
    public void method2(){}  
}  
  
interface B {  
    void method1();  
    void method2();  
}  
  
class Bbb implements B {  
    @Override  
    public void method1(){}  
    @Override  
    public void method2(){}  
}  
  
class Bcc implements B {  
    @Override  
    public void method1(){}  
    @Override  
    public void method2(){}  
}  
  
interface AlphabetFactory {  
    A makeA();  
    B makeB();  
}  
  
class AlphabetFactoryImple1 implements AlphabetFactory {  
    @Override  
    public A makeA() {  
        return new Aaa();  
    }  
  
    @Override  
    public B makeB() {  
        return new Bbb();  
    }  
}  
```  
</details>  
<details>  
  <summary>アブストラクトファクトリーパターン（抽象の階層を持つオブジェクトのファクトリー（ファクトリーメソッドパターン）に渡すパラメーターを解決に利用）</summary>  
  
```  
public class Main {  
    public void main() {  
        AlphabetFactory alphabetFactory = new AlphabetFactoryImple1();  
        A a = alphabetFactory.makeA();  
        B b = alphabetFactory.makeB();  
          
        CFactory cccFactory = new CccFactory();  
        C ccc = cccFactory.make(a, b);  
        ccc.method1();  
        ccc.method2();  
          
        CFactory cddFactory = new CddFactory();  
        C cdd = cddFactory.make(a, b);  
        cdd.method1();  
        cdd.method2();  
    }  
}  
  
interface A {  
    void method1();  
    void method2();  
}  
  
class Aaa implements A {  
    @Override  
    public void method1(){}  
    @Override  
    public void method2(){}  
}  
  
class Abb implements A {  
    @Override  
    public void method1(){}  
    @Override  
    public void method2(){}  
}  
  
interface B {  
    void method1();  
    void method2();  
}  
  
class Bbb implements B {  
    @Override  
    public void method1(){}  
    @Override  
    public void method2(){}  
}  
  
class Bcc implements B {  
    @Override  
    public void method1(){}  
    @Override  
    public void method2(){}  
}  
  
interface AlphabetFactory {  
    A makeA();  
    B makeB();  
}  
  
class AlphabetFactoryImple1 implements AlphabetFactory {  
    @Override  
    public A makeA() {  
        return new Aaa();  
    }  
  
    @Override  
    public B makeB() {  
        return new Bbb();  
    }  
}  
  
abstract class C {  
    A a;  
    B b;  
    public C(A a, B b) {  
        this.a = a;  
        this.b = b;  
    }  
  
    abstract void method1();  
    abstract void method2();  
}  
  
class Ccc extends C {  
    public Ccc(A a, B b) {  
        super(a, b);  
    }  
  
    @Override  
    void method1(){}  
    @Override  
    void method2(){}  
}  
  
class Cdd extends C {  
    public Cdd(A a, B b) {  
        super(a, b);  
    }  
  
    @Override  
    void method1(){}  
    @Override  
    void method2(){}  
}  
  
// ファクトリーメソッドパターン  
interface CFactory {  
    C make(A a, B b);  
}  
  
class CccFactory implements CFactory {  
    @Override  
    public C make(A a, B b) {  
        return new Ccc(a, b);  
    }  
}  
  
class CddFactory implements CFactory {  
    @Override  
    public C make(A a, B b) {  
        return new Cdd(a, b);  
    }  
}  
```  
</details>  
  
・ビルダーパターン(1)  
構造を持ったインスタンスを組み上げるパターン。  
DDDでアプリケーションサービスクラスに渡すコマンドオブジェクトを作る時に使えるかも。  
https://qiita.com/disc99/items/840cf9936687f97a482b  
  
  
・どのファクトリーを使うかは誰が決めるのか？  
クライアントクラス（今回はMainクラス）が決める。  
どの具象クラスを選択すべきかをクライアントは知らないほうが良い。  
結局のところ、クライアントは自身の「種別」や「環境」に応じてファクトリーを使い分けることになる。  
「種別」の場合は区分オブジェクトを使うと良い。  
区分オブジェクトは強力だが、ファクトリーパターンの場合、一つの具象ファクトリークラスが複数の具象依存オブジェクトを  
生成するため相性が悪い。一つの具象ファクトリークラスが、生成する具象依存オブジェクトを決定しているファクトリーメソッドパターンや  
アブストラクトファクトリーパターンの場合は相性が良い。  
  
## ユースケースを使った分析  
XPにおけるユーザーストーリーを詳細にしたもの。  
まずはユースケースを実現できるクラス設計を考えて行く。  
  
システムは以下で構成されることを意識し、まずはドメインオブジェクトを設計していく。  
```  
ドメインオブジェクト(Entity,ValueObject,Service) ＋ 集約の概念 ＋ ファクトリ ＋ リポジトリ  
```  
ユースケースはユーザーの操作と結果が含まれるため、それを実現するオブジェクトは自然とServiceに近くなる。  
SOLID原則を意識すること。  
  
## 継承か委譲か  
従業員の給与体系に3種の分類があるとして、その分類は従業員オブジェクトの継承で実現するか、別オブジェクトの委譲で実現すべきか。  
  
継承を利用する場合、給与計算ロジックを抽象化するとTemplate Methodパターンになる。  
委譲の場合はStrategyパターンになる。  
  
給与計算ロジックは従業員オブジェクト以外からも再利用されるべきだろうからStrategyパターンの方が良い。  
また継承を利用している場合は、ある従業員の給与体系が変更されたとき(時給→固定給)、別の従業員サブクラスに変更しなければならないが、  
委譲なら従業員クラスがもつ給与体系クラスを変更するだけで良い。  
  
基本的に委譲で実現できるのならその方が良い。  
  
## 抽象化の意識  
種類、種別があると抽象化のチャンスである。  
  
決して、種類ごとにサブクラスを作るような考えは持ってはいけない。  
  
「全ての〜〜は〇〇できる」  
〇〇に入る「振る舞い」に種類ごとの差分があれば、その振る舞いのインターフェースを定義し、差分を実装する。  
  
うまく抽象化できたとしても、その実装クラスがもつ固有のロジックや値にも注意しなければならない。  
それらには後に変更がありそうで、さらにその実装クラスが持たなくても自然な場合は上位に切り出した方が良い。  
給与分類を例にする。  
3種類の給与分類ごとに支払日が決まっているときに、給与分類の1種を表す実装クラスが、支払日判定ロジックを持っているとする。  
仕様に変更があり、従業員が指定した支払日にできるとき、同じ実装クラスの中でも支払日判定ロジックを変えなければならない。  
支払日判定ロジックの変更が、本来関係のない給与計算ロジックに影響を与える可能性も出てきてしまう。  
  
つまり支払日判定ロジックは上位の、従業員オブジェクトが持つべきだったことがわかる。  
無駄に下位のモジュールにロジックを埋め込むと、別のロジックに影響を与えやすくなる。  
また、そもそも単一責任の原則に違反している場合が多い。  
  
## パッケージング  
### 閉鎖性共通の原則の適用  
関連しあうクラスだけでパッケージングする。  
関係ないクラスを同じパッケージに含めない。  
  
### 依存関係逆転の原則の適用  
抽象クラスと実装クラスを別パッケージにする。  
  
そうすることで、実装パッケージ（システムの詳細）が抽象パッケージ（システムのアーキテクチャ）に依存する形になる。  
これは依存関係逆転の原則に従い、実装パッケージに変更があっても、抽象パッケージを再リリースする必要がなくなる。  
  
つまり抽象パッケージの再利用も簡単になる。  
  
### 再利用・リリース等価の原則の適用  
再利用したいパッケージに余計なクラスを含めない。  
  
しかしながら、どのような再利用をしたいのか、どのくらいの頻度でアプリケーションに変更されるのかを考え、  
必要ないのならば無理にこの原則を適用する必要はない。パッケージが増えるだけ。  
  
### 安定度・抽象度等価の原則の適用  
詳細な実装クラスを含むパッケージは、それだけ別のパッケージから依存されることが多くなる。  
そのパッケージ内でしか利用しない実装クラスはパッケージプライベートにして依存されないようにする。  
  
##### Factory パターンを適用する  
実装クラスパッケージは他のパッケージからnewするためどうしても多くの参照がある。  
対策として1つの実装クラスパッケージに対し、一つのFactoryパッケージを用意する。  
FactoryパッケージにはFactoryインターフェースを配置し、Factoryの実装は実装クラスパッケージに持たせる。  
  
