# クラス設計の原則  
## 単一責任の原則（SRP : Single Responsibility Principle）  
クラスを変更する理由は1つ以上存在してはならない。  
  
クラスにはシステムの要求仕様に答える役割がある。  
システムの要求仕様には「将来的に変更される仕様」と「変更されない仕様」の2種類がある。  
  
この原則では「役割 ＝ 責任 ＝ 変更理由」と定義しているので  
単一責任とは、2つ以上の「将来的に変更される仕様」に答えてはならないという意味である。  
  
クラスを設計する際には、クラスが2つ以上の「将来的に変更される仕様」に答えていないか確認すること。  
  
## オープン・クローズドの原則（OCP : Open-Closed Principle）  
ソフトウェアの構成要素（クラス、モジュール、関数（メソッド））は拡張に対し開いて（オープン : Open）いて、  
修正に対し閉じて（クローズド : Closed）いなければならない。  
  
システムの要求仕様の変更が、新しいコードの追加だけで実現できる（オープン）  
つまり既存のコードに修正を加える必要がない（クローズド）  
  
これは「抽象」に依存することで実現できる。  
要求仕様の変更に対応する「抽象」の具象クラスを追加すれば良い。  
  
具象クラス同士に順番（順位）をつけたい場合、OCPに則るためには工夫が必要である。  
具象クラスは増え続ける（または減る）ものなので、それらの比較処理をメソッドに書いてしまうと原則に違反する。  
実現方法は2つあり、一つはテーブル駆動型アプローチと呼ばれるもので  
テーブル（実際には配列など）に具象クラスの順番を表現しておき、メソッドがそれを利用して判定する。  
このテーブルだけがクローズドになっていないので他のモジュール等に切り離す。  
もう一つの方法は「Acyclic Visitorパターン」を利用する。  
  
## リスコフの置換原則（LSP : Liskov Substitution Principle）  
派生クラスは基本クラスと置換可能でなければならない。  
  
この原則は何かが便利になるものではなく、オープン・クローズドの原則（OCP）でトラブルにならないために  
守るべき原則である。  
  
OCPではクライアントが「抽象（基本クラス）」に依存するため、依存対象は基本クラスの場合もあれば  
その派生クラスの場合もある。  
クライアントは基本クラス型の変数を扱うため、基本クラスでできることを前提に処理を進める。そのとき  
基本クラスでは出来るのに派生クラスでは「出来ない処理」があると、OCPに基づいていざ基本クラス型の変数に  
派生クラスが入った時に、クライアントは気づくことなく「出来ない処理」を呼んでしまい不具合となる。  
この場合この派生クラスは「リスコフの置換原則に違反している」と表現できる。  
※「出来ない処理」とはクライアントが意図しない動作をする処理のことを指す。  
  
これを防ぐためには「契約による設計」にルールを課す。  
#### 契約による設計  
契約による設計とは、クライアントと実装側の間に「契約」を締結させる設計手法である。  
この「契約」とは、お互いが義務を果たせば正当な権利を得られるというものである。  
  
| 当事者 | 果たす義務 | 得られる権利 |  
|:-----------|:-----------|:-----------|  
| クライアント | 事前条件を満たす | 目的の処理が成功する（事後条件が満たされる） |  
| 実装側 | 事後条件を満たす | 処理が適切に呼ばれる（事前条件が満たされる） |  
  
- 事前条件  
実装側の処理を呼ぶ前に成立しておかなければならない条件  
- 事後条件  
実装側の処理が終了したときに成立しておかなければならない条件  
  
事前条件・事後条件のどちらも実装側が定義するものであり、ここに以下のルールを課す。  
```  
派生クラスのメソッドは  
事前条件を基本クラスと等しいか、それより弱い条件に、  
事後条件を基本クラスと等しいか、それより強い条件にする  
```  
こうすることでクライアントが派生クラスを呼べない（事前条件を満たせない）ことがなくなり、  
目的を果たせなくなる（事後条件を満たせない）こともなくなる。  
  
リスコフの置換原則違反コードの解決法として、共通部分の「くくりだし」というテクニックがある。  
これは派生クラスと基本クラスの共通部分を新たな「抽象」としてくくりだし、両者をその「抽象」に対して  
派生させる。こうすることで基本クラス型の変数に派生クラスが混入することがなくなる。  
※これは実装初期で有効な方法で、すでに多くの場所で原則違反コードがある場合は難しいが可能な限り実施すべきである。  
  
## 依存関係逆転の原則（DIP : Dependency Inversion Principle）  
上位のモジュールが下位のモジュールに依存してはならず、どちらも「抽象」に依存すべきである。  
  
アプリケーションの方針を定めている上位モジュールで変更があれば、下位モジュールにも影響が伝達するのが通常である。  
しかし上位のモジュールが下位のモジュールのクラスに依存している（参照を持っている）と、  
下位モジュールで修正があり、そのクラスのシグネチャに変更があったとき上位モジュールを修正しなければならない。  
アプリケーションの方針は変わっていないのに上位モジュールに修正があることは間違っている。  
  
そのため処理の流れは上位モジュール→下位モジュールでも、依存関係は逆転していなければならない。  
上位モジュールは、その中でインターフェースや抽象クラス（まとめて「抽象」とする）を定め、それに依存する。  
下位モジュールは、上位モジュールの「抽象」を実装する。  
  
こうすることで下位モジュールの変更は「抽象」に吸収され、上位モジュールの変更は必要なくなる。  
結果として下位モジュールが上位モジュールの「抽象」に依存している。  
  
「抽象」につける名前は、下位モジュールで幅広く実装されることを想定していることはもちろん、  
上位モジュールでも様々なクラスから依存されることを想定したものにすること。  
  
## インターフェース分離の原則（ISP : The Interface Segregation Principle）  
クライアントに、クライアントが利用しないメソッドへの依存を強制してはならない。  
  
この原則はリスコフの置換原則（LSP）と同じくオープン・クローズドの原則（OCP）  
でトラブルにならないために守るべき原則である。  
  
派生クラス（A）の一部だけが利用するインターフェース（a）を基本クラスにまで実装させてしまうとトラブルになる。  
インターフェース（a）を利用しない別の派生クラス（B）では対象メソッドを退化させなければならずLSPに違反する。  
さらに派生クラス（B）では使わないインターフェース（a）の定義をインポートすることになる。  
  
さらに重大なトラブルは「クライアントは自分が利用するインターフェースに影響力を持つ」ということに起因する。  
これはクライアントの要求が変更されることは避けらず、それにより実装側のインターフェースに変更が加わることも  
避けられないという意味である。  
  
上記の例では派生クラス（A）のクライアントによるインターフェース（a）変更は、基本クラスや派生クラス（B）にまで加わる。  
したがって本来関係のない基本クラスや派生クラス（B）のクライアントまで影響を受けてしまう。  
  
それを防ぐためにインターフェースを分離する。その方法は2つある。  
- 委譲による分離  
インターフェース（a）の実装クラス（A'）を作り、処理は派生クラス（A）に委譲する  
実装クラス（A'）のファクトリは派生クラス（A）に持たせる  
- 多重継承による分離  
インターフェース（a）と基本クラスを継承した派生クラス（A）を作る  
  
委譲による分離は処理時間とメモリを浪費するので、可能であれば多重継承による分離を用いる。  
  
# パッケージ設計の原則  
パッケージは利用するユーザーの視点に立って構造化（何らかの基準・原則に沿って整理）されていなければならない。  
## 再利用・リリース等価の原則（REP : Reuse-Rlelease Equivalency Principle）  
再利用の単位（パッケージ）がリリース単位になる。  
  
大前提としてオブジェクト指向における再利用（新しいコードを書くときに既存のクラス・インターフェースを継承・委譲・実装すること）は  
パッケージ単位で行われる。（あるパッケージの中の一つのクラスだけを自分のプロジェクトに持ってきて再利用することはない）  
  
つまりクラスライブラリを作ることはパッケージを作るという意味になる。  
クラスライブラリ（パッケージ）の作者は保守することを期待され、新しいバージョンをリリースするときは  
オプションで古いバージョンを利用できるようにトラッキング（追跡管理）しておかなければならない。  
   
## 全再利用の原則（CRP : Common Reuse Principle）  
ユーザーがパッケージを利用する場合、そこに含まれる全てのクラスに依存しなければならない。  
  
あるパッケージの新バージョンがリリースされたとき、たとえパッケージ内の一部のクラスへの変更しかなくても、  
そのパッケージを利用しているパッケージは再評価・再リリースされる必要がある。それが、全く利用していない箇所への変更であっても。  
  
そのため、パッケージを採用する際は、そこに含まれる全てのクラスに依存していなければならないし、  
パッケージを作る際は、利用する側が全てのクラスに依存するように設計しなければならない。  
  
そうすることで必要以上の再評価・再リリースを抑制する。  
再利用されるソフトウェアを含むパッケージには、再利用されないソフトウェアは入れてはいけない、とも言える。  
  
##   閉鎖性共通の原則（CCP : Common Closure Principle）  
パッケージは変更する理由を複数持ってはいけない。  
パッケージの変更理由は、そこに含まれる全てクラスに影響するが他のパッケージには全く影響しない。  
  
「単一責任の原則」のパッケージ版であり、同じ理由で変更されるクラスを一つのパッケージにまとめる。  
そうすることで仕様変更時に影響を受けるパッケージ数を最小限に抑え、再評価・再リリースを抑制する。  
関係のないソフトウェアが一つのパッケージに含まれてはいけない、とも言える。  
  
## 非循環依存関係の原則（ADP : Acyclic Dependencies Principle）  
パッケージ依存グラフに循環があってはならない。  
  
ビルド（コンパイル→テスト→リンク）はボトムアップで行われるため、最初は「どこにも依存していないパッケージ」から始まる。  
やがて「依存先パッケージが揃ったパッケージ」が処理されていき、最後に「どこからも依存されていないパッケージ」を処理して完了になる。  
  
あるパッケージが循環依存していると、そのパッケージがいつまで経っても「依存先パッケージが揃ったパッケージ」にならないため、  
ボトムアップで処理できなくなる。  
そのパッケージのテストをする際も「依存先パッケージが揃ったパッケージ」にするために  
循環依存先の全パッケージをコンパイル・リンクしなければならない。  
  
循環を断つために「依存関係逆転の原則」を利用するか、新しいパッケージを作って依存クラスを配置させる。  
  
パッケージ依存グラフはアプリケーションの機能を表現するものではなく、ビルド方法を示すマップである。  
  
## 安定依存の原則（SDP : Stable Dependencies Priciple）  
パッケージは安定する方向に依存しなければならない。  
  
- 安定なパッケージの条件  
  - 責任を負う  
  多くの他パッケージから依存されるため、このパッケージの変更理由が増えて変更されにくい。つまり  
  全ての他パッケージに変更がある場合にのみこのパッケージが変更される。  
  ※他パッケージの一つに変更がある場合はその依存先として新パッケージを作ればよい。  
  - 独立している  
  他パッケージに依存していないため、他パッケージの変更の影響を受けず変更されにくい。  
- 不安定なパッケージの条件  
  - 責任を負わない  
  他パッケージから依存されていないため、変更理由が一つで変更されやすい。  
  - 独立していない（依存している）  
  他パッケージに依存しているため、他パッケージの変更の影響を受けやすく変更されやすい。  
  
安定なパッケージが不安定なパッケージに依存していると、不安定ゆえの変更が安定なパッケージの変更につながり、  
安定なパッケージに依存している多くのパッケージがまた変更を必要としてしまう。  
  
それを防ぐために、パッケージは自分より安定なパッケージに依存しなければならない。  
  
## 安定度・抽象度等価の原則（SAP : Stable Abstractions Principle）  
パッケージの安定度と抽象度は同程度でなければならない。  
  
システムをどのように設計するのかを決定しているパッケージは安定度は高くあって欲しい。  
しかし安定度が高いことにより、実装がやりにくくなってしまう。  
そのため、安定度の高いパッケージはその拡張性を失わないためにも抽象的でなければならない。  
  
抽象度は、パッケージ中の抽象クラスの数が多いほど高くなる。  
  
## 経験則    
仕事で既存システムの追加改修があり、新しい「抽象」と実装を作って、新しいパッケージにその一部か全てを含めることにした。  
まずは全体のパッケージ依存グラフを書いて俯瞰し、そこに「非循環依存関係の原則（ADP）」に違反しないように  
新しいパッケージとクラスを配置してみると、いくつかの案に絞れた。  
次に「安定依存の原則（SDP）」と「閉鎖性共通の原則（CCP）」から、どの案が良いか考えたら答えが出た。  
  
# 給与システムのケーススタディ  
給与システムを構築する中で必要な知識と設計手法  
## Command パターンと Active Object パターン  
#### Command パターン  
「動作」を表現するクラスをOCPで運用する。  
  
本来オブジェクト指向における動作は、メソッドが与えられたパラメータとクラス・インスタンス変数を用いて実現するが、  
Commandパターンではそれを唯一のメソッドにカプセル化する。  
  
クライアントはOCPにより様々なCommandオブジェクトを単純（与えるパラメータを気にせず）に呼び出すことで処理が可能になる。  
  
#### Active Object パターン  
Commandパターンの利用方法の一つ。Commandオブジェクトをキューやスタックで管理し実行を管理する。  
  
## Templete Method パターンと Strategy パターン  
どちらも上位レベルの（土台となる）アルゴリズムを下位レベル（詳細）から切り離す。継承や委譲により実現できる。  
#### Templete Method パターン  
継承を利用する。  
抽象（abstract）クラスのメソッドにおいて、コアとなるビジネスロジックを派生クラスが実装する。  
抽象がabstractの場合、派生クラスが、抽象クラスのパラメータやクラス・インスタンス変数に依存してしまう場合がある。  
そうなると依存関係逆転の原則（DIP）の「抽象に依存すべき」に違反する。  
また、派生クラスの再利用が不可能である。  
  
#### Strategy パターン  
委譲を利用する。  
抽象クラスのメソッドにおいて、コアとなるビジネスロジックを「別の抽象」に依存する。  
抽象クラス→「別の抽象」の依存関係になり、  
「別の抽象」は派生クラスに実装されるので  
派生クラス→「別の抽象」の依存関係にもなる。（DIPに違反していない）  
  
Strategyパターンでは「別の抽象」の派生クラスを、抽象クラス以外の様々なクラスから利用できるメリットもある。  
委譲を利用しているので処理時間とメモリを浪費するが、可能であればTemplete MethodではなくStrategyパターンを利用すべきである。  
  
## Facade パターンと Mediator パターン  
どちらもオブジェクトに方針（動作）を強制するときに利用する。  
### Facade パターン  
Facadeクラスは別オブジェクト群の複雑な操作方法をラップする。  
Facadeクラスはユーザーが明示的に利用する。  
そのため「Facadeを使うこと」という約束をチームですることが前提となる。  
  
#### Mediator パターン  
Mediatorクラスは別オブジェクトの動作の中に仕込まれる。  
Mediatorクラスはユーザーから隠されているため、強制的に受け入れられる。  
  
## Singleton パターンとMonostate パターン  
どちらもオブジェクトの唯一性（特異性）を保証する。  
  
#### Singleton パターン  
Singletonオブジェクトは唯一のインスタンスである。  
インスタンス変数に状態を保存する。  
メソッドコールがシリアライズできる。  
処理時間とメモリを節約できる。  
  
Singletonオブジェクトの派生クラスには保存された状態は引き継がれない。（別インスタンスであるため）  
唯一インスタンスの保証（プライベートなコンストラクタ）も引き継がれない。  
※つまり派生クラスはSingletonオブジェクトではない。（再度Singletonにする必要がある）  
  
Singletonではないクラスの派生クラスをSingletonにすることは可能である。  
  
適切なミドルウェア（Java Remote Method Invocation：RMI）により別プラットフォームで共有可能。  
  
#### Monostate パターン  
Monostateオブジェクトは複数のインスタンスとなる。  
クラス変数に状態を保存する。  
  
Monostateオブジェクトの派生クラスには保存された状態は引き継がれる。  
加えてポリモーフィズムを実現できる。（オートマトンの実装が可能）  
※つまり派生クラスはMonostateオブジェクトである。  
  
Monostateではないクラスの派生クラスをMonostateにすることは不可能。  
  
別プラットフォームで共有不可能。  
