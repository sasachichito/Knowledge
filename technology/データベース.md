・アーキテクチャ  
OSがディスクに対して可能な最少アクセス単位はセレクタ  
一度のアクセスで１セレクタしか取得出来ないと不便なので、幾つかのセレクタをまとめたブロックという単位でアクセスする  
  
RDBMSはテーブルやインデックス等のオブジェクト毎に、ディスクに一定の領域（数ブロック分）を確保する。この領域をエクステントという。  
エクステント内にはページという論理区画が複数用意される。ページは数ブロック分のサイズである。  
RDBMSがOSにディスクアクセスを依頼するときは、ページ単位のやりとりとなる。  
  
テーブルエクステントのページには、ページのメタ情報、[rowId => レコードデータのポインタ, ...]配列(レコードディレクトリ)、空き領域、レコードデータの順で格納されている。  
空きがあるページをフリーリストとしてRDBMSが管理しており、適当なページの空きにレコードデータが追加されていくため、レコード順序は守られていない。  
あるページのレコードデータを取得するときは、レコードディレクトリの配列をなめていきレコードデータのポインタから取得する  
  
インデックスエクステントのページには、ページのメタ情報、B木構造の[キー => レコードデータのポインタ, ...]配列が格納される  
この配列はキーでソートされており、ソートアルゴリズムは？？？  
探索アルゴリズムはニ分探索  
詳細⇒http://itpro.nikkeibp.co.jp/article/COLUMN/20060113/227231/  
  
インデックスページは4種類  
プライマリーキーページ...テーブルに一つだけ＋キーに重複が無い＋NULLがない  
ユニークキーページ...キーに重複が無い  
マルチプルキーページ...特に制約はない  
複合キーページ...二つのキーの組み合わせでユニークとなる[第1キー：第2キー => レコードポインタ, ...]となり、第1キーでソートされる。  
第1キーだけWHERE句で指定するとソートされているのでインデックスを利用できるが、第2キーは第1キーが重複している分だけソートされているので、インデックスを使用できない  
詳細⇒http://use-the-index-luke.com/ja/sql/where-clause/the-equals-operator/concatenated-keys  
DESCで確認できる  
  
・SQL  
RDBMSはSQLを実行するまでに、三つのプログラムが連携する  
【構文解析プログラム】  
【プランナ（オプティマイザ）プログラム】  
【実行プログラム】  
  
【構文解析プログラム】  
SQLがRDBMSに渡されると、構文解析プログラムがそれを受け取る  
これは、SQLを分解し、構文ツリーを作成する  
データベースの情報（カタログという）を確認し、整合性が確保出来たらプランナ(オプティマイザ)プログラムに構文ツリーを渡す。  
  
【プランナ（オプティマイザ）プログラム】  
構文ツリーから、論理プランを作成する  
論理プランとは、最終的にSQLに対する回答を得ることができる、テーブルに対する関係代数演算（選択、射影、結合など）の一連の流れのこと。  
論理プランは、関係代数の規則や性質を利用して、出来るだけ結合の回数が少ないプランが選ばれる。  
論理プラン中の一つの関係代数演算に対応する実装モジュールは複数用意されており、一つの論理プランの実行方法（物理プラン）は複数ある。  
複数の物理プランから、カタログを利用して、もっとも処理時間が短いものを選択し、その物理プランを実行プログラムに渡す。（コストベースオプティマイザの場合）  
※ルールベースオプティマイザではカタログは使用せず、アクセスパス（物理プラン）の順位表から選択される  
  
【実行プログラム】  
物理プランを実行する。  
  
RDBMSがテーブルを「結合」（関係代数演算）する際に利用するアルゴリズムには，  
「ネスト・ループ結合」Nested Loop 結合  
「マージ結合」  
「ハッシュ結合」  
の三つがあげらる。  
MySQL には 「結合」に対応するモジュールは一つしかなく、そのモジュールはネスト・ループ結合を使っている。  
  
ネストループ結合は最初にアクセスする表(外部表、駆動表とも呼ばれる)をフェッチし、  
そのフェッチしたデータと結合可能なデータを内部表から(インデックスがあれば利用して)検索する処理をループして結合します。  
結合の詳細⇒http://www.atmarkit.co.jp/ait/articles/0408/25/news101.html  
  
・実行計画（どの物理プランを使うか検討する）  
論理プラン中の関係代数演算「選択」を、物理プラン中ではインデックススキャンモジュールにするか、フルスキャンモジュールにするかが主な要因となる。  
  
重要となるインデックスについて詳細にみていく　⇒　参考 http://use-the-index-luke.com/ja  
インデックスによる検索は、(1) ツリーを走査し、(2) リーフノードチェーンをたどり、(3) テーブルからデータを読み出す、という3ステップで行われます。  
Oracleデータベースではインデックスを使った基本的な検索の方法を表す、以下のような3つのはっきりした区分があります。  
INDEX UNIQUE SCAN  
木の走査しか行いません。Oracleデータベースでは、ユニーク制約により、検索条件が 必ず1つしかないことが確実な場合に、この方法を使います。  
INDEX RANGE SCAN  
一致する全ての エントリを探すために、木の走査に加えて リーフノードチェーンをたどった検索も行います。検索条件に対して複数のエントリが存在する可能性がある場合の代替策です。  
TABLE ACCESS BY INDEX ROWID  
テーブルから行を読み出します。この操作は、直前に行われたインデックス スキャンの結果から、一致するレコードを読み出すために行われます。  
  
実際の処理を考えると、  
１．ユニークなインデックスを利用して、インデックスカラムのみ読みだす... INDEX UNIQUE SCAN  
２．ユニークでないインデックスを利用して、インデックスカラムのみ読みだす... INDEX RANGE SCAN  
３．ユニークなインデックスを利用して、複数カラムを読みだす... INDEX UNIQUE SCAN　⇒　TABLE ACCESS BY INDEX ROWID  
４．ユニークでないインデックスを利用して、複数カラムを読みだす... INDEX RANGE SCAN　⇒　TABLE ACCESS BY INDEX ROWID  
となる  
  
インデックスを遅くする完璧な組み合わせは、広い範囲のインデックス探索と、たくさんの行を1行ずつ読み出す処理です。（４．で対象が大量な場合）  
この場合は、インデックスがあろうと、フルスキャンモジュールを使用した物理プランを選択してほしい。  
そうさせるためには、カタログを最新にしておくべき。  
  
  
  
選択された実行計画はEXPLAIN で出力できる  
カラム名とその意味  
・id	  
⇒SELECT識別子。  
・select_type	  
⇒SELECT型を表す。大きく3種類からなる。「サブクエリー」「UNION」「UNIONとサブクエリーを使用しない」の三つ  
SQLでサブクエリーを使用すると「サブクエリー」となり、select_typeは以下のいずれかとなる。  
PRIMARY・・・外部クエリを示す。  
SUBQUERY・・・相関関係のないサブクエリ。  
DEPENDENT SUBQUERY・・・相関関係のあるサブクエリ。  
UNCACHEABLE SUBQUERY・・・実行する度に結果が変わる可能性のあるサブクエリ。  
DERIVED・・・FROM句で用いられているサブクエリ。  
UNION句を使用すると「UNION」になる。select_typeはPRIMARY、UNION、DEPENDENT UNION、UNION RESULTのどれか  
  
SQLでUNION句を使用すると「UNION」となり、select_typeは以下のいずれかとなる。  
PRIMARY・・・UNIONにおいて最初にフェッチされるテーブル  
UNION・・・2番目以降にフェッチされるテーブル  
UNION RESULT・・・UNIONの実行結果  
DEPENDENT UNION・・・DEPENDENT SUBQUERYがUNIONになっている場合  
UNCACHEABLE UNION・・・UNCACHEABLE SUBQUERYがUNIONになっている場合  
  
SQLでサブクエリーもUNION句も使用しないと「UNIONとサブクエリーを使用しない」となり、select_typeは以下となる。  
SIMPLE・・・単純な SELECT   
  
・table  
⇒出力行のテーブル  
・partitions	  
⇒一致するパーティション  
・type	  
⇒結合型  
constタイプは、OracleでいうINDEX UNIQUE SCANのこと  
  
possible_keys	選択可能なインデックス  
key	実際に選択されたインデックス  
key_len	選択されたキーの長さ  
ref	インデックスと比較されるカラム  
rows	調査される行の見積もり  
filtered	テーブル条件によってフィルタ処理される行の割合  
Extra	追加情報  
  
  
・トランザクション  
トランザクションを開始すると、ロールバック用の情報を保存するためディスク領域の一部を，そのトランザクションに対して割り当てます。この領域をロールバック・セグメントと呼びます。  
流れは以下  
トランザクション開始  
↓  
レコードの追加や更新などの変更を行うたびに、そのレコードを含むページの（変更前の）内容をロールバック・セグメント（メモリ上）に保存する  
↓  
REDOログ・バッファに変更の履歴を記録する。※REDOログ・バッファは，変更の履歴を記録しておくためのメモリー上のバッファで，後でディスク上のREDOログ・ファイルに内容が保存されます。  
↓  
ページの内容を更新する  
↓  
トランザクションをコミット  
↓  
トランザクションに対して、識別するための「システム変更番号（SCN）」を割り当て  
↓  
ロールバック・セグメント（メモリ上）にこの番号とコミット済みであることを記録  
↓  
REDOログ・バッファの内容を，REDOログ・ファイル（ディスク）に書き出す（メモリ上に持ったままだと、ここでシステムダウンしたとき、ロールバックセグメントとREDOログデータの両方を失ってしまう）  
↓  
トランザクション完了  
↓  
適当なタイミングでロールバック・セグメント（メモリ上）のデータをディスクに書き出す。  
詳細 http://itpro.nikkeibp.co.jp/article/COLUMN/20060118/227489/  
  
・ロックについて  
上記のトランザクションは、あくまで一人のユーザーに焦点を当てたものであり、マルチユーザーでの複数のトランザクション間制御では、「ロック」という技術が使われる  
「ロック」には以下の3種類がある  
排他ロック... レコードを更新・削除するために取得するロック。レコードに対して一つのプロセスしか取得できず、他のプロセスは読み込みや変更が出来ない。  
共有ロック... レコードを読み込むために取得するロック。レコードに対して複数のプロセスが取得可能。共有ロックがかかっているレコードには排他ロックは取得できない。  
範囲ロック... レコードを読み込むために取得するロック。特定のキーの値の範囲を共有ロックすることで、その段階ではまだ存在しないキーのINSERT・DELETEを防ぐ。  
わかりやすく言えば、  
共有ロックは、１トランザクションで読み込み結果が変わるかどうかに関係する  
排他ロックは、上記で読み込み結果が変わる場合、どのくらい変わるか※に関係する  
※他トランザクションの未コミット変更結果が参照される未コミットレベル、他トランザクションのコミット済み変更結果が参照されるコミットレベル、他トランザクションのインサート結果が参照されるインサートレベルとする（勝手に決めた）  
  
トランザクション中の各処理（読み込みや書き込み）において、この2種類のロックの使い方（ルール）を決める。  
ルール１... 読み込み：ロック無し　　書き込み：ロック無し  
ルール２... 読み込み：ロック無し　　書き込み：排他ロック  
ルール３... 読み込み：共有ロック　　書き込み：排他ロック  
ルール４... 読み込み：範囲ロック　　書き込み：排他ロック  
RDBMSは上記のどれかのルールを採用する。デフォルトはルール２。ルールはトランザクション分離レベルともいわれる。  
【ルール１：READ UNCOMMITTED分離レベル】  
読み込み結果が未コミットレベルで変わる  
  
読み込み... 対象レコードをロックしないので、他トランザクションは更新できる(読み込み結果が変わる)  
書き込み... 対象レコードをロックしないので、他トランザクションは未コミットの結果を参照・更新できる  
【ルール２：READ COMMITTED】  
読み込み結果がコミットレベルで変わる  
  
読み込み... 対象レコードをロックしないので、他トランザクションは更新できる(読み込み結果が変わる)  
書き込み... 対象レコードを排他ロックするので、他トランザクションは未コミットの結果は参照・更新出来ないが、コミットした結果はできる  
【ルール３：REPEATABLE READ】  
読み込み結果がインサートレベルで変わる  
  
読み込み... 対象レコードを共有ロックするので、他トランザクションは更新できない(読み込み結果が変わらないが、増える)  
書き込み... 対象レコードを排他ロックするので、他トランザクションは未コミットの結果は参照・更新出来ないが、コミットした結果はできる  
※共有ロックはレコードに対して行われるので、その段階でまだ存在しないレコードはロックされておらず、インサートは可能  
そのため、読み込みで範囲指定していた場合、急にレコードが増えたりする。  
【ルール４：SERIALIZABLE】  
読み込み結果が変わらない  
  
読み込み... 対象レコードを範囲ロックするので、他トランザクションは範囲内の更新・削除・挿入ができない(読み込み結果が変わらない）  
書き込み... 対象レコードを排他ロックするので、他トランザクションは未コミットの結果は参照・更新出来ないが、コミットした結果はできる  
  
【特別ルール】  
読み込みで、共有、範囲ロックをしてしまうと、他のトランザクションで更新・削除・挿入ができないため不便である。  
そのため読み込みではロックをしない実装もある。  
その場合、まずデータを読み込む際にそのデータのSCNを調べ、データの内容がトランザクション開始以降に更新されている場合には  
ロールバック・セグメントから更新前のデータを取り出して読み込む。  
そうすれば共有、範囲ロックすることなく、１トランザクションで読み込み結果が変わらない  
詳細 http://itpro.nikkeibp.co.jp/article/COLUMN/20060118/227489/?SS=imgview&FD=3561930  
  
  
  
