# ・アーキテクチャ  
OSがディスクに対して可能な最少アクセス単位はセレクタ  
一度のアクセスで１セレクタしか取得出来ないと不便なので、幾つかのセレクタをまとめたブロックという単位でアクセスする  
  
RDBMSはテーブルやインデックス等のオブジェクト毎に、ディスクに一定の領域（数ブロック分）を確保する。この領域をエクステントという。  
エクステント内にはページという論理区画が複数用意される。ページは数ブロック分のサイズである。  
RDBMSがOSにディスクアクセスを依頼するときは、ページ単位のやりとりとなる。  
  
テーブルエクステントのページには、ページのメタ情報、[rowId => レコードデータのポインタ, ...]配列(レコードディレクトリ)、空き領域、レコードデータの順で格納されている。  
空きがあるページをフリーリストとしてRDBMSが管理しており、適当なページの空きにレコードデータが追加されていくため、レコード順序は守られていない。  
あるページのレコードデータを取得するときは、レコードディレクトリの配列をなめていきレコードデータのポインタから取得する  
  
インデックスエクステントのページには、ページのメタ情報、B木構造の[キー => レコードデータのポインタ, ...]配列が格納される  
この配列はキーでソートされており、ソートアルゴリズムは？？？  
探索アルゴリズムはニ分探索  
詳細⇒http://itpro.nikkeibp.co.jp/article/COLUMN/20060113/227231/  
  
インデックスページは4種類  
プライマリーキーページ...テーブルに一つだけ＋キーに重複が無い＋NULLがない  
ユニークキーページ...キーに重複が無い  
マルチプルキーページ...特に制約はない  
複合キーページ...二つのキーの組み合わせでユニークとなる[第1キー：第2キー => レコードポインタ, ...]となり、第1キーでソートされる。  
第1キーだけWHERE句で指定するとソートされているのでインデックスを利用できるが、第2キーは第1キーが重複している分だけソートされているので、インデックスを使用できない  
詳細⇒http://use-the-index-luke.com/ja/sql/where-clause/the-equals-operator/concatenated-keys  
DESCで確認できる  
  
# ・SQL    
RDBMSはSQLを実行するまでに、三つのプログラムが連携する  
【構文解析プログラム】  
【プランナ（オプティマイザ）プログラム】  
【実行プログラム】  
  
【構文解析プログラム】  
SQLがRDBMSに渡されると、構文解析プログラムがそれを受け取る  
これは、SQLを分解し、構文ツリーを作成する  
データベースの情報（カタログという）を確認し、整合性が確保出来たらプランナ(オプティマイザ)プログラムに構文ツリーを渡す。  
  
【プランナ（オプティマイザ）プログラム】  
構文ツリーから、論理プランを作成する  
論理プランとは、最終的にSQLに対する回答を得ることができる、テーブルに対する関係代数演算（選択、射影、結合など）の一連の流れのこと。  
論理プランは、関係代数の規則や性質を利用して、出来るだけ結合の回数が少ないプランが選ばれる。  
論理プラン中の一つの関係代数演算に対応する実装モジュールは複数用意されており、一つの論理プランの実行方法（物理プラン）は複数ある。  
複数の物理プランから、カタログを利用して、もっとも処理時間が短いものを選択し、その物理プランを実行プログラムに渡す。（コストベースオプティマイザの場合）  
この作業を「最適化」という。  
※ルールベースオプティマイザではカタログは使用せず、アクセスパス（物理プラン）の順位表から選択される  
  
【実行プログラム】  
物理プランを実行する。  
  
RDBMSがテーブルを「結合」（関係代数演算）する際に利用するアルゴリズムには，  
「ネスト・ループ結合」Nested Loop 結合  
「マージ結合」  
「ハッシュ結合」  
の三つがあげらる。  
MySQL には 「結合」に対応するモジュールは一つしかなく、そのモジュールはネスト・ループ結合を使っている。  
  
ネストループ結合は最初にアクセスする表(外部表、駆動表とも呼ばれる)をフェッチし、  
そのフェッチしたデータと結合可能なデータを内部表から(インデックスがあれば利用して)検索する処理をループして結合する。  
結合の詳細⇒http://www.atmarkit.co.jp/ait/articles/0408/25/news101.html  
  
# 実行計画（どの物理プランを使うか検討する）  
論理プラン中の関係代数演算「選択」を、物理プラン中ではインデックススキャンモジュールにするか、フルスキャンモジュールにするかが主な要因となる。  

### 重要となるインデックスについて詳細にみていく　⇒　参考 http://use-the-index-luke.com/ja  
インデックスによる検索は、(1) ツリーを走査し、(2) リーフノードチェーンをたどり、(3) テーブルからデータを読み出す、という3ステップで行われる。  
Oracleデータベースではインデックスを使った基本的な検索の方法を表す、以下のような3つのはっきりした区分がある。  
INDEX UNIQUE SCAN  
木の走査しか行わない。Oracleデータベースでは、ユニーク制約により、検索条件が 必ず1つしかないことが確実な場合に、この方法を使用。  
INDEX RANGE SCAN  
一致する全ての エントリを探すために、木の走査に加えて リーフノードチェーンをたどった検索も行う。検索条件に対して複数のエントリが存在する可能性がある場合の代替策。  
TABLE ACCESS BY INDEX ROWID  
テーブルから行を読み出す。この操作は、直前に行われたインデックス スキャンの結果から、一致するレコードを読み出すために行われる。  
  
実際の処理を考えると、  
１．ユニークなインデックスを利用して、インデックスカラムのみ読みだす... INDEX UNIQUE SCAN  
２．ユニークでないインデックスを利用して、インデックスカラムのみ読みだす... INDEX RANGE SCAN  
３．ユニークなインデックスを利用して、複数カラムを読みだす... INDEX UNIQUE SCAN　⇒　TABLE ACCESS BY INDEX ROWID  
４．ユニークでないインデックスを利用して、複数カラムを読みだす... INDEX RANGE SCAN　⇒　TABLE ACCESS BY INDEX ROWID  
となる  
  
インデックスを遅くする完璧な組み合わせは、広い範囲のインデックス探索と、たくさんの行を1行ずつ読み出す処理。（４．で対象が大量な場合）  
この場合は、インデックスがあろうと、フルスキャンモジュールを使用した物理プランを選択してほしい。  
そうさせるためには、カタログを最新にしておくべき。  

### 関数インデックス
製品によってはサポートされていないが、関数インデックスというものがある。
```
CREATE INDEX emp_up_name 
    ON employees (UPPER(last_name))
```
のようなクエリで作成できる。これはlast_nameにインデックスが作成されていても、WHERE UPPER(last_name) = XXXX;で検索した時に
インデックスを利用してくれるようにするためである。  
※last_nameとUPPER(last_name)は別物扱い。  

関数インデックスを作成するためには、その関数が引数に対して固定の値を返却するもの(確定的)でなければいけない。  
例えば、引数に日付を与えると年齢を返す関数は、時が経つにつれて返却値が変わっていくためインデックスは作成できない。  
関数が確定的であるためには、確定的であると宣言したものである必要がある。 これにはDETERMINISTIC (Oracle)あるいはIMMUTABLE (PostgreSQL)を使用する。


### パラメータ化クエリ

通常のSQLは最適化の際、SQL文にあるカラムの値がどの程度の頻度で現れるかを判断するために、ヒストグラムを使う。  

「バインドパラメータ」を利用したSQLは、どのような最適化が行われるのか。 
与えられた値がどの程度の 頻度で出現するか明確な情報は持っていない。全て同じように分布していて、同じ行数の見積もり、同じコスト値が得られると推測するだけ。そのため、いつも同じ実行計画を使うことになる。  
※LIKE検索でバインドパラメータがある場合、ワイルドカードを使用した検索は行われないと判定するデータベースがほとんど。PostgreSQLは例外で全文検索を選択する

最適化のオーバーヘッドをなくすためバインドパラメータを利用するか、正しい最適化を求めてバインドパラメータを利用しないかはトレードオフ。

・実行計画のキャッシュ
SQLServerやOracleのように、実行計画をキャッシュするデータベースでは、 複数回実行される同じ文に対して同じ実行計画を再利用することができる。  
これにより、実行計画を作成し直すコストを節約できるが SQL文は完全に同じでなければならない。  
そのために「バインドパラメータ」を利用すると、同じSQL文として認識させ、実行計画キャッシュを使うことができる。
  
  
### 範囲検索
誤解を恐れずに言えば、インデックスはまず等価性を確認するためにあり、それから範囲を調べるために使われる。  
複合インデックスの場合は特に顕著にその性質が現れる。  
【SQLで where 範囲 AND 等号; 検索をした場合】    
・複合インデックスの左側が範囲検索、右側が等号検索に使われた場合  
左側が一意に決まらないので、検索範囲の最初の値があるリーフノードからINDEX RANGE SCANされる。※アクセス述語＋フィルタ述語になる。    
・複合インデックスの左側が等号検索、右側が範囲検索に使われた場合  
左側が一意に決まるのでリーフノードが一意に決まる。※全ての条件をアクセス述語として使う。  
【参考】http://use-the-index-luke.com/ja/sql/where-clause/searching-for-ranges/greater-less-between-tuning-sql-access-filter-predicates  
　　
アクセス述語は、インデックスをスキャンする範囲を定義する。  　
フィルタ述語は、スキャン後のリーフノードデータの走査時にのみ適用される。  
  
### LIKE検索
インデックスのツリー走査においてLIKEが有効なのは、最初のワイルドカードの前までだけ。  
残りの文字はスキャンされるインデックスの範囲を狭めてくれない、単なるフィルタ述語になる。  
LIKEが1つしかない表現には、(1) 最初のワイルドカードの前のアクセス述語として使われる部分、  
(2) フィルタ述語となるその他の部分、の2つの述語タイプのみがあり得ます。
  
ワイルドカードから始まるLIKE式もあり得るが、こういったLIKE式はアクセス述語としては使えない。  
そのためデータベースはテーブル全体をスキャンしなくてはならない。

### 部分インデックス
以下のクエリのようにWHERE句を使うことで部分的にインデックスを作成できる  
CREATE INDEX 〜 WHERE 条件;

### NULL
OracleではインデックスにNULL が含まれない。  
複合キーだと、どちらもNULLの場合にインデックスに含まれない。  
複合キーカラムA,Bがあり、WHERE A IS NULL;で検索するとき、「AあるいはBにNOT NULL制約」がある場合のみインデックスを使用した検索が実行される。  
※どちらもNULLの可能性が捨てきれない限り、インデックスに存在しないかもしれないのでテーブルフルスキャンしてしまう。  

### 処理しにくい条件
・日付型  
カラムに対して関数を使用しがちだが、関数インデックスを利用できないMySQLなどでは、BETWHEENの使用がおすすめ。  

・数値文字列  
```
SELECT ...
  FROM ...
 WHERE numeric_string = 42
```
のように引用符をつけ忘れると、暗黙的に  
```
SELECT ...
  FROM ...
 WHERE TO_NUMBER(numeric_string) = 42
```
となってしまうので気をつける。  
そもそも数値を保存する時は、数値型を使用する。  
また、逆の場合（数値型を文字列で検索）は、データベースが自動で変換するので問題ない。  

・バインドパラメータ  

```
SELECT first_name, last_name, subsidiary_id, employee_id
  FROM employees
 WHERE ( subsidiary_id    = :sub_id OR :sub_id IS NULL )
   AND ( employee_id      = :emp_id OR :emp_id IS NULL )
   AND ( UPPER(last_name) = :name   OR :name   IS NULL )
```
のような名前付きバインド変数を使った、フィルタを三つ用意したクエリがあったとする。  
ポイントはバインド変数にNULLを入れることで、フィルタを無効化できるところ。  
これがアンチパターンであり、オプティマイザはフィルタが３つとも無効化される最悪のパターンを想定するので、テーブルフルスキャンの実行計画を選択する。  

不要なフィルタは使用しないこと。  

・等式  
```
SELECT numeric_number
  FROM table_name
 WHERE numeric_number - 1000 > ?
```
```
SELECT a, b
  FROM table_name
 WHERE 3*a + 5 = b
```
のような等式を使ったクエリでは、関数インデックスと同じくインデックスを使用してくれない。  
関数インデックスを作成するか、以下のように定数を右辺に集めて、左辺に対するインデックスを作ればよい。  
```
CREATE INDEX math ON table_name (3*a - b)
```

### ソート処理

### グルーピング処理

### EXPLAIN
選択された実行計画はEXPLAIN で出力できる  
カラム名とその意味  
・id	  
⇒SELECT識別子。  
・select_type	  
⇒SELECT型を表す。大きく3種類からなる。「サブクエリー」「UNION」「UNIONとサブクエリーを使用しない」の三つ  
SQLでサブクエリーを使用すると「サブクエリー」となり、select_typeは以下のいずれかとなる。  
PRIMARY・・・外部クエリを示す。  
SUBQUERY・・・相関関係のないサブクエリ。  
DEPENDENT SUBQUERY・・・相関関係のあるサブクエリ。  
UNCACHEABLE SUBQUERY・・・実行する度に結果が変わる可能性のあるサブクエリ。  
DERIVED・・・FROM句で用いられているサブクエリ。  
UNION句を使用すると「UNION」になる。select_typeはPRIMARY、UNION、DEPENDENT UNION、UNION RESULTのどれか  
  
SQLでUNION句を使用すると「UNION」となり、select_typeは以下のいずれかとなる。  
PRIMARY・・・UNIONにおいて最初にフェッチされるテーブル  
UNION・・・2番目以降にフェッチされるテーブル  
UNION RESULT・・・UNIONの実行結果  
DEPENDENT UNION・・・DEPENDENT SUBQUERYがUNIONになっている場合  
UNCACHEABLE UNION・・・UNCACHEABLE SUBQUERYがUNIONになっている場合  
  
SQLでサブクエリーもUNION句も使用しないと「UNIONとサブクエリーを使用しない」となり、select_typeは以下となる。  
SIMPLE・・・単純な SELECT   
  
・table  
⇒出力行のテーブル  
・partitions	  
⇒一致するパーティション  
・type	  
⇒結合型  
constタイプは、OracleでいうINDEX UNIQUE SCANのこと  
  
possible_keys	選択可能なインデックス  
key	実際に選択されたインデックス  
key_len	選択されたキーの長さ  
ref	インデックスと比較されるカラム  
rows	調査される行の見積もり  
filtered	テーブル条件によってフィルタ処理される行の割合  
Extra	追加情報  
  
  
# ・トランザクション  
トランザクションを開始すると、ロールバック用の情報を保存するためディスク領域の一部を，そのトランザクションに対して割り当てます。この領域をロールバック・セグメントと呼びます。  
流れは以下  
トランザクション開始  
↓  
レコードの追加や更新などの変更を行うたびに、そのレコードを含むページの（変更前の）内容をロールバック・セグメント（メモリ上）に保存する  
↓  
REDOログ・バッファに変更の履歴を記録する。※REDOログ・バッファは，変更の履歴を記録しておくためのメモリー上のバッファで，後でディスク上のREDOログ・ファイルに内容が保存されます。  
↓  
ページの内容を更新する  
↓  
トランザクションをコミット  
↓  
トランザクションに対して、識別するための「システム変更番号（SCN）」を割り当て  
↓  
ロールバック・セグメント（メモリ上）にこの番号とコミット済みであることを記録  
↓  
REDOログ・バッファの内容を，REDOログ・ファイル（ディスク）に書き出す（メモリ上に持ったままだと、ここでシステムダウンしたとき、ロールバックセグメントとREDOログデータの両方を失ってしまう）  
↓  
トランザクション完了  
↓  
適当なタイミングでロールバック・セグメント（メモリ上）のデータをディスクに書き出す。  
詳細 http://itpro.nikkeibp.co.jp/article/COLUMN/20060118/227489/  
  
# ・ロックについて  
上記のトランザクションは、あくまで一人のユーザーに焦点を当てたものであり、マルチユーザーでの複数のトランザクション間制御では、「ロック」という技術が使われる  
「ロック」には以下の3種類がある  
排他ロック... レコードを更新・削除するために取得するロック。レコードに対して一つのプロセスしか取得できず、他のプロセスは読み込みや変更が出来ない。  
共有ロック... レコードを読み込むために取得するロック。レコードに対して複数のプロセスが取得可能。共有ロックがかかっているレコードには排他ロックは取得できない。  
範囲ロック... レコードを読み込むために取得するロック。特定のキーの値の範囲を共有ロックすることで、その段階ではまだ存在しないキーのINSERT・DELETEを防ぐ。  
わかりやすく言えば、  
共有ロックは、１トランザクションで読み込み結果が変わるかどうかに関係する  
排他ロックは、上記で読み込み結果が変わる場合、どのくらい変わるか※に関係する  
※他トランザクションの未コミット変更結果が参照される未コミットレベル、他トランザクションのコミット済み変更結果が参照されるコミットレベル、他トランザクションのインサート結果が参照されるインサートレベルとする（勝手に決めた）  
  
トランザクション中の各処理（読み込みや書き込み）において、この2種類のロックの使い方（ルール）を決める。  
ルール１... 読み込み：ロック無し　　書き込み：ロック無し  
ルール２... 読み込み：ロック無し　　書き込み：排他ロック  
ルール３... 読み込み：共有ロック　　書き込み：排他ロック  
ルール４... 読み込み：範囲ロック　　書き込み：排他ロック  
RDBMSは上記のどれかのルールを採用する。デフォルトはルール２。ルールはトランザクション分離レベルともいわれる。  
【ルール１：READ UNCOMMITTED分離レベル】  
読み込み結果が未コミットレベルで変わる  
  
読み込み... 対象レコードをロックしないので、他トランザクションは更新できる(読み込み結果が変わる)  
書き込み... 対象レコードをロックしないので、他トランザクションは未コミットの結果を参照・更新できる  
【ルール２：READ COMMITTED】  
読み込み結果がコミットレベルで変わる  
  
読み込み... 対象レコードをロックしないので、他トランザクションは更新できる(読み込み結果が変わる)  
書き込み... 対象レコードを排他ロックするので、他トランザクションは未コミットの結果は参照・更新出来ないが、コミットした結果はできる  
【ルール３：REPEATABLE READ】  
読み込み結果がインサートレベルで変わる  
  
読み込み... 対象レコードを共有ロックするので、他トランザクションは更新できない(読み込み結果が変わらないが、増える)  
書き込み... 対象レコードを排他ロックするので、他トランザクションは未コミットの結果は参照・更新出来ないが、コミットした結果はできる  
※共有ロックはレコードに対して行われるので、その段階でまだ存在しないレコードはロックされておらず、インサートは可能  
そのため、読み込みで範囲指定していた場合、急にレコードが増えたりする。  
【ルール４：SERIALIZABLE】  
読み込み結果が変わらない  
  
読み込み... 対象レコードを範囲ロックするので、他トランザクションは範囲内の更新・削除・挿入ができない(読み込み結果が変わらない）  
書き込み... 対象レコードを排他ロックするので、他トランザクションは未コミットの結果は参照・更新出来ないが、コミットした結果はできる  
  
【特別ルール】  
読み込みで、共有、範囲ロックをしてしまうと、他のトランザクションで更新・削除・挿入ができないため不便である。  
そのため読み込みではロックをしない実装もある。  
その場合、まずデータを読み込む際にそのデータのSCNを調べ、データの内容がトランザクション開始以降に更新されている場合には  
ロールバック・セグメントから更新前のデータを取り出して読み込む。  
そうすれば共有、範囲ロックすることなく、１トランザクションで読み込み結果が変わらない  
詳細 http://itpro.nikkeibp.co.jp/article/COLUMN/20060118/227489/?SS=imgview&FD=3561930  
  
  
  
